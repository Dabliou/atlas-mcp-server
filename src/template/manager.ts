import { Resource, ResourceTemplate } from '@modelcontextprotocol/sdk/types.js';
import { TaskManager } from '../task/manager/task-manager.js';
import { TaskType } from '../types/task-types.js';
import { TemplateStorage } from '../storage/interfaces/template-storage.js';
import { PathUtils } from '../utils/path-utils.js';
import {
  TaskTemplate,
  TemplateInfo,
  TemplateInstantiationOptions,
  TemplateTask,
} from '../types/template.js';
import { TemplateLoader } from './loader/template-loader.js';
import { VariableInterpolator } from './interpolation/variable-interpolator.js';
import { MetadataTransformer } from './interpolation/metadata-transformer.js';
import { TemplateErrorFactory } from '../errors/template-error.js';
import { Logger } from '../logging/index.js';

/**
 * Manages task templates including storage, validation, and instantiation
 */
export class TemplateManager {
  private readonly loader: TemplateLoader;
  private readonly interpolator: VariableInterpolator;
  private readonly transformer: MetadataTransformer;
  private readonly processingTemplates: Set<string> = new Set();
  private readonly logger: Logger;

  constructor(
    private readonly storage: TemplateStorage,
    private readonly taskManager: TaskManager
  ) {
    this.loader = new TemplateLoader(storage);
    this.interpolator = new VariableInterpolator();
    this.transformer = new MetadataTransformer();
    this.logger = Logger.getInstance().child({ component: 'TemplateManager' });
  }

  /**
   * Initialize the template system
   */
  async initialize(templateDirs: string[]): Promise<void> {
    await this.storage.initialize();
    await this.loader.initialize(templateDirs);
  }

  /**
   * List available templates
   */
  async listTemplates(tag?: string): Promise<TemplateInfo[]> {
    return this.storage.listTemplates(tag);
  }

  /**
   * Get a specific template by ID
   */
  async getTemplate(id: string): Promise<TaskTemplate> {
    return this.storage.getTemplate(id);
  }

  /**
   * Create parent task if it doesn't exist
   */
  private async ensureParentExists(
    parentPath: string,
    variables: Record<string, unknown>
  ): Promise<void> {
    const parentTask = await this.taskManager.getTask(parentPath);
    if (!parentTask) {
      this.logger.info(`Creating parent task: ${parentPath}`);

      // Extract project name from variables or path
      const projectName =
        (variables.projectName as string) ||
        PathUtils.getLastSegment(parentPath).replace(/[-_]/g, ' ');

      // Create parent task
      await this.taskManager.createTask({
        path: parentPath,
        name: projectName,
        type: TaskType.MILESTONE,
        description: `Auto-generated parent task for template instantiation. Project: ${projectName}`,
        metadata: {
          autoGenerated: true,
          generatedBy: 'template-manager',
          timestamp: Date.now(),
          variables: variables,
        },
      });

      this.logger.info(`Created parent task: ${parentPath}`);
    }
  }

  /**
   * Sort tasks by dependencies and parent-child relationships
   */
  private async sortTasks(
    tasks: TemplateTask[],
    variables: Record<string, unknown>,
    parentPath?: string
  ): Promise<TemplateTask[]> {
    const taskMap = new Map<string, TemplateTask>();
    const graph = new Map<string, Set<string>>();

    // Build dependency graph
    for (const task of tasks) {
      const normalizedPath = parentPath
        ? PathUtils.normalizePath(
            PathUtils.joinPath(
              parentPath,
              this.interpolator.interpolateString(task.path, variables)
            )
          )
        : PathUtils.normalizePath(this.interpolator.interpolateString(task.path, variables));

      taskMap.set(normalizedPath, task);
      graph.set(normalizedPath, new Set());

      // Add explicit dependencies
      if (task.dependencies) {
        for (const dep of task.dependencies) {
          const normalizedDep = parentPath
            ? PathUtils.normalizePath(
                PathUtils.joinPath(parentPath, this.interpolator.interpolateString(dep, variables))
              )
            : PathUtils.normalizePath(this.interpolator.interpolateString(dep, variables));

          if (!graph.has(normalizedDep)) {
            graph.set(normalizedDep, new Set());
          }
          graph.get(normalizedPath)?.add(normalizedDep);
        }
      }

      // Add implicit parent dependency
      const pathParts = normalizedPath.split('/');
      if (pathParts.length > 1) {
        const parentPath = pathParts.slice(0, -1).join('/');
        if (!graph.has(parentPath)) {
          graph.set(parentPath, new Set());
        }
        graph.get(normalizedPath)?.add(parentPath);
      }
    }

    // Topological sort
    const visited = new Set<string>();
    const sorted: string[] = [];

    const visit = (path: string) => {
      if (visited.has(path)) return;
      visited.add(path);

      for (const dep of graph.get(path) || []) {
        visit(dep);
      }

      sorted.push(path);
    };

    for (const path of graph.keys()) {
      visit(path);
    }

    // Convert back to tasks
    return sorted
      .map(path => taskMap.get(path))
      .filter((task): task is TemplateTask => task !== undefined);
  }

  /**
   * Instantiate a template with provided variables
   */
  async instantiateTemplate(options: TemplateInstantiationOptions): Promise<void> {
    if (this.processingTemplates.has(options.templateId)) {
      throw TemplateErrorFactory.createCycleError(
        `Circular template reference detected: ${options.templateId}`,
        'TemplateManager.instantiateTemplate',
        { templateId: options.templateId }
      );
    }

    this.processingTemplates.add(options.templateId);

    try {
      const template = await this.getTemplate(options.templateId);

      // Combine provided variables with defaults
      const variables = { ...options.variables };
      for (const v of template.variables) {
        if (!(v.name in variables) && 'default' in v) {
          variables[v.name] = v.default;
        }
      }

      // Validate required variables
      const missingVars = this.interpolator.validateRequiredVariables(
        template.variables,
        variables
      );
      if (missingVars.length) {
        throw TemplateErrorFactory.createValidationError(
          `Missing required variables: ${missingVars.join(', ')}`,
          'TemplateManager.instantiateTemplate',
          { missingVariables: missingVars }
        );
      }

      // Create parent path if provided
      if (options.parentPath) {
        await this.ensureParentExists(options.parentPath, variables);
      }

      // Sort tasks by dependencies and parent-child relationships
      const sortedTasks = await this.sortTasks(template.tasks, variables, options.parentPath);

      // Create tasks in order
      for (const task of sortedTasks) {
        await this.processTemplateTask(task, variables, options.parentPath);
      }
    } finally {
      this.processingTemplates.delete(options.templateId);
    }
  }

  /**
   * Process a single template task
   */
  private async processTemplateTask(
    task: TemplateTask,
    variables: Record<string, unknown>,
    parentPath?: string
  ): Promise<void> {
    // Interpolate variables in strings and metadata first
    const interpolatedTask = {
      path: this.interpolator.interpolateString(task.path, variables),
      title: this.interpolator.interpolateString(task.title, variables),
      type: task.type,
      description: task.description
        ? this.interpolator.interpolateString(task.description, variables)
        : undefined,
      dependencies: task.dependencies?.map(d => this.interpolator.interpolateString(d, variables)),
      metadata: task.metadata
        ? this.interpolator.interpolateMetadata(task.metadata, variables)
        : undefined,
    };

    // Normalize paths
    let normalizedPath = parentPath
      ? PathUtils.normalizePath(PathUtils.joinPath(parentPath, interpolatedTask.path))
      : PathUtils.normalizePath(interpolatedTask.path);

    // Remove redundant project name segments
    const pathSegments = normalizedPath.split('/');
    const projectName = pathSegments[0];
    const cleanedSegments = pathSegments.filter((segment, index) => {
      // Keep the first occurrence of project name
      if (index === 0) return true;
      // Remove redundant project name segments
      return !segment.toLowerCase().includes(projectName.toLowerCase());
    });
    normalizedPath = cleanedSegments.join('/');

    interpolatedTask.path = normalizedPath;

    // Extract parent path from normalized path
    const pathParts = normalizedPath.split('/');
    const implicitParentPath = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : undefined;

    // Normalize dependency paths
    if (interpolatedTask.dependencies) {
      interpolatedTask.dependencies = interpolatedTask.dependencies.map(d => {
        let normalizedDep = parentPath
          ? PathUtils.normalizePath(PathUtils.joinPath(parentPath, d))
          : PathUtils.normalizePath(d);

        // Clean dependency paths too
        const depSegments = normalizedDep.split('/');
        const cleanedDepSegments = depSegments.filter((segment, index) => {
          if (index === 0) return true;
          return !segment.toLowerCase().includes(projectName.toLowerCase());
        });
        normalizedDep = cleanedDepSegments.join('/');

        return normalizedDep;
      });
    }

    // Transform the interpolated metadata
    const transformedMetadata = interpolatedTask.metadata
      ? this.transformer.transform(interpolatedTask.metadata)
      : undefined;

    // Check for nested template reference
    const templateRef =
      transformedMetadata && this.transformer.extractTemplateRef(transformedMetadata);

    // Ensure parent task exists first
    if (implicitParentPath) {
      await this.ensureParentExists(implicitParentPath, variables);
    }

    if (templateRef) {
      // Create the task without the templateRef
      const cleanMetadata = this.transformer.removeTemplateRef(transformedMetadata);
      await this.taskManager.createTask({
        path: interpolatedTask.path,
        name: interpolatedTask.title,
        description: interpolatedTask.description,
        type: interpolatedTask.type === 'TASK' ? TaskType.TASK : TaskType.MILESTONE,
        metadata: cleanMetadata,
        dependencies: interpolatedTask.dependencies,
        parentPath: implicitParentPath,
      });

      // Process nested template
      await this.instantiateTemplate({
        templateId: templateRef.template,
        variables: templateRef.variables,
        parentPath: interpolatedTask.path,
      });
    } else {
      // Create task normally
      await this.taskManager.createTask({
        path: interpolatedTask.path,
        name: interpolatedTask.title,
        description: interpolatedTask.description,
        type: interpolatedTask.type === 'TASK' ? TaskType.TASK : TaskType.MILESTONE,
        metadata: transformedMetadata,
        dependencies: interpolatedTask.dependencies,
        parentPath: implicitParentPath,
      });
    }
  }

  /**
   * Save a new template or update an existing one
   */
  async saveTemplate(template: TaskTemplate): Promise<void> {
    await this.storage.saveTemplate(template);
  }

  /**
   * Clean up resources
   */
  async close(): Promise<void> {
    await this.loader.close();
    await this.storage.close();
  }

  // Resource-related methods
  async listTemplateResources(): Promise<Resource[]> {
    return [
      {
        uri: 'templates://current',
        name: 'Available Templates',
        description: 'List of all available task templates with their metadata and variables',
        mimeType: 'application/json',
      },
    ];
  }

  async getTemplateResource(uri: string): Promise<Resource> {
    if (uri !== 'templates://current') {
      throw TemplateErrorFactory.createNotFoundError(
        `Invalid template resource URI: ${uri}`,
        'TemplateManager.getTemplateResource',
        { uri }
      );
    }

    // Get full template details for each template
    const templateInfos = await this.listTemplates();
    const fullTemplates = await Promise.all(templateInfos.map(info => this.getTemplate(info.id)));

    const templateOverview = {
      timestamp: new Date().toISOString(),
      totalTemplates: fullTemplates.length,
      templates: fullTemplates.map(template => ({
        id: template.id,
        name: template.name,
        description: template.description,
        tags: template.tags,
        variables: template.variables.map(v => ({
          name: v.name,
          description: v.description,
          required: v.required,
          default: v.default,
        })),
      })),
    };

    return {
      uri,
      name: 'Available Templates',
      mimeType: 'application/json',
      text: JSON.stringify(templateOverview, null, 2),
    };
  }

  async getResourceTemplates(): Promise<ResourceTemplate[]> {
    return []; // No dynamic templates needed since we use a single resource
  }

  async resolveResourceTemplate(template: string, vars: Record<string, string>): Promise<Resource> {
    throw TemplateErrorFactory.createValidationError(
      `Resource templates not supported - use templates://current instead (attempted to resolve template "${template}" with variables ${JSON.stringify(vars)})`,
      'TemplateManager.resolveResourceTemplate',
      { template, vars }
    );
  }
}
