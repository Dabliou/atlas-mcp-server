This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T11:56:56.856Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    index.ts
  errors/
    index.ts
  logging/
    index.ts
  server/
    health-monitor.ts
    index.ts
    metrics-collector.ts
    rate-limiter.ts
    request-tracer.ts
  storage/
    connection-manager.ts
    factory.ts
    index.ts
    sqlite-storage.ts
  task/
    core/
      batch/
        base-batch-processor.ts
        dependency-aware-batch-processor.ts
        generic-batch-processor.ts
        index.ts
        task-status-batch-processor.ts
      cache/
        cache-manager.ts
        cache-types.ts
      indexing/
        index-manager.ts
      transactions/
        transaction-manager.ts
        transaction-types.ts
      dependency-validator.ts
      index.ts
      status-manager.ts
      task-store.ts
  tools/
    handler.ts
    index.ts
    schemas.ts
    session-schemas.ts
    utils.ts
  types/
    batch.ts
    config.ts
    error.ts
    index.ts
    indexing.ts
    logging.ts
    project.ts
    session.ts
    storage.ts
    task.ts
  utils/
    id-generator.ts
    pattern-matcher.ts
  validation/
    config.ts
    id-schema.ts
    index.ts
    logging.ts
    task.ts
  index.ts
  task-manager.ts
  types.ts
.eslintrc.json
implementation-plan.md
jest.config.js
LICENSE
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/config/index.ts
================
/**
 * Configuration module
 * Handles application configuration management
 */

import { ConfigError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels } from '../types/logging.js';

/**
 * Environment variable names
 */
export const EnvVars = {
    NODE_ENV: 'NODE_ENV',
    LOG_LEVEL: 'LOG_LEVEL',
    TASK_STORAGE_DIR: 'TASK_STORAGE_DIR'
} as const;

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

/**
 * Logging configuration type
 */
export interface LoggingConfig {
    level: LogLevel;
    console: boolean;
    file: boolean;
    dir?: string;
    maxFiles: number;
    maxSize: number;
}

/**
 * Configuration schema
 */
export const configSchema = {
    env: {
        type: 'string',
        enum: [
            Environments.DEVELOPMENT,
            Environments.PRODUCTION,
            Environments.TEST
        ],
        default: Environments.DEVELOPMENT
    },
    logging: {
        type: 'object',
        properties: {
            level: {
                type: 'string',
                enum: [
                    LogLevels.ERROR,
                    LogLevels.WARN,
                    LogLevels.INFO,
                    LogLevels.HTTP,
                    LogLevels.VERBOSE,
                    LogLevels.DEBUG,
                    LogLevels.SILLY
                ],
                default: LogLevels.INFO
            },
            console: {
                type: 'boolean',
                default: true
            },
            file: {
                type: 'boolean',
                default: false
            },
            dir: {
                type: 'string',
                optional: true
            },
            maxFiles: {
                type: 'number',
                minimum: 1,
                default: 5
            },
            maxSize: {
                type: 'number',
                minimum: 1024,
                default: 5242880 // 5MB
            }
        },
        required: ['level']
    },
    storage: {
        type: 'object',
        properties: {
            baseDir: {
                type: 'string'
            },
            name: {
                type: 'string'
            },
            connection: {
                type: 'object',
                properties: {
                    maxRetries: {
                        type: 'number',
                        minimum: 1,
                        optional: true
                    },
                    retryDelay: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    busyTimeout: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            },
            performance: {
                type: 'object',
                properties: {
                    checkpointInterval: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    cacheSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    mmapSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    pageSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            }
        },
        required: ['baseDir', 'name']
    }
};

/**
 * Default logging configuration
 */
const defaultLoggingConfig: LoggingConfig = {
    level: LogLevels.INFO,
    console: true,
    file: false,
    maxFiles: 5,
    maxSize: 5242880
};

/**
 * Default configuration values
 */
export const defaultConfig = {
    env: Environments.DEVELOPMENT,
    logging: defaultLoggingConfig
};

/**
 * Configuration manager class
 */
export class ConfigManager {
    private static instance: ConfigManager;
    private config: any;

    private constructor(initialConfig: any = {}) {
        this.config = this.loadConfig(initialConfig);
    }

    /**
     * Gets the configuration manager instance
     */
    static getInstance(): ConfigManager {
        if (!ConfigManager.instance) {
            ConfigManager.instance = new ConfigManager();
        }
        return ConfigManager.instance;
    }

    /**
     * Initializes the configuration manager with custom config
     */
    static initialize(config: any): void {
        if (ConfigManager.instance) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Configuration already initialized'
            );
        }
        ConfigManager.instance = new ConfigManager(config);
    }

    /**
     * Gets the current configuration
     */
    getConfig(): any {
        return { ...this.config };
    }

    /**
     * Updates the configuration
     */
    updateConfig(updates: any): void {
        const newConfig = {
            ...this.config,
            ...updates,
            logging: {
                ...this.config.logging,
                ...(updates.logging || {})
            },
            storage: {
                ...this.config.storage,
                ...(updates.storage || {})
            }
        };

        this.validateConfig(newConfig);
        this.config = newConfig;
    }

    /**
     * Loads and validates configuration
     */
    private loadConfig(customConfig: any): any {
        try {
            // Load from environment
            const envConfig = this.loadEnvConfig(customConfig);

            // Merge configurations with precedence:
            // custom > environment > default
            const mergedConfig = {
                ...defaultConfig,
                ...envConfig,
                ...customConfig,
                logging: {
                    ...defaultLoggingConfig,
                    ...(envConfig.logging || {}),
                    ...(customConfig.logging || {})
                },
                storage: {
                    ...(envConfig.storage || {}),
                    ...(customConfig.storage || {})
                }
            };

            // Validate final configuration
            this.validateConfig(mergedConfig);

            return mergedConfig;
        } catch (error) {
            if (error instanceof ConfigError) {
                throw error;
            }
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Failed to load configuration',
                error
            );
        }
    }

    /**
     * Loads configuration from environment variables
     */
    private loadEnvConfig(customConfig: any): any {
        const env = process.env[EnvVars.NODE_ENV];
        const logLevel = process.env[EnvVars.LOG_LEVEL];
        const storageDir = customConfig.storage?.baseDir || process.env[EnvVars.TASK_STORAGE_DIR];

        if (!storageDir) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage directory must be provided'
            );
        }

        const config: any = {
            storage: {
                baseDir: storageDir,
                name: 'atlas-tasks',
                connection: {
                    maxRetries: 3,
                    retryDelay: 1000,
                    busyTimeout: 5000
                },
                performance: {
                    checkpointInterval: 300000, // 5 minutes
                    cacheSize: 2000,
                    mmapSize: 30000000000, // 30GB
                    pageSize: 4096
                }
            },
            logging: { ...defaultLoggingConfig }
        };

        if (env) {
            if (!Object.values(Environments).includes(env as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid environment'
                );
            }
            config.env = env;
        }

        if (logLevel) {
            const level = logLevel.toLowerCase();
            if (!Object.values(LogLevels).includes(level as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid log level'
                );
            }
            config.logging!.level = level;
        }

        return config;
    }

    /**
     * Validates configuration against schema
     */
    private validateConfig(config: any): void {
        // Basic validation - could be expanded
        if (!config.storage?.baseDir) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage directory must be provided'
            );
        }

        if (config.logging?.level && !Object.values(LogLevels).includes(config.logging.level)) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Invalid log level'
            );
        }
    }
}

/**
 * Creates a default configuration manager
 */
export function createDefaultConfig(): ConfigManager {
    return ConfigManager.getInstance();
}

================
File: src/errors/index.ts
================
/**
 * Error handling module
 * Provides centralized error handling and error types with detailed guidance
 */

import { z } from 'zod';

/**
 * Error codes enumeration with categories
 */
export const ErrorCodes = {
    // Task errors (1000-1999)
    TASK_NOT_FOUND: 'TASK_1001',
    TASK_VALIDATION: 'TASK_1002',
    TASK_DEPENDENCY: 'TASK_1003',
    TASK_STATUS: 'TASK_1004',
    TASK_DUPLICATE: 'TASK_1005',
    TASK_INVALID_PATH: 'TASK_1014',
    TASK_INVALID_TYPE: 'TASK_1006',
    TASK_INVALID_STATUS: 'TASK_1007',
    TASK_INVALID_PARENT: 'TASK_1008',
    TASK_PARENT_NOT_FOUND: 'TASK_1009',
    TASK_PARENT_TYPE: 'TASK_1010',
    TASK_DUPLICATE_NAME: 'TASK_1011',
    TASK_LOCKED: 'TASK_1012',
    TASK_CYCLE: 'TASK_1013',

    // Storage errors (2000-2999)
    STORAGE_READ: 'STORAGE_2001',
    STORAGE_WRITE: 'STORAGE_2002',
    STORAGE_DELETE: 'STORAGE_2003',
    STORAGE_ERROR: 'STORAGE_2004',
    STORAGE_INIT: 'STORAGE_2005',
    STORAGE_INIT_ERROR: 'STORAGE_2006',

    // Configuration errors (3000-3999)
    CONFIG_INVALID: 'CONFIG_3001',
    CONFIG_MISSING: 'CONFIG_3002',
    CONFIG_TYPE_ERROR: 'CONFIG_3003',

    // Validation errors (4000-4999)
    VALIDATION_ERROR: 'VALIDATION_4001',
    INVALID_INPUT: 'VALIDATION_4002',
    INVALID_STATE: 'VALIDATION_4003',

    // Operation errors (5000-5999)
    OPERATION_FAILED: 'OPERATION_5001',
    NOT_IMPLEMENTED: 'OPERATION_5002',
    INTERNAL_ERROR: 'OPERATION_5003',
    CONCURRENT_MODIFICATION: 'OPERATION_5004',
    TIMEOUT: 'OPERATION_5005'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

/**
 * Error messages with detailed explanations and recovery suggestions
 */
export const ErrorMessages: Record<ErrorCode, { message: string; suggestion: string }> = {
    // Task errors
    [ErrorCodes.TASK_NOT_FOUND]: {
        message: 'Task not found',
        suggestion: 'Verify the task ID and ensure it exists in the system'
    },
    [ErrorCodes.TASK_VALIDATION]: {
        message: 'Task validation failed',
        suggestion: 'Check task properties against schema requirements'
    },
    [ErrorCodes.TASK_DEPENDENCY]: {
        message: 'Invalid task dependency',
        suggestion: 'Ensure all dependent tasks exist and are valid. Common issues:\n' +
                   '1. Referenced task does not exist\n' +
                   '2. Dependency creates a circular reference\n' +
                   '3. Dependent task is in a failed or blocked state\n' +
                   '4. Dependencies specified in both task and metadata (use task.dependencies instead)'
    },
    [ErrorCodes.TASK_STATUS]: {
        message: 'Invalid task status transition',
        suggestion: 'Follow the allowed status transition flow: pending → in_progress → completed'
    },
    [ErrorCodes.TASK_DUPLICATE]: {
        message: 'Task already exists',
        suggestion: 'Use a unique task identifier or update the existing task'
    },
    [ErrorCodes.TASK_INVALID_TYPE]: {
        message: 'Invalid task type',
        suggestion: 'Use one of: task, milestone, or group'
    },
    [ErrorCodes.TASK_INVALID_STATUS]: {
        message: 'Invalid task status value',
        suggestion: 'Use one of: pending, in_progress, completed, failed, or blocked'
    },
    [ErrorCodes.TASK_INVALID_PARENT]: {
        message: 'Invalid parent-child relationship',
        suggestion: 'Check parent task existence and type compatibility'
    },
    [ErrorCodes.TASK_PARENT_NOT_FOUND]: {
        message: 'Parent task not found',
        suggestion: 'Verify the parent task ID exists in the system'
    },
    [ErrorCodes.TASK_PARENT_TYPE]: {
        message: 'Invalid parent task type',
        suggestion: 'Parent tasks must be of type "group" or "milestone". Regular tasks cannot contain subtasks.'
    },
    [ErrorCodes.TASK_DUPLICATE_NAME]: {
        message: 'Duplicate task name in scope',
        suggestion: 'Task names must be unique within the same level (either as root tasks or under the same parent)'
    },
    [ErrorCodes.TASK_LOCKED]: {
        message: 'Task is locked by another operation',
        suggestion: 'Wait a few seconds and retry the operation'
    },
    [ErrorCodes.TASK_CYCLE]: {
        message: 'Circular dependency detected',
        suggestion: 'Review and restructure task dependencies to eliminate cycles. Steps to resolve:\n' +
                   '1. Identify the cycle path in the error message\n' +
                   '2. Break the cycle by removing one of the dependencies\n' +
                   '3. Consider using task ordering or parent-child relationships instead\n' +
                   '4. Ensure dependencies flow in one direction'
    },
    [ErrorCodes.TASK_INVALID_PATH]: {
        message: 'Invalid task path format',
        suggestion: 'Task paths must:\n' +
                   '1. Contain only alphanumeric characters, hyphens, and forward slashes\n' +
                   '2. Not exceed 8 levels of depth\n' +
                   '3. Not start or end with a slash\n' +
                   '4. Use lowercase characters'
    },

    // Storage errors
    [ErrorCodes.STORAGE_READ]: {
        message: 'Failed to read from storage',
        suggestion: 'Check storage permissions and connectivity'
    },
    [ErrorCodes.STORAGE_WRITE]: {
        message: 'Failed to write to storage',
        suggestion: 'Verify storage capacity and permissions'
    },
    [ErrorCodes.STORAGE_DELETE]: {
        message: 'Failed to delete from storage',
        suggestion: 'Check if item exists and you have delete permissions'
    },
    [ErrorCodes.STORAGE_ERROR]: {
        message: 'Storage operation failed',
        suggestion: 'Verify storage system health and connectivity'
    },
    [ErrorCodes.STORAGE_INIT]: {
        message: 'Failed to initialize storage',
        suggestion: 'Check storage configuration and permissions'
    },
    [ErrorCodes.STORAGE_INIT_ERROR]: {
        message: 'Storage initialization error',
        suggestion: 'Verify storage prerequisites and configuration'
    },

    // Configuration errors
    [ErrorCodes.CONFIG_INVALID]: {
        message: 'Invalid configuration',
        suggestion: 'Review configuration against schema requirements'
    },
    [ErrorCodes.CONFIG_MISSING]: {
        message: 'Required configuration missing',
        suggestion: 'Provide all required configuration parameters'
    },
    [ErrorCodes.CONFIG_TYPE_ERROR]: {
        message: 'Configuration type error',
        suggestion: 'Ensure configuration values match expected types'
    },

    // Validation errors
    [ErrorCodes.VALIDATION_ERROR]: {
        message: 'Validation failed',
        suggestion: 'Check input against validation requirements. Common issues: missing required fields, invalid field types, or constraint violations. Review the validation error details for specific field issues.'
    },
    [ErrorCodes.INVALID_INPUT]: {
        message: 'Invalid input provided',
        suggestion: 'Review input format and requirements'
    },
    [ErrorCodes.INVALID_STATE]: {
        message: 'Invalid state',
        suggestion: 'Ensure operation is valid for current state'
    },

    // Operation errors
    [ErrorCodes.OPERATION_FAILED]: {
        message: 'Operation failed',
        suggestion: 'Check error details and retry operation'
    },
    [ErrorCodes.NOT_IMPLEMENTED]: {
        message: 'Feature not implemented',
        suggestion: 'This feature is planned but not yet available'
    },
    [ErrorCodes.INTERNAL_ERROR]: {
        message: 'Internal error occurred',
        suggestion: 'Contact system administrator if problem persists'
    },
    [ErrorCodes.CONCURRENT_MODIFICATION]: {
        message: 'Concurrent modification detected',
        suggestion: 'Refresh data and retry operation'
    },
    [ErrorCodes.TIMEOUT]: {
        message: 'Operation timed out',
        suggestion: 'Check system load and retry operation'
    }
};

/**
 * Base error class for all application errors
 */
export class BaseError extends Error {
    constructor(
        public readonly code: ErrorCode,
        message: string,
        public readonly details?: unknown,
        public readonly suggestion?: string
    ) {
        super(message);
        this.name = this.constructor.name;
        this.suggestion = suggestion || ErrorMessages[code]?.suggestion;
    }

    /**
     * Gets a user-friendly error message with guidance
     */
    public getUserMessage(): string {
        const baseMessage = this.message || ErrorMessages[this.code]?.message;
        const suggestion = this.suggestion || ErrorMessages[this.code]?.suggestion;
        return `${baseMessage}${suggestion ? `\nSuggestion: ${suggestion}` : ''}`;
    }
}

/**
 * Task-related errors
 */
export class TaskError extends BaseError {
    constructor(code: ErrorCode, message: string, details?: unknown, suggestion?: string) {
        super(code, message, details, suggestion);
    }
}

/**
 * Configuration-related errors
 */
export class ConfigError extends BaseError {
    constructor(code: ErrorCode, message: string, details?: unknown, suggestion?: string) {
        super(code, message, details, suggestion);
    }
}

/**
 * Storage-related errors
 */
export class StorageError extends BaseError {
    constructor(code: ErrorCode, message: string, details?: unknown, suggestion?: string) {
        super(code, message, details, suggestion);
    }
}

/**
 * Validation-related errors
 */
export class ValidationError extends BaseError {
    constructor(
        code: ErrorCode,
        message: string,
        public readonly validationErrors?: Array<{
            field: string;
            error: string;
            received?: unknown;
            expected?: string;
        }>,
        details?: unknown,
        suggestion?: string
    ) {
        const formattedMessage = validationErrors 
            ? `${message}\nValidation Errors:\n${validationErrors.map(
                err => `- ${err.field}: ${err.error}${err.received ? ` (received: ${JSON.stringify(err.received)})` : ''}${err.expected ? ` (expected: ${err.expected})` : ''}`
              ).join('\n')}`
            : message;
        super(code, formattedMessage, details, suggestion);
    }

    /**
     * Creates a validation error from Zod validation issues
     */
    static fromZodError(error: z.ZodError): ValidationError {
        const validationErrors = error.errors.map((err: z.ZodIssue) => {
            const base = {
                field: err.path.join('.'),
                error: err.message
            };

            // Handle different types of Zod issues
            if (err.code === 'invalid_type') {
                return {
                    ...base,
                    received: err.received,
                    expected: err.expected
                };
            }

            if (err.code === 'invalid_enum_value') {
                return {
                    ...base,
                    received: err.received,
                    expected: err.options.join(' | ')
                };
            }

            if (err.code === 'too_small') {
                return {
                    ...base,
                    received: 'value too small',
                    expected: `${err.type === 'string' ? 'length' : 'value'} >= ${(err as z.ZodTooSmallIssue).minimum}`
                };
            }

            if (err.code === 'too_big') {
                return {
                    ...base,
                    received: 'value too big',
                    expected: `${err.type === 'string' ? 'length' : 'value'} <= ${(err as z.ZodTooBigIssue).maximum}`
                };
            }

            // Default case for other types of errors
            return base;
        });

        return new ValidationError(
            ErrorCodes.VALIDATION_ERROR,
            'Task validation failed',
            validationErrors
        );
    }
}

/**
 * Creates an error with a standard message and suggestion
 */
export function createError(
    code: ErrorCode,
    details?: unknown,
    customMessage?: string,
    customSuggestion?: string
): BaseError {
    const message = customMessage || ErrorMessages[code]?.message;
    const suggestion = customSuggestion || ErrorMessages[code]?.suggestion;

    switch (code) {
        case ErrorCodes.TASK_NOT_FOUND:
        case ErrorCodes.TASK_VALIDATION:
        case ErrorCodes.TASK_DEPENDENCY:
        case ErrorCodes.TASK_STATUS:
        case ErrorCodes.TASK_DUPLICATE:
        case ErrorCodes.TASK_INVALID_TYPE:
        case ErrorCodes.TASK_INVALID_STATUS:
        case ErrorCodes.TASK_INVALID_PARENT:
        case ErrorCodes.TASK_LOCKED:
        case ErrorCodes.TASK_CYCLE:
            return new TaskError(code, message, details, suggestion);

        case ErrorCodes.CONFIG_INVALID:
        case ErrorCodes.CONFIG_MISSING:
        case ErrorCodes.CONFIG_TYPE_ERROR:
            return new ConfigError(code, message, details, suggestion);

        case ErrorCodes.STORAGE_READ:
        case ErrorCodes.STORAGE_WRITE:
        case ErrorCodes.STORAGE_DELETE:
        case ErrorCodes.STORAGE_ERROR:
        case ErrorCodes.STORAGE_INIT:
        case ErrorCodes.STORAGE_INIT_ERROR:
            return new StorageError(code, message, details, suggestion);

        case ErrorCodes.VALIDATION_ERROR:
        case ErrorCodes.INVALID_INPUT:
        case ErrorCodes.INVALID_STATE:
            if (details instanceof z.ZodError) {
                return ValidationError.fromZodError(details);
            }
            return new ValidationError(code, message, undefined, details, suggestion);

        default:
            return new BaseError(code, message, details, suggestion);
    }
}

/**
 * Wraps an error with additional context
 */
export function wrapError(error: unknown, context: string): BaseError {
    if (error instanceof BaseError) {
        return new BaseError(
            error.code,
            `${context}: ${error.message}`,
            error.details,
            error.suggestion
        );
    }
    return new BaseError(
        ErrorCodes.INTERNAL_ERROR,
        `${context}: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error,
        ErrorMessages[ErrorCodes.INTERNAL_ERROR].suggestion
    );
}

/**
 * Type guard for BaseError
 */
export function isBaseError(error: unknown): error is BaseError {
    return error instanceof BaseError;
}

/**
 * Gets a user-friendly error message with guidance
 */
export function getUserErrorMessage(error: unknown): string {
    if (error instanceof BaseError) {
        return error.getUserMessage();
    }
    const defaultError = ErrorMessages[ErrorCodes.INTERNAL_ERROR];
    return `${defaultError.message}\nSuggestion: ${defaultError.suggestion}`;
}

/**
 * Error handler type
 */
export type ErrorHandler = (error: unknown) => void;

/**
 * Creates a default error handler with context
 */
export function createErrorHandler(context: string): ErrorHandler {
    return (error: unknown) => {
        const message = error instanceof BaseError ? error.getUserMessage() : String(error);
        console.error(`[${context}] ${message}`);
    };
}

================
File: src/logging/index.ts
================
/**
 * Logging module
 * Provides centralized logging functionality with structured output
 */

import { createLogger, format, transports, Logger as WinstonLogger, config as winstonConfig } from 'winston';
import path from 'path';
import { BaseError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels, LoggerConfig } from '../types/logging.js';

/**
 * Logger class
 * Provides structured logging with context and error handling
 */
export class Logger {
    private static instance: Logger;
    private logger: WinstonLogger;

    private constructor(config: LoggerConfig) {
        this.logger = this.createLogger(config);
    }

    /**
     * Gets the logger instance
     */
    static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger({
                minLevel: LogLevels.INFO,
                console: true
            });
        }
        return Logger.instance;
    }

    /**
     * Initializes the logger with configuration
     */
    static initialize(config: LoggerConfig): void {
        if (Logger.instance) {
            throw new BaseError(
                ErrorCodes.INVALID_STATE,
                'Logger already initialized'
            );
        }
        Logger.instance = new Logger(config);
    }

    /**
     * Creates a child logger with additional context
     */
    child(context: Record<string, unknown>): Logger {
        const childLogger = new Logger({
            minLevel: LogLevels.INFO,
            console: true
        });
        childLogger.logger = this.logger.child(context);
        return childLogger;
    }

    /**
     * Logs a debug message
     */
    debug(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.DEBUG, message, context);
    }

    /**
     * Logs an info message
     */
    info(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.INFO, message, context);
    }

    /**
     * Logs a warning message
     */
    warn(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.WARN, message, context);
    }

    /**
     * Logs an error message
     */
    error(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Logs a fatal error message (maps to error level for Winston compatibility)
     */
    fatal(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Creates the Winston logger instance
     */
    private createLogger(config: LoggerConfig): WinstonLogger {
        const loggerTransports = [];

        // Console transport
        if (config.console) {
            const formats = [format.simple()];
            if (!config.noColors) {
                formats.unshift(format.colorize());
            }
            loggerTransports.push(
                new transports.Console({
                    format: format.combine(...formats)
                })
            );
        }

        // File transport
        if (config.file && config.logDir) {
            loggerTransports.push(
                new transports.File({
                    filename: path.join(config.logDir, 'error.log'),
                    level: LogLevels.ERROR,
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles
                }),
                new transports.File({
                    filename: path.join(config.logDir, 'combined.log'),
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles
                })
            );
        }

        return createLogger({
            level: config.minLevel,
            format: format.combine(
                format.timestamp(),
                format.json()
            ),
            transports: loggerTransports,
            levels: winstonConfig.npm.levels // Use standard npm levels
        });
    }

    /**
     * Formats an error for logging
     */
    private formatError(error: unknown): Record<string, unknown> | undefined {
        if (!error) return undefined;

        if (error instanceof BaseError) {
            return {
                name: error.name,
                message: error.message,
                code: error.code,
                details: error.details,
                stack: error.stack
            };
        }

        if (error instanceof Error) {
            return {
                name: error.name,
                message: error.message,
                stack: error.stack
            };
        }

        return {
            name: 'UnknownError',
            message: String(error)
        };
    }

    /**
     * Internal log method
     */
    private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {
        this.logger.log({
            level,
            message,
            ...context
        });
    }
}

/**
 * Creates a logger instance with default configuration
 */
export function createDefaultLogger(): Logger {
    try {
        return Logger.getInstance();
    } catch (error) {
        throw new BaseError(
            ErrorCodes.STORAGE_INIT,
            'Failed to create default logger',
            error
        );
    }
}

/**
 * Re-export types
 */
export type { LogLevel, LoggerConfig } from '../types/logging.js';
export { LogLevels } from '../types/logging.js';

================
File: src/server/health-monitor.ts
================
/**
 * Health monitoring for system components
 */
import { Logger } from '../logging/index.js';
import { StorageMetrics } from '../types/storage.js';
import { Metrics } from './metrics-collector.js';

export interface HealthStatus {
    healthy: boolean;
    components: {
        storage: boolean;
        rateLimiter: boolean;
        metrics: boolean;
    };
    details?: Record<string, unknown>;
    timestamp: number;
    [key: string]: unknown;
}

export interface ComponentStatus {
    storage: StorageMetrics;
    rateLimiter: {
        current: number;
        limit: number;
        windowMs: number;
    };
    metrics: Metrics;
}

export class HealthMonitor {
    private logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
    }

    async check(status: ComponentStatus): Promise<HealthStatus> {
        const health: HealthStatus = {
            healthy: true,
            components: {
                storage: true,
                rateLimiter: true,
                metrics: true
            },
            details: {},
            timestamp: Date.now()
        };

        try {
            // Check storage health - only fail if metrics are undefined/null
            if (!status.storage || !status.storage.tasks || !status.storage.storage) {
                health.components.storage = false;
                health.healthy = false;
                health.details!.storage = 'Storage metrics unavailable';
            }

            // Check rate limiter
            if (status.rateLimiter.current >= status.rateLimiter.limit) {
                health.components.rateLimiter = false;
                health.healthy = false;
                health.details!.rateLimiter = 'Rate limit reached';
            }

            // Check metrics
            const errorRate = status.metrics.requests.failed / status.metrics.requests.total;
            if (errorRate > 0.1) { // More than 10% error rate
                health.components.metrics = false;
                health.healthy = false;
                health.details!.metrics = `High error rate: ${(errorRate * 100).toFixed(2)}%`;
            }

            this.logger.debug('Health check completed', { health });
            return health;
        } catch (error) {
            this.logger.error('Health check failed', { error });
            return {
                healthy: false,
                components: {
                    storage: false,
                    rateLimiter: false,
                    metrics: false
                },
                details: {
                    error: error instanceof Error ? error.message : String(error)
                },
                timestamp: Date.now()
            };
        }
    }
}

================
File: src/server/index.ts
================
/**
 * Server module for Atlas MCP Server
 * Handles server initialization, transport setup, and graceful shutdown
 */
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ErrorCode,
    ListToolsRequestSchema,
    McpError,
} from '@modelcontextprotocol/sdk/types.js';
import { Logger } from '../logging/index.js';
import { RateLimiter } from './rate-limiter.js';
import { HealthMonitor, ComponentStatus } from './health-monitor.js';
import { MetricsCollector, MetricEvent } from './metrics-collector.js';
import { RequestTracer, TraceEvent } from './request-tracer.js';

export interface ServerConfig {
    name: string;
    version: string;
    maxRequestsPerMinute?: number;
    requestTimeout?: number;
    shutdownTimeout?: number;
}

export interface ToolHandler {
    listTools: () => Promise<any>;
    handleToolCall: (request: any) => Promise<any>;
    getStorageMetrics: () => Promise<any>;
    clearCaches?: () => Promise<void>;
    cleanup?: () => Promise<void>;
}

/**
 * AtlasServer class encapsulates MCP server functionality
 * Handles server lifecycle, transport, and error management
 */
export class AtlasServer {
    private readonly server: Server;
    private readonly logger: Logger;
    private readonly rateLimiter: RateLimiter;
    private readonly healthMonitor: HealthMonitor;
    private readonly metricsCollector: MetricsCollector;
    private readonly requestTracer: RequestTracer;
    private isShuttingDown: boolean = false;
    private readonly activeRequests: Set<string> = new Set();
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_MEMORY_USAGE = 2 * 1024 * 1024 * 1024; // 2GB threshold
    private readonly MEMORY_CHECK_INTERVAL = 30000; // 30 seconds

    /**
     * Creates a new AtlasServer instance
     */
    constructor(
        private readonly config: ServerConfig,
        private readonly toolHandler: ToolHandler
    ) {
        this.logger = Logger.getInstance().child({ component: 'AtlasServer' });
        
        // Initialize components
        this.rateLimiter = new RateLimiter(config.maxRequestsPerMinute || 600);
        this.healthMonitor = new HealthMonitor();
        this.metricsCollector = new MetricsCollector();
        this.requestTracer = new RequestTracer();

        // Initialize MCP server
        this.server = new Server(
            {
                name: config.name,
                version: config.version,
            },
            {
                capabilities: {
                    tools: {},
                },
            }
        );

        this.setupErrorHandling();
        this.setupToolHandlers();
        this.setupHealthCheck();
        this.setupMemoryMonitoring();
    }

    /**
     * Sets up error handling for the server
     */
    private setupErrorHandling(): void {
        this.server.onerror = (error) => {
            const metricEvent: MetricEvent = {
                type: 'error',
                timestamp: Date.now(),
                error: error instanceof Error ? error.message : String(error)
            };
            this.metricsCollector.recordError(metricEvent);
            
            const errorContext = {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                } : error,
                metrics: this.metricsCollector.getMetrics()
            };

            this.logger.error('[MCP Error]', errorContext);
        };

        process.on('SIGINT', async () => {
            await this.shutdown();
        });

        process.on('SIGTERM', async () => {
            await this.shutdown();
        });

        process.on('unhandledRejection', (reason, promise) => {
            this.logger.error('Unhandled Rejection:', {
                reason,
                promise,
                metrics: this.metricsCollector.getMetrics()
            });
        });

        process.on('uncaughtException', (error) => {
            this.logger.error('Uncaught Exception:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            this.shutdown().finally(() => process.exit(1));
        });
    }

    /**
     * Sets up tool request handlers with middleware
     */
    private setupToolHandlers(): void {
        // Handler for listing available tools
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'list_tools',
                timestamp: Date.now()
            };
            
            try {
                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await this.toolHandler.listTools();
                
                const metricEvent: MetricEvent = {
                    type: 'list_tools',
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });

        // Handler for tool execution requests
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'tool_execution',
                tool: request.params.name,
                timestamp: Date.now()
            };
            
            try {
                if (this.isShuttingDown) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        'Server is shutting down'
                    );
                }

                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await Promise.race([
                    this.toolHandler.handleToolCall(request),
                    this.createTimeout(this.config.requestTimeout || 30000)
                ]);
                
                const metricEvent: MetricEvent = {
                    type: 'tool_execution',
                    tool: request.params.name,
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });
    }

    /**
     * Sets up health check endpoint
     */
    private setupHealthCheck(): void {
        setInterval(async () => {
            try {
                const status: ComponentStatus = {
                    storage: await this.toolHandler.getStorageMetrics(),
                    rateLimiter: this.rateLimiter.getStatus(),
                    metrics: this.metricsCollector.getMetrics()
                };

                const health = await this.healthMonitor.check(status);

                if (!health.healthy) {
                    this.logger.warn('Health check failed:', { health, status });
                }
            } catch (error) {
                this.logger.error('Health check error:', { error });
            }
        }, 30000);
    }

    /**
     * Creates a timeout promise
     */
    private createTimeout(ms: number): Promise<never> {
        return new Promise((_, reject) => {
            setTimeout(() => {
                reject(new McpError(
                    ErrorCode.InternalError,
                    `Request timed out after ${ms}ms`
                ));
            }, ms);
        });
    }

    /**
     * Transforms errors into McpErrors
     */
    private handleToolError(error: unknown): void {
        const metricEvent: MetricEvent = {
            type: 'error',
            timestamp: Date.now(),
            error: error instanceof Error ? error.message : String(error)
        };
        this.metricsCollector.recordError(metricEvent);

        if (error instanceof McpError) {
            return;
        }

        this.logger.error('Unexpected error in tool handler:', {
            error,
            metrics: this.metricsCollector.getMetrics()
        });
        
        throw new McpError(
            ErrorCode.InternalError,
            error instanceof Error ? error.message : 'An unexpected error occurred',
            error instanceof Error ? error.stack : undefined
        );
    }

    /**
     * Starts the server
     */
    async run(): Promise<void> {
        try {
            const transport = new StdioServerTransport();
            await this.server.connect(transport);
            
            this.logger.info(`${this.config.name} v${this.config.version} running on stdio`, {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            this.logger.error('Failed to start server:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }

    /**
     * Gracefully shuts down the server
     */
    /**
     * Sets up memory monitoring to prevent leaks
     */
    private setupMemoryMonitoring(): void {
        this.memoryMonitor = setInterval(() => {
            const memUsage = process.memoryUsage();
            
            // Log memory stats
            this.logger.debug('Memory usage:', {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`
            });

            // Trigger cleanup if memory usage is too high
            if (memUsage.heapUsed > this.MAX_MEMORY_USAGE) {
                this.logger.warn('High memory usage detected, triggering cleanup', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(this.MAX_MEMORY_USAGE / 1024 / 1024)}MB`
                });
                
                // Force garbage collection if available
                if (global.gc) {
                    this.logger.info('Forcing garbage collection');
                    global.gc();
                }

                // Clear caches
                this.toolHandler.clearCaches?.();
            }
        }, this.MEMORY_CHECK_INTERVAL);
    }

    /**
     * Gracefully shuts down the server and cleans up resources
     */
    async shutdown(): Promise<void> {
        if (this.isShuttingDown) {
            return;
        }

        this.isShuttingDown = true;
        this.logger.info('Starting graceful shutdown...');

        try {
            // Wait for active requests to complete
            const timeout = this.config.shutdownTimeout || 30000;
            const shutdownStart = Date.now();

            while (this.activeRequests.size > 0) {
                if (Date.now() - shutdownStart > timeout) {
                    this.logger.warn('Shutdown timeout reached, forcing shutdown', {
                        activeRequests: this.activeRequests.size
                    });
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Clear monitoring intervals
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }
            
            // Clean up resources
            await this.toolHandler.cleanup?.();
            
            // Close server
            await this.server.close();
            
            // Force final garbage collection
            if (global.gc) {
                global.gc();
            }
            this.logger.info('Server closed successfully', {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            this.logger.error('Error during shutdown:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }
}

================
File: src/server/metrics-collector.ts
================
/**
 * Metrics collection for monitoring and analysis
 */
import { Logger } from '../logging/index.js';

export interface MetricEvent {
    type: string;
    tool?: string;
    timestamp: number;
    duration?: number;
    success?: boolean;
    error?: string;
    [key: string]: unknown;
}

export interface Metrics {
    requests: {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
    };
    tools: Record<string, {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
        errors: Record<string, number>;
    }>;
}

export class MetricsCollector {
    private events: MetricEvent[] = [];
    private logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'MetricsCollector' });
    }

    recordSuccess(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: true,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded success metric', { event });
    }

    recordError(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: false,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded error metric', { event });
    }

    getMetrics(): Metrics {
        const now = Date.now();
        const recentEvents = this.events.filter(e => now - e.timestamp < 3600000); // Last hour

        const metrics: Metrics = {
            requests: {
                total: recentEvents.length,
                success: recentEvents.filter(e => e.success).length,
                failed: recentEvents.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(recentEvents)
            },
            tools: {}
        };

        // Calculate per-tool metrics
        const toolEvents = recentEvents.filter(e => e.tool);
        const tools = new Set(toolEvents.map(e => e.tool!));

        for (const tool of tools) {
            const toolMetrics = toolEvents.filter(e => e.tool === tool);
            metrics.tools[tool] = {
                total: toolMetrics.length,
                success: toolMetrics.filter(e => e.success).length,
                failed: toolMetrics.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(toolMetrics),
                errors: this.calculateErrorFrequency(toolMetrics)
            };
        }

        return metrics;
    }

    private calculateAvgDuration(events: MetricEvent[]): number {
        const eventsWithDuration = events.filter(e => e.duration);
        if (eventsWithDuration.length === 0) return 0;
        
        const total = eventsWithDuration.reduce((sum, e) => sum + (e.duration || 0), 0);
        return total / eventsWithDuration.length;
    }

    private calculateErrorFrequency(events: MetricEvent[]): Record<string, number> {
        const errors: Record<string, number> = {};
        
        for (const event of events) {
            if (!event.success && event.error) {
                errors[event.error] = (errors[event.error] || 0) + 1;
            }
        }
        
        return errors;
    }

    clearMetrics(): void {
        this.events = [];
        this.logger.debug('Cleared metrics');
    }
}

================
File: src/server/rate-limiter.ts
================
/**
 * Rate limiter for request throttling
 */
export class RateLimiter {
    private requests: number[] = [];
    private readonly windowMs = 60000; // 1 minute window

    constructor(private readonly maxRequests: number) {}

    /**
     * Checks if request is within rate limit
     * @throws Error if rate limit exceeded
     */
    async checkLimit(): Promise<void> {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        if (this.requests.length >= this.maxRequests) {
            throw new Error('Rate limit exceeded');
        }

        this.requests.push(now);
    }

    /**
     * Gets current rate limiter status
     */
    getStatus(): { current: number; limit: number; windowMs: number } {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        return {
            current: this.requests.length,
            limit: this.maxRequests,
            windowMs: this.windowMs
        };
    }

    /**
     * Resets rate limiter
     */
    reset(): void {
        this.requests = [];
    }
}

================
File: src/server/request-tracer.ts
================
/**
 * Request tracing for monitoring and debugging with memory management
 */
import { Logger } from '../logging/index.js';

export interface TracerConfig {
    maxTraces?: number;           // Maximum number of traces to store
    maxEventsPerTrace?: number;   // Maximum events per trace
    traceRetentionMs?: number;    // How long to keep traces
    cleanupIntervalMs?: number;   // How often to run cleanup
}

const DEFAULT_CONFIG: TracerConfig = {
    maxTraces: 1000,
    maxEventsPerTrace: 100,
    traceRetentionMs: 24 * 60 * 60 * 1000, // 24 hours
    cleanupIntervalMs: 60 * 60 * 1000      // 1 hour
};

export interface TraceEvent {
    type: string;
    tool?: string;
    timestamp: number;
    success?: boolean;
    error?: string;
    duration?: number;
    [key: string]: unknown;
}

export class RequestTracer {
    private traces: Map<string, TraceEvent[]> = new Map();
    private startTimes: Map<string, number> = new Map();
    private logger: Logger;
    private config: TracerConfig;
    private cleanupTimer!: NodeJS.Timeout;

    constructor(config: TracerConfig = {}) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.logger = Logger.getInstance().child({ component: 'RequestTracer' });

        // Start cleanup timer
        this.cleanupTimer = setInterval(
            () => this.cleanup(),
            this.config.cleanupIntervalMs ?? DEFAULT_CONFIG.cleanupIntervalMs!
        ) as unknown as NodeJS.Timeout;

        // Bind cleanup to process events
        process.on('SIGINT', () => this.destroy());
        process.on('SIGTERM', () => this.destroy());
    }

    /**
     * Cleanup old traces and enforce size limits
     */
    private cleanup(): void {
        const now = Date.now();
        const cutoff = now - (this.config.traceRetentionMs ?? DEFAULT_CONFIG.traceRetentionMs!);
        
        // Remove old traces
        for (const [requestId, _] of this.traces.entries()) {
            const startTime = this.startTimes.get(requestId);
            if (startTime && startTime < cutoff) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Cleaned up old trace', { requestId, age: now - startTime });
            }
        }

        // Enforce maximum traces limit
        const maxTraces = this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!;
        if (this.traces.size > maxTraces) {
            const sortedTraces = Array.from(this.startTimes.entries())
                .sort(([, a], [, b]) => b - a);
            
            const tracesToRemove = sortedTraces.slice(maxTraces);
            for (const [requestId] of tracesToRemove) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Removed excess trace', { requestId });
            }
        }
    }

    startTrace(requestId: string, event: TraceEvent): void {
        // Cleanup if we're at the limit
        if (this.traces.size >= (this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!)) {
            this.cleanup();
        }

        this.traces.set(requestId, [event]);
        this.startTimes.set(requestId, event.timestamp);
        this.logger.debug('Started trace', { requestId, event });
    }

    addEvent(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        
        // Enforce maximum events per trace
        const maxEvents = this.config.maxEventsPerTrace ?? DEFAULT_CONFIG.maxEventsPerTrace!;
        if (events.length >= maxEvents) {
            this.logger.warn('Maximum events per trace reached', { 
                requestId, 
                limit: maxEvents
            });
            return;
        }

        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Added trace event', { requestId, event });
    }

    endTrace(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        const startTime = this.startTimes.get(requestId);
        
        if (startTime) {
            event.duration = event.timestamp - startTime;
        }
        
        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Ended trace', { requestId, event });
    }

    getTrace(requestId: string): TraceEvent[] {
        return this.traces.get(requestId) || [];
    }

    getStartTime(requestId: string): number | undefined {
        return this.startTimes.get(requestId);
    }

    clearTrace(requestId: string): void {
        this.traces.delete(requestId);
        this.startTimes.delete(requestId);
        this.logger.debug('Cleared trace', { requestId });
    }

    /**
     * Get memory usage statistics
     */
    getStats(): {
        traceCount: number;
        totalEvents: number;
        memoryUsage: NodeJS.MemoryUsage;
    } {
        let totalEvents = 0;
        for (const events of this.traces.values()) {
            totalEvents += events.length;
        }

        return {
            traceCount: this.traces.size,
            totalEvents,
            memoryUsage: process.memoryUsage()
        };
    }

    /**
     * Cleanup resources and stop timers
     */
    destroy(): void {
        clearInterval(this.cleanupTimer);
        this.traces.clear();
        this.startTimes.clear();
        this.logger.info('Request tracer destroyed');
    }
}

================
File: src/storage/connection-manager.ts
================
/**
 * Database connection manager
 */
import { Logger } from '../logging/index.js';
import { StorageError, StorageErrorType } from '../types/storage.js';

export class ConnectionManager {
    private readonly logger: Logger;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private readonly busyTimeout: number;

    constructor(options: {
        maxRetries?: number;
        retryDelay?: number;
        busyTimeout?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionManager' });
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.busyTimeout = options.busyTimeout || 5000;
    }

    /**
     * Executes a database operation with retries
     */
    async executeWithRetry<T>(
        operation: () => Promise<T>,
        context: string
    ): Promise<T> {
        let lastError: Error | undefined;
        let retryCount = 0;

        while (retryCount < this.maxRetries) {
            try {
                return await operation();
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                retryCount++;

                if (retryCount < this.maxRetries) {
                    this.logger.warn(`Operation failed, retrying (${retryCount}/${this.maxRetries})`, {
                        error: lastError,
                        context
                    });
                    await new Promise(resolve => setTimeout(resolve, this.retryDelay));
                }
            }
        }

        throw new StorageError(
            StorageErrorType.CONNECTION,
            `Operation failed after ${this.maxRetries} retries: ${lastError?.message}`,
            lastError
        );
    }

    /**
     * Handles database busy state
     */
    async handleBusy(
        operation: () => Promise<void>,
        context: string
    ): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                await operation();
                return;
            } catch (error) {
                const elapsed = Date.now() - startTime;
                if (elapsed >= this.busyTimeout) {
                    throw new StorageError(
                        StorageErrorType.CONNECTION,
                        `Operation timed out after ${elapsed}ms: ${error instanceof Error ? error.message : String(error)}`,
                        error
                    );
                }

                this.logger.warn('Database busy, waiting...', {
                    elapsed,
                    timeout: this.busyTimeout,
                    context
                });

                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
}

================
File: src/storage/factory.ts
================
/**
 * Storage factory for creating task storage instances
 */
import { StorageConfig, TaskStorage, StorageError, StorageErrorType } from '../types/storage.js';
import { SqliteStorage } from './sqlite-storage.js';
import { promises as fs } from 'fs';
import path from 'path';

/**
 * Creates a storage instance based on configuration
 */
export async function createStorage(config: StorageConfig): Promise<TaskStorage> {
    try {
        // Ensure base directory exists with proper permissions
        await fs.mkdir(config.baseDir, { recursive: true, mode: 0o750 });

        // Create SQLite storage
        const storage = new SqliteStorage(config);
        await storage.initialize();

        return storage;
    } catch (error) {
        throw new StorageError(
            StorageErrorType.INITIALIZATION,
            'Failed to create storage',
            error
        );
    }
}

/**
 * Creates a storage instance with default configuration
 */
export async function createDefaultStorage(): Promise<TaskStorage> {
    const baseDir = process.env.ATLAS_STORAGE_DIR || path.join(process.cwd(), 'data');

    const config: StorageConfig = {
        baseDir,
        name: process.env.ATLAS_STORAGE_NAME || 'atlas-tasks',
        connection: {
            maxRetries: Number(process.env.ATLAS_MAX_RETRIES) || 3,
            retryDelay: Number(process.env.ATLAS_RETRY_DELAY) || 1000,
            busyTimeout: Number(process.env.ATLAS_BUSY_TIMEOUT) || 5000
        },
        performance: {
            checkpointInterval: Number(process.env.ATLAS_CHECKPOINT_INTERVAL) || 300000, // 5 minutes
            cacheSize: Number(process.env.ATLAS_CACHE_SIZE) || 2000,
            mmapSize: Number(process.env.ATLAS_MMAP_SIZE) || 30000000000, // 30GB
            pageSize: Number(process.env.ATLAS_PAGE_SIZE) || 4096
        }
    };

    return createStorage(config);
}

================
File: src/storage/index.ts
================
/**
 * Storage module exports
 */
export { createStorage, createDefaultStorage } from './factory.js';
export { SqliteStorage } from './sqlite-storage.js';
export { ConnectionManager } from './connection-manager.js';

================
File: src/storage/sqlite-storage.ts
================
/**
 * SQLite storage implementation
 */
import { Database, open } from 'sqlite';
import { Task, TaskStatus } from '../types/task.js';
import { StorageConfig, TaskStorage, StorageMetrics, CacheStats } from '../types/storage.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { ConnectionManager } from './connection-manager.js';
import { globToSqlPattern } from '../utils/pattern-matcher.js';

interface CacheEntry {
    task: Task;
    timestamp: number;
    hits: number;
}

export class SqliteStorage implements TaskStorage {
    private db: Database | null = null;
    private readonly logger: Logger;
    private readonly config: StorageConfig;
    private readonly connectionManager: ConnectionManager;
    private readonly cache: Map<string, CacheEntry> = new Map();
    private readonly MAX_CACHE_SIZE = 1000;
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    private cacheHits = 0;
    private cacheMisses = 0;

    constructor(config: StorageConfig) {
        this.config = config;
        this.logger = Logger.getInstance().child({ component: 'SqliteStorage' });
        this.connectionManager = new ConnectionManager(config.connection);
    }

    async initialize(): Promise<void> {
        const dbPath = `${this.config.baseDir}/${this.config.name}.db`;
        this.logger.debug('Opening SQLite database', { dbPath });

        try {
            // Import required modules
            const fs = await import('fs/promises');
            const path = await import('path');
            
            // Ensure storage directory exists with proper permissions
            await fs.mkdir(path.dirname(dbPath), { recursive: true, mode: 0o750 });
            this.logger.debug('Storage directory created/verified', { path: path.dirname(dbPath) });

            // Import sqlite3 with verbose mode for better error messages
            const sqlite3 = (await import('sqlite3')).default;
            this.logger.debug('SQLite3 module imported');

            // Initialize database with retry support
            await this.connectionManager.executeWithRetry(async () => {
                try {
                    // Initialize database with promise interface
                    this.db = await open({
                        filename: dbPath,
                        driver: sqlite3.Database,
                        mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE
                    });
                    this.logger.debug('Database opened successfully');
                } catch (err) {
                    this.logger.error('Failed to open database', {
                        error: err instanceof Error ? {
                            name: err.name,
                            message: err.message,
                            stack: err.stack,
                            code: (err as any).code,
                            errno: (err as any).errno
                        } : err
                    });
                    throw err;
                }

                // Set busy timeout
                await this.db.run(`PRAGMA busy_timeout = ${this.config.connection?.busyTimeout || 5000}`);

                // Enable extended error codes
                await this.db.run('PRAGMA extended_result_codes = ON');

                // Configure database
                if (this.config.performance) {
                    await this.db.exec(`
                        PRAGMA cache_size=${this.config.performance.cacheSize || 2000};
                        PRAGMA mmap_size=${this.config.performance.mmapSize || 30000000000};
                        PRAGMA page_size=${this.config.performance.pageSize || 4096};
                        PRAGMA journal_mode=WAL;
                        PRAGMA synchronous=NORMAL;
                        PRAGMA temp_store=MEMORY;
                        PRAGMA foreign_keys=ON;
                        PRAGMA busy_timeout=${this.config.connection?.busyTimeout || 5000};
                    `);
                }
            }, 'initialize');

            await this.setupDatabase();
            this.logger.info('SQLite storage initialized', { path: this.config.baseDir });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            const errorDetails = {
                error: error instanceof Error ? {
                    stack: error.stack,
                    ...error,
                    // Ensure custom properties don't get overwritten
                    customProps: Object.getOwnPropertyNames(error).reduce((acc, key) => {
                        if (key !== 'name' && key !== 'message' && key !== 'stack') {
                            acc[key] = (error as any)[key];
                        }
                        return acc;
                    }, {} as Record<string, unknown>)
                } : error,
                config: {
                    baseDir: this.config.baseDir,
                    name: this.config.name,
                    dbPath: `${this.config.baseDir}/${this.config.name}.db`
                }
            };
            
            this.logger.error('Failed to initialize SQLite storage', errorDetails);
            
            // Try to get more details about the SQLite error
            if (error instanceof Error && 'code' in error) {
                this.logger.error('SQLite error details', {
                    code: (error as any).code,
                    errno: (error as any).errno,
                    syscall: (error as any).syscall
                });
            }
            
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize SQLite storage',
                `${errorMessage} - Details: ${JSON.stringify(errorDetails, null, 2)}`
            );
        }
    }

    private async setupDatabase(): Promise<void> {
        return this.withDb(async (db) => {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    path TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    parent_path TEXT,
                    notes TEXT,
                    reasoning TEXT,
                    dependencies TEXT,
                    subtasks TEXT,
                    metadata TEXT,
                    created_at INTEGER NOT NULL,
                    updated_at INTEGER NOT NULL
                );

                CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path);
                CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
                CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type);
            `);
        });
    }

    async saveTask(task: Task): Promise<void> {
        await this.saveTasks([task]);
    }

    private async withDb<T>(operation: (db: Database) => Promise<T>): Promise<T> {
        if (!this.db) {
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Database not initialized'
            );
        }
        return operation(this.db);
    }

    private transactionDepth = 0;

    private async inTransaction<T>(operation: () => Promise<T>): Promise<T> {
        return this.withDb(async (db) => {
            // If we're already in a transaction, just execute the operation
            if (this.transactionDepth > 0) {
                this.transactionDepth++;
                try {
                    return await operation();
                } finally {
                    this.transactionDepth--;
                }
            }

            // Start a new transaction
            this.transactionDepth = 1;
            try {
                await db.run('BEGIN IMMEDIATE');
                this.logger.debug('Started new transaction');
                
                const result = await operation();
                
                // Only commit if we haven't already committed
                if (this.transactionDepth === 1) {
                    await db.run('COMMIT');
                    this.logger.debug('Committed transaction');
                }
                
                return result;
            } catch (error) {
                // Only rollback if we haven't already rolled back
                if (this.transactionDepth === 1) {
                    try {
                        await db.run('ROLLBACK');
                        this.logger.debug('Rolled back transaction');
                    } catch (rollbackError) {
                        this.logger.error('Failed to rollback transaction', {
                            error: rollbackError,
                            originalError: error
                        });
                    }
                }
                throw error;
            } finally {
                this.transactionDepth = 0;
            }
        });
    }

    async saveTasks(tasks: Task[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {

                // First pass: collect all parent paths to load existing parents
                const parentPaths = new Set<string>();
                for (const task of tasks) {
                    if (task.parentPath) {
                        parentPaths.add(task.parentPath);
                    }
                }

                // Load existing parents
                const existingParents = new Map<string, Task>();
                if (parentPaths.size > 0) {
                    const placeholders = Array(parentPaths.size).fill('?').join(',');
                    const rows = await db.all<Record<string, unknown>[]>(
                        `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                        Array.from(parentPaths)
                    );
                    for (const row of rows) {
                        const parent = this.rowToTask(row);
                        existingParents.set(parent.path, parent);
                    }
                }

                // Second pass: update parent-child relationships
                for (const task of tasks) {
                    if (task.parentPath) {
                        let parent = existingParents.get(task.parentPath);
                        if (parent) {
                            // Update parent's subtasks array if needed
                            if (!parent.subtasks.includes(task.path)) {
                                parent.subtasks = [...parent.subtasks, task.path];
                                existingParents.set(parent.path, parent);
                                tasks.push(parent); // Add parent to tasks to be saved
                            }
                        }
                    }
                }

                // Save all tasks with updated relationships
                for (const task of tasks) {
                    await db.run(
                        `INSERT OR REPLACE INTO tasks (
                            path, name, description, type, status,
                            parent_path, notes, reasoning, dependencies,
                            subtasks, metadata, created_at, updated_at
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                        task.path,
                        task.name,
                        task.description,
                        task.type,
                        task.status,
                        task.parentPath,
                        task.notes ? JSON.stringify(task.notes) : null,
                        task.reasoning,
                        JSON.stringify(task.dependencies),
                        JSON.stringify(task.subtasks),
                        JSON.stringify(task.metadata),
                        task.metadata.created,
                        task.metadata.updated
                    );
                }
            });
        });
    }

    /**
     * Implements CacheManager.clearCache
     */
    async clearCache(): Promise<void> {
        this.cache.clear();
        this.cacheHits = 0;
        this.cacheMisses = 0;
        this.logger.debug('Cache cleared');
    }

    /**
     * Implements CacheManager.getCacheStats
     */
    async getCacheStats(): Promise<CacheStats> {
        const totalRequests = this.cacheHits + this.cacheMisses;
        return {
            size: this.cache.size,
            hitRate: totalRequests > 0 ? this.cacheHits / totalRequests : 0,
            memoryUsage: process.memoryUsage().heapUsed
        };
    }

    /**
     * Gets a task from cache or database
     */
    async getTask(path: string): Promise<Task | null> {
        // Check cache first
        const cached = this.cache.get(path);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            cached.hits++;
            this.cacheHits++;
            return cached.task;
        }
        this.cacheMisses++;

        return this.withDb(async (db) => {
            try {
                const row = await db.get<Record<string, unknown>>(
                    'SELECT * FROM tasks WHERE path = ?',
                    path
                );

                if (!row) {
                    return null;
                }

                const task = this.rowToTask(row);
                
                // Add to cache with LRU eviction
                if (this.cache.size >= this.MAX_CACHE_SIZE) {
                    // Find least recently used entry
                    let oldestTime = Date.now();
                    let oldestKey = '';
                    for (const [key, entry] of this.cache.entries()) {
                        if (entry.timestamp < oldestTime) {
                            oldestTime = entry.timestamp;
                            oldestKey = key;
                        }
                    }
                    this.cache.delete(oldestKey);
                }
                
                this.cache.set(path, {
                    task,
                    timestamp: Date.now(),
                    hits: 1
                });

                return task;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get task', { error: errorMessage, path });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get task',
                    errorMessage
                );
            }
        });
    }

    async getTasks(paths: string[]): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                    ...paths
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks', { error: errorMessage, paths });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks',
                    errorMessage
                );
            }
        });
    }

    async getTasksByPattern(pattern: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Convert glob pattern to SQL pattern
                const sqlPattern = globToSqlPattern(pattern);

                this.logger.debug('Converting glob pattern to SQL', {
                    original: pattern,
                    sql: sqlPattern
                });

                // Use both GLOB and LIKE for better pattern matching
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE 
                     path GLOB ? OR 
                     path LIKE ? OR
                     path LIKE ?`,
                    sqlPattern,
                    sqlPattern,
                    // Add recursive matching for **
                    pattern.includes('**') ? `${sqlPattern}/%` : sqlPattern
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by pattern', { error: errorMessage, pattern });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by pattern',
                    errorMessage
                );
            }
        });
    }

    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const rows = await db.all<Record<string, unknown>[]>(
                    'SELECT * FROM tasks WHERE status = ?',
                    status
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by status', { error: errorMessage, status });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by status',
                    errorMessage
                );
            }
        });
    }

    async getSubtasks(parentPath: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Get the parent task first
                const parent = await this.getTask(parentPath);
                if (!parent) {
                    return [];
                }

                // Get all tasks that have this parent path
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE parent_path = ?`,
                    parentPath
                );

                // Convert rows to tasks
                const tasks = rows.map(row => this.rowToTask(row));

                // Ensure consistency - update any tasks that have this parent
                // but aren't in the parent's subtasks array
                const needsUpdate = tasks.some(task => 
                    task.parentPath === parentPath && !parent.subtasks.includes(task.path)
                );

                if (needsUpdate) {
                    parent.subtasks = Array.from(new Set([
                        ...parent.subtasks,
                        ...tasks.filter(t => t.parentPath === parentPath).map(t => t.path)
                    ]));
                    await this.saveTask(parent);
                }

                return tasks;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get subtasks', { error: errorMessage, parentPath });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get subtasks',
                    errorMessage
                );
            }
        });
    }

    async deleteTask(path: string): Promise<void> {
        await this.deleteTasks([path]);
    }

    async deleteTasks(paths: string[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {
                // Get all tasks that need to be deleted using recursive CTE
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `WITH RECURSIVE task_tree AS (
                        -- Base case: tasks with paths in the input list
                        SELECT path, parent_path, json_extract(subtasks, '$') as subtasks
                        FROM tasks 
                        WHERE path IN (${placeholders})
                        
                        UNION ALL
                        
                        -- Recursive case 1: tasks with parent_path matching any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON t.parent_path = tt.path
                        
                        UNION ALL
                        
                        -- Recursive case 2: tasks listed in subtasks array of any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON json_each.value = t.path
                        JOIN json_each(tt.subtasks)
                    )
                    SELECT DISTINCT path FROM task_tree`,
                    ...paths
                );

                const allPaths = rows.map(row => String(row.path));
                this.logger.debug('Found tasks to delete', { 
                    inputPaths: paths,
                    foundPaths: allPaths 
                });

                // Get all tasks before deletion for proper cleanup
                const tasksToDelete = await Promise.all(
                    allPaths.map(path => this.getTask(path))
                );
                const validTasksToDelete = tasksToDelete.filter((t): t is Task => t !== null);

                // Find all parent paths that need updating
                const parentsToUpdate = new Set(
                    validTasksToDelete
                        .filter(t => t.parentPath)
                        .map(t => t.parentPath as string)
                );

                // Update parent tasks' subtasks arrays
                for (const parentPath of parentsToUpdate) {
                    const parent = await this.getTask(parentPath);
                    if (parent && !allPaths.includes(parent.path)) {
                        parent.subtasks = parent.subtasks.filter(p => !allPaths.includes(p));
                        await this.saveTask(parent);
                    }
                }

                // Delete all tasks and their descendants
                if (allPaths.length > 0) {
                    const deletePlaceholders = allPaths.map(() => '?').join(',');
                    await db.run(
                        `DELETE FROM tasks WHERE path IN (${deletePlaceholders})`,
                        ...allPaths
                    );
                }

                this.logger.debug('Tasks deleted with descendants', {
                    inputPaths: paths,
                    deletedPaths: allPaths
                });
            });
        });
    }

    async vacuum(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('VACUUM');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to vacuum database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to vacuum database',
                    errorMessage
                );
            }
        });
    }

    async analyze(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('ANALYZE');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to analyze database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to analyze database',
                    errorMessage
                );
            }
        });
    }

    async checkpoint(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('PRAGMA wal_checkpoint(TRUNCATE)');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to checkpoint database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to checkpoint database',
                    errorMessage
                );
            }
        });
    }

    async getMetrics(): Promise<StorageMetrics & {
        cache?: CacheStats;
        memory?: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
    }> {
        return this.withDb(async (db) => {
            try {
                const [taskStats, storageStats] = await Promise.all([
                    db.get<Record<string, unknown>>(`
                        SELECT 
                            COUNT(*) as total,
                            SUM(CASE WHEN notes IS NOT NULL THEN 1 ELSE 0 END) as noteCount,
                            SUM(CASE WHEN dependencies IS NOT NULL THEN json_array_length(dependencies) ELSE 0 END) as dependencyCount,
                            json_group_object(status, COUNT(*)) as byStatus
                        FROM tasks
                    `),
                    db.get<Record<string, unknown>>(`
                        SELECT 
                            page_count * page_size as totalSize,
                            page_size,
                            page_count,
                            (SELECT page_count * page_size FROM pragma_wal_checkpoint) as wal_size
                        FROM pragma_page_count, pragma_page_size
                    `)
                ]);

                const memUsage = process.memoryUsage();
                const cacheStats = await this.getCacheStats();

                return {
                    tasks: {
                        total: Number(taskStats?.total || 0),
                        byStatus: this.parseJSON(String(taskStats?.byStatus || '{}'), {}),
                        noteCount: Number(taskStats?.noteCount || 0),
                        dependencyCount: Number(taskStats?.dependencyCount || 0)
                    },
                    storage: {
                        totalSize: Number(storageStats?.totalSize || 0),
                        pageSize: Number(storageStats?.page_size || 0),
                        pageCount: Number(storageStats?.page_count || 0),
                        walSize: Number(storageStats?.wal_size || 0),
                        cache: {
                            hitRate: cacheStats.hitRate,
                            memoryUsage: cacheStats.memoryUsage,
                            entryCount: this.cache.size
                        }
                    },
                    cache: cacheStats,
                    memory: {
                        heapUsed: memUsage.heapUsed,
                        heapTotal: memUsage.heapTotal,
                        rss: memUsage.rss
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get storage metrics', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to get storage metrics',
                    errorMessage
                );
            }
        });
    }

    private parseJSON<T>(value: string | null | undefined, defaultValue: T): T {
        if (!value) return defaultValue;
        try {
            return JSON.parse(value) as T;
        } catch {
            return defaultValue;
        }
    }

    private rowToTask(row: Record<string, unknown>): Task {
        return {
            path: String(row.path || ''),
            name: String(row.name || ''),
            description: row.description ? String(row.description) : undefined,
            type: String(row.type || '') as Task['type'],
            status: String(row.status || '') as Task['status'],
            parentPath: row.parent_path ? String(row.parent_path) : undefined,
            notes: this.parseJSON<string[]>(String(row.notes || '[]'), []),
            reasoning: row.reasoning ? String(row.reasoning) : undefined,
            dependencies: this.parseJSON<string[]>(String(row.dependencies || '[]'), []),
            subtasks: this.parseJSON<string[]>(String(row.subtasks || '[]'), []),
            metadata: this.parseJSON(String(row.metadata || '{}'), {
                created: Date.now(),
                updated: Date.now(),
                projectPath: String(row.path || '').split('/')[0],
                version: 1
            })
        };
    }

    /**
     * Clears all tasks from the database
     */
    async clearAllTasks(): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {
                await db.run('DELETE FROM tasks');
                this.logger.info('All tasks cleared from database');
            });
        });
    }

    /**
     * Repairs parent-child relationships
     */
    async repairRelationships(dryRun: boolean = false): Promise<{ fixed: number, issues: string[] }> {
        return this.inTransaction(async () => {
            return this.withDb(async (db) => {
                const issues: string[] = [];
                let fixCount = 0;

                try {
                    // Find tasks with invalid parent paths
                    const orphanedTasks = await db.all<Record<string, unknown>[]>(
                        `SELECT t1.path, t1.parent_path 
                         FROM tasks t1 
                         LEFT JOIN tasks t2 ON t1.parent_path = t2.path 
                         WHERE t1.parent_path IS NOT NULL 
                         AND t2.path IS NULL`
                    );

                    for (const task of orphanedTasks) {
                        issues.push(`Task ${task.path} has invalid parent_path: ${task.parent_path}`);
                        if (!dryRun) {
                            await db.run(
                                'UPDATE tasks SET parent_path = NULL WHERE path = ?',
                                task.path
                            );
                            fixCount++;
                        }
                    }

                    // Find inconsistencies between parent_path and subtasks
                    const rows = await db.all<Record<string, unknown>[]>(
                        'SELECT * FROM tasks WHERE parent_path IS NOT NULL OR subtasks IS NOT NULL'
                    );

                    for (const row of rows) {
                        const task = this.rowToTask(row);
                        const subtaskRefs = new Set(task.subtasks);
                        
                        // Check if all subtasks exist and reference this task as parent
                        if (subtaskRefs.size > 0) {
                            const subtasks = await db.all<Record<string, unknown>[]>(
                                `SELECT * FROM tasks WHERE path IN (${Array(subtaskRefs.size).fill('?').join(',')})`,
                                ...Array.from(subtaskRefs)
                            );

                            for (const subtask of subtasks.map(r => this.rowToTask(r))) {
                                if (subtask.parentPath !== task.path) {
                                    issues.push(`Task ${task.path} lists ${subtask.path} as subtask but parent_path mismatch`);
                                    if (!dryRun) {
                                        subtask.parentPath = task.path;
                                        await this.saveTask(subtask);
                                        fixCount++;
                                    }
                                }
                            }
                        }
                    }

                    return { fixed: fixCount, issues };
                } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                    this.logger.error('Failed to repair relationships', { error: errorMessage });
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Failed to repair relationships',
                        errorMessage
                    );
                }
            });
        });
    }

    /**
     * Begins a new transaction
     */
    async beginTransaction(): Promise<void> {
        if (this.transactionDepth > 0) {
            this.transactionDepth++;
            this.logger.debug('Nested transaction started', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('BEGIN IMMEDIATE');
                this.transactionDepth = 1;
                this.logger.debug('Transaction started');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to begin transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to begin transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Commits the current transaction
     */
    async commitTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction committed', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('COMMIT');
                this.transactionDepth = 0;
                this.logger.debug('Transaction committed');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to commit transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to commit transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Rolls back the current transaction
     */
    async rollbackTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction rolled back', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('ROLLBACK');
                this.transactionDepth = 0;
                this.logger.debug('Transaction rolled back');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to rollback transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to rollback transaction',
                    errorMessage
                );
            }
        });
    }

    async close(): Promise<void> {
        await this.clearCache();
        if (this.db) {
            await this.db.close();
            this.db = null;
        }
    }
}

================
File: src/task/core/batch/base-batch-processor.ts
================
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import {
    BatchConfig,
    BatchResult,
    BatchProgressCallback,
    BatchError
} from '../../../types/batch.js';

const DEFAULT_CONFIG: BatchConfig = {
    batchSize: 50,
    concurrentBatches: 3,
    retryCount: 3,
    retryDelay: 1000
};

/**
 * Base class for batch processors providing core functionality.
 * Uses types defined in src/types/batch.ts for consistent type definitions.
 */
export abstract class BaseBatchProcessor<T = unknown> {
    protected readonly logger: Logger;
    protected config: BatchConfig;

    constructor(config: Partial<BatchConfig> = {}) {
        this.logger = Logger.getInstance().child({ component: this.constructor.name });
        this.config = { ...DEFAULT_CONFIG, ...config };
    }

    /**
     * Process a single batch of items
     * @see BatchProcessor in src/types/batch.ts
     */
    abstract processBatch(
        batch: T[],
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;

    /**
     * Process multiple batches of items
     * @see BatchProcessor in src/types/batch.ts
     */
    abstract processInBatches(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;

    /**
     * Pre-validate batch items
     */
    protected async preValidateBatch(_batch: T[]): Promise<void> {
        // Base validation - can be overridden by subclasses
    }

    /**
     * Create batches from an array of items
     */
    protected createBatches(items: T[], batchSize: number): T[][] {
        const batches: T[][] = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }

    /**
     * Process an item with retry logic
     */
    protected async processWithRetry(
        item: T,
        operation: (item: T) => Promise<void>
    ): Promise<void> {
        let lastError: Error | undefined;
        let lastAttemptContext: Record<string, unknown> = {};

        for (let attempt = 1; attempt <= this.config.retryCount; attempt++) {
            try {
                await operation(item);
                if (attempt > 1) {
                    this.logger.info('Operation succeeded after retry', {
                        successfulAttempt: attempt,
                        totalAttempts: this.config.retryCount
                    });
                }
                return;
            } catch (error) {
                if (this.isCriticalError(error)) {
                    throw error;
                }

                lastError = error instanceof Error ? error : new Error(String(error));
                lastAttemptContext = {
                    attempt,
                    maxAttempts: this.config.retryCount,
                    error: lastError,
                    errorType: this.categorizeError(error),
                    item: typeof item === 'object' ? JSON.stringify(item) : item,
                    timestamp: new Date().toISOString()
                };

                this.logger.warn('Operation failed, retrying', lastAttemptContext);

                if (attempt < this.config.retryCount) {
                    await this.delay(this.config.retryDelay * Math.pow(2, attempt - 1));
                }
            }
        }

        throw createError(
            ErrorCodes.OPERATION_FAILED,
            {
                message: 'Operation failed after all retry attempts',
                retryCount: this.config.retryCount,
                error: lastError,
                context: lastAttemptContext
            },
            `Operation failed after ${this.config.retryCount} attempts`,
            'Check logs for detailed error history'
        );
    }

    /**
     * Create error context for batch errors
     */
    protected createErrorContext(
        error: unknown,
        context: {
            item: T;
            batchSize: number;
            currentIndex: number;
            processedCount: number;
        }
    ): BatchError {
        return {
            item: context.item,
            error: error instanceof Error ? error : new Error(String(error)),
            context: {
                ...context,
                errorType: this.categorizeError(error),
                timestamp: new Date().toISOString(),
                failureReason: error instanceof Error ? error.message : String(error)
            }
        };
    }

    /**
     * Categorize an error for better error handling
     */
    protected categorizeError(error: unknown): string {
        if (error instanceof Error) {
            if (error.message.includes('TASK_CYCLE')) return 'DEPENDENCY_CYCLE';
            if (error.message.includes('TASK_DEPENDENCY')) return 'DEPENDENCY_VALIDATION';
            if (error.message.includes('TASK_NOT_FOUND')) return 'MISSING_DEPENDENCY';
            if (error.message.includes('VALIDATION')) return 'VALIDATION';
        }
        return 'UNKNOWN';
    }

    /**
     * Check if an error is critical and should stop processing
     */
    protected isCriticalError(error: unknown): boolean {
        const errorType = this.categorizeError(error);
        return ['DEPENDENCY_CYCLE', 'DEPENDENCY_VALIDATION'].includes(errorType);
    }

    /**
     * Check if batch processing should stop based on errors
     */
    protected shouldStopProcessing(result: BatchResult): boolean {
        const criticalErrorCount = result.errors.filter(
            e => this.isCriticalError(e.error)
        ).length;
        
        return criticalErrorCount > 0 || 
               (result.failedCount / (result.processedCount + result.failedCount)) > 0.5;
    }

    /**
     * Delay execution
     */
    protected delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Update batch processor configuration
     */
    updateConfig(config: Partial<BatchConfig>): void {
        this.config = { ...this.config, ...config };
        this.logger.debug('Batch processor configuration updated', { config: this.config });
    }

    /**
     * Get batch processor statistics
     */
    getStats(): {
        config: BatchConfig;
        performance: {
            averageBatchSize: number;
            concurrencyLevel: number;
            retryRate: number;
        };
    } {
        return {
            config: { ...this.config },
            performance: {
                averageBatchSize: this.config.batchSize,
                concurrencyLevel: this.config.concurrentBatches,
                retryRate: 0 // Would need to track this during processing
            }
        };
    }
}

================
File: src/task/core/batch/dependency-aware-batch-processor.ts
================
import { 
    BatchProgressCallback,
    BatchResult,
    DependentItem
} from '../../../types/batch.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { GenericBatchProcessor } from './generic-batch-processor.js';

/**
 * Batch processor for handling items with dependencies.
 * Extends GenericBatchProcessor to add dependency-aware processing.
 * Uses types defined in src/types/batch.ts for consistent type definitions.
 */
export class DependencyAwareBatchProcessor<T extends DependentItem> extends GenericBatchProcessor<T> {
    /**
     * Process multiple batches of items with dependency ordering
     * @see BatchProcessor in src/types/batch.ts
     */
    override async processInBatches(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult> {
        try {
            // Sort items based on dependencies
            const sortedItems = this.sortByDependencies(items);

            const batches = this.createBatches(sortedItems, batchSize);
            const totalBatches = batches.length;
            let currentBatch = 0;

            const result: BatchResult = {
                success: true,
                processedCount: 0,
                failedCount: 0,
                errors: []
            };

            // Process batches sequentially to maintain dependency order
            for (const batch of batches) {
                if (progressCallback?.onBatchStart) {
                    progressCallback.onBatchStart(currentBatch + 1, totalBatches);
                }

                const batchResult = await this.processBatch(
                    batch,
                    operation,
                    progressCallback
                );

                if (progressCallback?.onBatchComplete) {
                    progressCallback.onBatchComplete(currentBatch + 1, batchResult);
                }

                result.processedCount += batchResult.processedCount;
                result.failedCount += batchResult.failedCount;
                result.errors.push(...batchResult.errors);

                if (!batchResult.success) {
                    result.success = false;
                    // Stop processing on failure when dealing with dependencies
                    break;
                }

                currentBatch++;
            }

            this.logger.info('Dependency-aware batch processing completed', {
                totalItems: items.length,
                processedCount: result.processedCount,
                failedCount: result.failedCount,
                batchCount: totalBatches
            });

            return result;
        } catch (error) {
            this.logger.error('Dependency-aware batch processing failed', { error });
            throw error;
        }
    }

    /**
     * Sort items based on their dependencies using topological sort
     */
    private sortByDependencies(items: T[]): T[] {
        const graph = new Map<string, Set<string>>();
        const inDegree = new Map<string, number>();
        const itemMap = new Map<string, T>();

        // Build dependency graph
        for (const item of items) {
            const itemId = this.getItemId(item);
            if (!itemId) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    {
                        message: 'Item missing required identifier',
                        context: { item }
                    },
                    'Items must have either a path or id property'
                );
            }

            itemMap.set(itemId, item);
            if (!graph.has(itemId)) {
                graph.set(itemId, new Set());
            }

            if (item.dependencies) {
                for (const dep of item.dependencies) {
                    if (!graph.has(dep)) {
                        graph.set(dep, new Set());
                    }
                    graph.get(dep)!.add(itemId);
                    inDegree.set(itemId, (inDegree.get(itemId) || 0) + 1);
                }
            }
        }

        // Perform topological sort
        const sorted: T[] = [];
        const queue: string[] = [];

        // Find all nodes with no dependencies
        for (const [node] of graph) {
            if (!inDegree.has(node)) {
                queue.push(node);
            }
        }

        while (queue.length > 0) {
            const node = queue.shift()!;
            const item = itemMap.get(node);
            if (item) {
                sorted.push(item);
            }

            for (const dependent of graph.get(node) || []) {
                inDegree.set(dependent, inDegree.get(dependent)! - 1);
                if (inDegree.get(dependent) === 0) {
                    queue.push(dependent);
                }
            }
        }

        // Check for cycles
        if (sorted.length !== items.length) {
            throw createError(
                ErrorCodes.TASK_CYCLE,
                {
                    message: 'Circular dependencies detected',
                    context: {
                        graph: Object.fromEntries(graph),
                        inDegree: Object.fromEntries(inDegree),
                        processedCount: sorted.length,
                        totalItems: items.length
                    }
                },
                'Cannot process items with circular dependencies',
                'Review dependencies to ensure there are no cycles'
            );
        }

        return sorted;
    }

    /**
     * Get unique identifier for an item
     */
    private getItemId(item: T): string | undefined {
        return item.path || item.id;
    }

    /**
     * Pre-validate batch items
     * @see BaseBatchProcessor in src/task/core/batch/base-batch-processor.ts
     */
    protected async preValidateBatch(batch: T[]): Promise<void> {
        await super.preValidateBatch(batch);

        const missingIds = batch.filter(item => !this.getItemId(item));
        if (missingIds.length > 0) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                {
                    message: 'Items missing required identifiers',
                    context: { items: missingIds }
                },
                'All items must have either a path or id property'
            );
        }
    }
}

================
File: src/task/core/batch/generic-batch-processor.ts
================
import { BatchProgressCallback, BatchResult } from '../../../types/batch.js';
import { BaseBatchProcessor } from './base-batch-processor.js';

/**
 * Generic batch processor for handling non-dependent items with concurrent processing.
 * Uses types defined in src/types/batch.ts for consistent type definitions.
 */
export class GenericBatchProcessor<T> extends BaseBatchProcessor<T> {
    /**
     * Process a single batch of items
     * @see BatchProcessor in src/types/batch.ts
     */
    async processBatch(
        batch: T[],
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult> {
        const result: BatchResult = {
            success: true,
            processedCount: 0,
            failedCount: 0,
            errors: []
        };

        for (const [index, item] of batch.entries()) {
            try {
                await this.processWithRetry(item, operation);
                result.processedCount++;

                if (progressCallback?.onOperationComplete) {
                    progressCallback.onOperationComplete(index + 1, batch.length);
                }
            } catch (error) {
                const errorContext = this.createErrorContext(error, {
                    item,
                    batchSize: batch.length,
                    currentIndex: index,
                    processedCount: result.processedCount
                });

                result.failedCount++;
                result.errors.push(errorContext);
                result.success = false;

                if (progressCallback?.onOperationComplete) {
                    progressCallback.onOperationComplete(index + 1, batch.length);
                }

                // Check if we should stop processing
                if (this.shouldStopProcessing(result)) {
                    this.logger.warn('Stopping batch processing due to errors', {
                        processedCount: result.processedCount,
                        failedCount: result.failedCount,
                        errorTypes: result.errors.map(e => this.categorizeError(e.error))
                    });
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Process multiple batches of items with concurrent processing
     * @see BatchProcessor in src/types/batch.ts
     */
    async processInBatches(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult> {
        const batches = this.createBatches(items, batchSize);
        const totalBatches = batches.length;
        let currentBatch = 0;

        const result: BatchResult = {
            success: true,
            processedCount: 0,
            failedCount: 0,
            errors: []
        };

        try {
            while (currentBatch < totalBatches) {
                const batchPromises: Promise<BatchResult>[] = [];

                // Create concurrent batch operations up to the limit
                for (
                    let i = 0;
                    i < this.config.concurrentBatches && currentBatch < totalBatches;
                    i++, currentBatch++
                ) {
                    if (progressCallback?.onBatchStart) {
                        progressCallback.onBatchStart(currentBatch + 1, totalBatches);
                    }

                    const batchPromise = this.processBatch(
                        batches[currentBatch],
                        operation,
                        progressCallback
                    ).then(batchResult => {
                        if (progressCallback?.onBatchComplete) {
                            progressCallback.onBatchComplete(currentBatch + 1, batchResult);
                        }
                        return batchResult;
                    });

                    batchPromises.push(batchPromise);
                }

                // Wait for current batch of promises to complete
                const batchResults = await Promise.all(batchPromises);

                // Aggregate results
                for (const batchResult of batchResults) {
                    result.processedCount += batchResult.processedCount;
                    result.failedCount += batchResult.failedCount;
                    result.errors.push(...batchResult.errors);
                    if (!batchResult.success) {
                        result.success = false;
                    }
                }

                // Check if we should stop processing
                if (this.shouldStopProcessing(result)) {
                    this.logger.warn('Stopping batch processing due to errors', {
                        processedCount: result.processedCount,
                        failedCount: result.failedCount,
                        remainingBatches: totalBatches - currentBatch
                    });
                    break;
                }
            }

            this.logger.info('Batch processing completed', {
                totalItems: items.length,
                processedCount: result.processedCount,
                failedCount: result.failedCount,
                batchCount: totalBatches
            });

            return result;
        } catch (error) {
            this.logger.error('Batch processing failed', { error });
            throw error;
        }
    }
}

================
File: src/task/core/batch/index.ts
================
export * from './base-batch-processor.js';
export * from './dependency-aware-batch-processor.js';
export * from './generic-batch-processor.js';
export * from './task-status-batch-processor.js';

================
File: src/task/core/batch/task-status-batch-processor.ts
================
import { Task, TaskStatus } from '../../../types/task.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { BatchProgressCallback, BatchResult } from '../../../types/batch.js';
import { DependencyAwareBatchProcessor } from './dependency-aware-batch-processor.js';

/**
 * Specialized batch processor for handling task status updates.
 * Extends DependencyAwareBatchProcessor to handle task-specific dependencies.
 * Uses types defined in src/types/batch.ts and src/types/task.ts.
 */
export class TaskStatusBatchProcessor extends DependencyAwareBatchProcessor<Task> {
    /**
     * Process a batch of task status updates
     * @see BatchProcessor in src/types/batch.ts
     */
    override async processBatch(
        tasks: Task[],
        operation: (item: Task) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult> {
        if (!tasks.length) {
            return {
                success: true,
                processedCount: 0,
                failedCount: 0,
                errors: []
            };
        }

        try {
            // Calculate status updates
            const updates = this.calculateStatusUpdates(tasks);

            // Apply updates
            let processedCount = 0;
            const errors: BatchResult['errors'] = [];

            for (const update of updates) {
                try {
                    await operation(update);
                    processedCount++;

                    if (progressCallback?.onOperationComplete) {
                        progressCallback.onOperationComplete(processedCount, updates.length);
                    }
                } catch (error) {
                    errors.push({
                        item: update,
                        error: error instanceof Error ? error : new Error(String(error)),
                        context: {
                            batchSize: updates.length,
                            currentIndex: processedCount,
                            processedCount,
                            failureReason: 'Status update failed'
                        }
                    });
                }
            }

            this.logger.debug('Batch status updates processed', {
                taskCount: tasks.length,
                updateCount: updates.length,
                processedCount,
                errorCount: errors.length
            });

            return {
                success: errors.length === 0,
                processedCount,
                failedCount: errors.length,
                errors
            };
        } catch (error) {
            this.logger.error('Failed to process task status batch', { error });
            return {
                success: false,
                processedCount: 0,
                failedCount: tasks.length,
                errors: [{
                    item: tasks,
                    error: error instanceof Error ? error : new Error(String(error)),
                    context: {
                        batchSize: tasks.length,
                        currentIndex: 0,
                        processedCount: 0,
                        failureReason: 'Batch processing failed'
                    }
                }]
            };
        }
    }

    /**
     * Calculates required status updates based on task dependencies
     */
    private calculateStatusUpdates(tasks: Task[]): Task[] {
        const updates: Task[] = [];
        const taskMap = new Map(tasks.map(t => [t.path, t]));

        for (const task of tasks) {
            const newStatus = this.calculateTaskStatus(task, taskMap);
            if (newStatus !== task.status) {
                updates.push({
                    ...task,
                    status: newStatus
                });
            }
        }

        return updates;
    }

    /**
     * Calculates status for a single task based on its dependencies
     */
    private calculateTaskStatus(
        task: Task,
        taskMap: Map<string, Task>
    ): TaskStatus {
        // Check dependencies
        if (!task.dependencies?.length) {
            return task.status;
        }

        // Check if any dependencies are blocked or failed
        for (const depPath of task.dependencies) {
            const depTask = taskMap.get(depPath);
            if (!depTask) continue;

            if (depTask.status === TaskStatus.BLOCKED || 
                depTask.status === TaskStatus.FAILED) {
                return TaskStatus.BLOCKED;
            }
        }

        // Check if all dependencies are completed
        const allCompleted = task.dependencies.every(depPath => {
            const depTask = taskMap.get(depPath);
            return depTask?.status === TaskStatus.COMPLETED;
        });

        if (!allCompleted) {
            return TaskStatus.BLOCKED;
        }

        return task.status;
    }

    /**
     * Pre-validate batch items
     * @see DependencyAwareBatchProcessor in src/task/core/batch/dependency-aware-batch-processor.ts
     */
    protected override async preValidateBatch(batch: Task[]): Promise<void> {
        await super.preValidateBatch(batch);

        // Validate task statuses
        const invalidTasks = batch.filter(task => 
            !Object.values(TaskStatus).includes(task.status)
        );

        if (invalidTasks.length > 0) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                {
                    message: 'Tasks have invalid status values',
                    context: { tasks: invalidTasks }
                },
                'All tasks must have valid status values'
            );
        }
    }
}

================
File: src/task/core/cache/cache-manager.ts
================
import { Task } from '../../../types/task.js';
import { Logger } from '../../../logging/index.js';
import { CacheEntry, CacheConfig, CacheManager, CacheStats } from './cache-types.js';

const DEFAULT_CONFIG: CacheConfig = {
    maxSize: 1000, // Maximum number of entries
    baseTTL: 60000, // 1 minute base TTL
    maxTTL: 300000, // 5 minutes maximum TTL
    cleanupInterval: 60000, // Run cleanup every minute
    persistPath: null // Optional path for cache persistence
};

interface LRUNode {
    key: string;
    entry: CacheEntry;
    prev: LRUNode | null;
    next: LRUNode | null;
}

/**
 * Enhanced cache manager with LRU eviction, persistence, and adaptive TTL
 */
export class EnhancedCacheManager implements CacheManager {
    private cache: Map<string, LRUNode>;
    private head: LRUNode | null = null;
    private tail: LRUNode | null = null;
    private logger: Logger;
    private config: CacheConfig;
    private cleanupTimer: ReturnType<typeof setInterval>;
    private hits: number = 0;
    private misses: number = 0;

    constructor(config: Partial<CacheConfig> = {}) {
        this.cache = new Map();
        this.logger = Logger.getInstance().child({ component: 'EnhancedCacheManager' });
        this.config = { ...DEFAULT_CONFIG, ...config };

        // Start periodic cleanup and persistence
        this.cleanupTimer = setInterval(() => {
            this.cleanup();
            if (this.config.persistPath) {
                this.persistCache();
            }
        }, this.config.cleanupInterval);

        // Load persisted cache if available
        if (this.config.persistPath) {
            this.loadPersistedCache();
        }
    }

    /**
     * Gets a task from cache with LRU update and adaptive TTL
     */
    async get(path: string): Promise<Task | null> {
        const node = this.cache.get(path);
        if (!node) {
            this.misses++;
            this.logger.debug('Cache miss', { path });
            return null;
        }

        const ttl = this.calculateAdaptiveTTL(node.entry);
        if (Date.now() - node.entry.timestamp > ttl) {
            await this.delete(path);
            this.misses++;
            return null;
        }

        // Move to front of LRU list
        this.moveToFront(node);

        // Update access statistics
        node.entry.accessCount++;
        node.entry.lastAccessed = Date.now();
        this.hits++;

        this.logger.debug('Cache hit', {
            path,
            accessCount: node.entry.accessCount,
            ttl
        });

        return node.entry.task;
    }

    /**
     * Sets a task in cache with LRU eviction
     */
    async set(path: string, task: Task): Promise<void> {
        const existingNode = this.cache.get(path);
        const timestamp = Date.now();

        if (existingNode) {
            // Update existing entry
            existingNode.entry = {
                task,
                timestamp,
                lastAccessed: timestamp,
                accessCount: existingNode.entry.accessCount + 1
            };
            this.moveToFront(existingNode);
        } else {
            // Create new entry
            const newNode: LRUNode = {
                key: path,
                entry: {
                    task,
                    timestamp,
                    lastAccessed: timestamp,
                    accessCount: 1
                },
                prev: null,
                next: null
            };

            // Evict if at capacity
            if (this.cache.size >= this.config.maxSize) {
                await this.evictLRU();
            }

            this.cache.set(path, newNode);
            this.addToFront(newNode);
        }

        this.logger.debug('Cache set', {
            path,
            cacheSize: this.cache.size,
            maxSize: this.config.maxSize
        });

        // Persist cache if configured
        if (this.config.persistPath) {
            await this.persistCache();
        }
    }

    /**
     * Removes a task from cache
     */
    async delete(path: string): Promise<void> {
        const node = this.cache.get(path);
        if (node) {
            this.removeFromList(node);
            this.cache.delete(path);
            this.logger.debug('Cache delete', { path });

            // Persist cache if configured
            if (this.config.persistPath) {
                await this.persistCache();
            }
        }
    }

    /**
     * Clears all entries from cache
     */
    async clear(): Promise<void> {
        this.cache.clear();
        this.head = null;
        this.tail = null;
        this.hits = 0;
        this.misses = 0;
        this.logger.debug('Cache cleared');

        // Persist empty cache if configured
        if (this.config.persistPath) {
            await this.persistCache();
        }
    }

    /**
     * Cleans up expired cache entries
     */
    async cleanup(): Promise<void> {
        const now = Date.now();
        let expiredCount = 0;
        let node = this.tail;

        while (node) {
            const ttl = this.calculateAdaptiveTTL(node.entry);
            if (now - node.entry.timestamp > ttl) {
                const prevNode = node.prev;
                await this.delete(node.key);
                expiredCount++;
                node = prevNode;
            } else {
                node = node.prev;
            }
        }

        if (expiredCount > 0) {
            this.logger.debug('Cache cleanup', {
                expiredCount,
                remainingCount: this.cache.size
            });
        }
    }

    /**
     * Stops the cleanup timer and persists cache if configured
     */
    async destroy(): Promise<void> {
        clearInterval(this.cleanupTimer);
        if (this.config.persistPath) {
            await this.persistCache();
        }
        this.logger.debug('Cache manager destroyed');
    }

    /**
     * Gets detailed cache statistics
     */
    async getStats(): Promise<CacheStats> {
        const entries = Array.from(this.cache.values());
        const totalAccessCount = entries.reduce((sum, node) => sum + node.entry.accessCount, 0);
        const totalHits = this.hits + this.misses;
        
        return {
            size: this.cache.size,
            hitRate: totalHits > 0 ? this.hits / totalHits : 0,
            averageAccessCount: this.cache.size > 0 ? totalAccessCount / this.cache.size : 0,
            memoryUsage: process.memoryUsage().heapUsed
        };
    }

    /**
     * Calculates adaptive TTL based on access patterns
     */
    private calculateAdaptiveTTL(entry: CacheEntry): number {
        const baseMultiplier = Math.log2(entry.accessCount + 1);
        const recencyBonus = Math.max(0, 1 - (Date.now() - entry.lastAccessed) / this.config.maxTTL);
        return Math.min(
            this.config.baseTTL * (baseMultiplier + recencyBonus),
            this.config.maxTTL
        );
    }

    /**
     * Moves a node to the front of the LRU list
     */
    private moveToFront(node: LRUNode): void {
        if (node === this.head) return;
        this.removeFromList(node);
        this.addToFront(node);
    }

    /**
     * Adds a node to the front of the LRU list
     */
    private addToFront(node: LRUNode): void {
        if (!this.head) {
            this.head = node;
            this.tail = node;
        } else {
            node.next = this.head;
            this.head.prev = node;
            this.head = node;
        }
    }

    /**
     * Removes a node from the LRU list
     */
    private removeFromList(node: LRUNode): void {
        if (node.prev) node.prev.next = node.next;
        if (node.next) node.next.prev = node.prev;
        if (node === this.head) this.head = node.next;
        if (node === this.tail) this.tail = node.prev;
        node.prev = null;
        node.next = null;
    }

    /**
     * Evicts the least recently used entry
     */
    private async evictLRU(): Promise<void> {
        if (this.tail) {
            this.logger.debug('Cache eviction', {
                path: this.tail.key,
                accessCount: this.tail.entry.accessCount,
                lastAccessed: new Date(this.tail.entry.lastAccessed).toISOString()
            });
            await this.delete(this.tail.key);
        }
    }

    /**
     * Persists cache to disk if configured
     */
    private async persistCache(): Promise<void> {
        if (!this.config.persistPath) return;

        const persistData = {
            entries: Array.from(this.cache.entries()).map(([key, node]) => ({
                key,
                entry: node.entry
            })),
            stats: {
                hits: this.hits,
                misses: this.misses
            }
        };

        try {
            await new Promise<void>((resolve, reject) => {
                require('fs').writeFile(
                    this.config.persistPath!,
                    JSON.stringify(persistData),
                    'utf8',
                    (err: Error | null) => {
                        if (err) reject(err);
                        else resolve();
                    }
                );
            });

            this.logger.debug('Cache persisted', {
                path: this.config.persistPath,
                entries: persistData.entries.length
            });
        } catch (error) {
            this.logger.error('Failed to persist cache', { error });
        }
    }

    /**
     * Loads persisted cache from disk
     */
    private async loadPersistedCache(): Promise<void> {
        if (!this.config.persistPath) return;

        try {
            const data = await new Promise<string>((resolve, reject) => {
                require('fs').readFile(
                    this.config.persistPath!,
                    'utf8',
                    (err: Error | null, data: string) => {
                        if (err) reject(err);
                        else resolve(data);
                    }
                );
            });

            const persistData = JSON.parse(data);

            await this.clear();
            for (const { key, entry } of persistData.entries) {
                if (Date.now() - entry.timestamp <= this.config.maxTTL) {
                    await this.set(key, entry.task);
                }
            }

            this.hits = persistData.stats.hits;
            this.misses = persistData.stats.misses;

            this.logger.debug('Cache loaded', {
                path: this.config.persistPath,
                entries: this.cache.size
            });
        } catch (error) {
            this.logger.error('Failed to load persisted cache', { error });
        }
    }
}

================
File: src/task/core/cache/cache-types.ts
================
import { Task } from '../../../types/task.js';

export interface CacheConfig {
    maxSize: number;        // Maximum number of entries in cache
    baseTTL: number;        // Base time-to-live in milliseconds
    maxTTL: number;         // Maximum time-to-live in milliseconds
    cleanupInterval: number; // Cleanup interval in milliseconds
    persistPath: string | null; // Optional path for cache persistence
}

export interface CacheEntry {
    task: Task;
    timestamp: number;
    lastAccessed: number;
    accessCount: number;
}

export interface CacheStats {
    size: number;
    hitRate: number;
    averageAccessCount: number;
    memoryUsage: number;
}

export interface CacheManager {
    get(path: string): Promise<Task | null>;
    set(path: string, task: Task): Promise<void>;
    delete(path: string): Promise<void>;
    clear(): Promise<void>;
    cleanup(): Promise<void>;
    destroy(): Promise<void>;
    getStats(): Promise<CacheStats>;
}

================
File: src/task/core/indexing/index-manager.ts
================
/**
 * Task index manager
 * Maintains in-memory indexes for efficient task lookups
 */
import { ErrorCodes, createError } from '../../../errors/index.js';
import { Task, TaskStatus } from '../../../types/task.js';
import { TaskIndex, IndexStats } from '../../../types/indexing.js';
import { Logger } from '../../../logging/index.js';
import { globToRegex, generatePathPatterns, matchesPattern } from '../../../utils/pattern-matcher.js';


export class TaskIndexManager {
    private readonly logger: Logger;
    private readonly taskIndexes: Map<string, TaskIndex>;
    private readonly pathIndex: Map<string, Set<string>>;
    private readonly patternIndex: Map<string, Set<string>>;
    private readonly statusIndex: Map<TaskStatus, Set<string>>;
    private readonly parentIndex: Map<string, Set<string>>;
    private readonly dependencyIndex: Map<string, Set<string>>;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'TaskIndexManager' });
        this.taskIndexes = new Map();
        this.pathIndex = new Map();
        this.patternIndex = new Map();
        this.statusIndex = new Map();
        this.parentIndex = new Map();
        this.dependencyIndex = new Map();
    }

    /**
     * Indexes path patterns for efficient pattern matching
     */
    private indexPathPatterns(path: string): void {
        const patterns = generatePathPatterns(path);
        
        for (const pattern of patterns) {
            let paths = this.patternIndex.get(pattern);
            if (!paths) {
                paths = new Set();
                this.patternIndex.set(pattern, paths);
            }
            paths.add(path);
        }
    }

    /**
     * Indexes a task
     */
    async indexTask(task: Task): Promise<void> {
        try {
            // Create task index
            const taskIndex: TaskIndex = {
                ...task,
                path: task.path,
                status: task.status,
                parentPath: task.parentPath,
                dependencies: task.dependencies,
                subtasks: task.subtasks
            };

            // Update task indexes
            this.taskIndexes.set(task.path, taskIndex);

            // Update path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                let paths = this.pathIndex.get(prefix);
                if (!paths) {
                    paths = new Set();
                    this.pathIndex.set(prefix, paths);
                }
                paths.add(task.path);
            }
            this.indexPathPatterns(task.path);

            // Update status index
            let statusPaths = this.statusIndex.get(task.status);
            if (!statusPaths) {
                statusPaths = new Set();
                this.statusIndex.set(task.status, statusPaths);
            }
            statusPaths.add(task.path);

            // Update parent index
            if (task.parentPath) {
                let children = this.parentIndex.get(task.parentPath);
                if (!children) {
                    children = new Set();
                    this.parentIndex.set(task.parentPath, children);
                }
                children.add(task.path);
            }

            // Update dependency index
            for (const depPath of task.dependencies) {
                let dependents = this.dependencyIndex.get(depPath);
                if (!dependents) {
                    dependents = new Set();
                    this.dependencyIndex.set(depPath, dependents);
                }
                dependents.add(task.path);
            }

            this.logger.debug('Indexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to index task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to index task',
                errorMessage
            );
        }
    }

    /**
     * Gets tasks by path pattern
     */
    async getTasksByPattern(pattern: string): Promise<TaskIndex[]> {
        // First try exact pattern match from pattern index
        const exactMatches = this.patternIndex.get(pattern);
        if (exactMatches) {
            return Array.from(exactMatches)
                .map(path => this.taskIndexes.get(path))
                .filter((task): task is TaskIndex => task !== undefined);
        }

        // Try prefix match from path index
        const prefixMatches = this.pathIndex.get(pattern);
        if (prefixMatches) {
            return Array.from(prefixMatches)
                .map(path => this.taskIndexes.get(path))
                .filter((task): task is TaskIndex => task !== undefined);
        }

        // Fall back to regex matching
        const regex = globToRegex(pattern);
        const matchingPaths = Array.from(this.taskIndexes.keys())
            .filter(path => regex.test(path));

        return matchingPaths
            .map(path => this.taskIndexes.get(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks by status with optional pattern filtering
     */
    async getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]> {
        const statusPaths = this.statusIndex.get(status) || new Set<string>();
        
        if (!pattern) {
            return Array.from(statusPaths)
                .map(path => this.taskIndexes.get(path))
                .filter((task): task is TaskIndex => task !== undefined);
        }

        // Filter by pattern if provided
        const matchingPaths = Array.from(statusPaths)
            .filter(path => matchesPattern(path, pattern));

        return matchingPaths
            .map(path => this.taskIndexes.get(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets project tasks by pattern
     */
    async getProjectTasks(pattern: string): Promise<TaskIndex[]> {
        return this.getTasksByPattern(pattern);
    }

    /**
     * Gets tasks by parent path
     */
    async getTasksByParent(parentPath: string): Promise<TaskIndex[]> {
        const children = this.parentIndex.get(parentPath) || new Set<string>();
        return Array.from(children)
            .map(path => this.taskIndexes.get(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks that depend on a task
     */
    async getDependentTasks(path: string): Promise<TaskIndex[]> {
        const dependents = this.dependencyIndex.get(path) || new Set<string>();
        return Array.from(dependents)
            .map(path => this.taskIndexes.get(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets a task by path
     */
    async getTaskByPath(path: string): Promise<TaskIndex | null> {
        return this.taskIndexes.get(path) || null;
    }

    /**
     * Unindexes a task
     */
    async unindexTask(task: Task): Promise<void> {
        try {
            // Remove from task indexes
            this.taskIndexes.delete(task.path);

            // Remove from path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                const paths = this.pathIndex.get(prefix);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.pathIndex.delete(prefix);
                    }
                }
            }

            // Remove from pattern index
            const patterns = generatePathPatterns(task.path);
            for (const pattern of patterns) {
                const paths = this.patternIndex.get(pattern);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.patternIndex.delete(pattern);
                    }
                }
            }

            // Remove from status index
            const statusPaths = this.statusIndex.get(task.status);
            if (statusPaths) {
                statusPaths.delete(task.path);
                if (statusPaths.size === 0) {
                    this.statusIndex.delete(task.status);
                }
            }

            // Remove from parent index
            if (task.parentPath) {
                const children = this.parentIndex.get(task.parentPath);
                if (children) {
                    children.delete(task.path);
                    if (children.size === 0) {
                        this.parentIndex.delete(task.parentPath);
                    }
                }
            }

            // Remove from dependency index
            for (const depPath of task.dependencies) {
                const dependents = this.dependencyIndex.get(depPath);
                if (dependents) {
                    dependents.delete(task.path);
                    if (dependents.size === 0) {
                        this.dependencyIndex.delete(depPath);
                    }
                }
            }

            this.logger.debug('Unindexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to unindex task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to unindex task',
                errorMessage
            );
        }
    }

    /**
     * Gets index statistics
     */
    getStats(): IndexStats {
        const byStatus = {} as Record<TaskStatus, number>;
        const byDepth = {} as Record<number, number>;
        let totalDepth = 0;

        for (const task of this.taskIndexes.values()) {
            // Count by status
            byStatus[task.status] = (byStatus[task.status] || 0) + 1;

            // Count by depth
            const depth = task.path.split('/').length - 1;
            byDepth[depth] = (byDepth[depth] || 0) + 1;
            totalDepth += depth;
        }

        return {
            totalTasks: this.taskIndexes.size,
            byStatus,
            byDepth,
            averageDepth: this.taskIndexes.size > 0 ? totalDepth / this.taskIndexes.size : 0
        };
    }

    /**
     * Clears all indexes
     */
    clear(): void {
        this.taskIndexes.clear();
        this.pathIndex.clear();
        this.patternIndex.clear();
        this.statusIndex.clear();
        this.parentIndex.clear();
        this.dependencyIndex.clear();
        this.logger.debug('Cleared all indexes');
    }
}

================
File: src/task/core/transactions/transaction-manager.ts
================
/**
 * Manages atomic transactions for task operations
 */

import { Logger } from '../../../logging/index.js';
import { TaskStorage } from '../../../types/storage.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { 
    Transaction,
    Operation,
    TransactionResult 
} from './transaction-types.js';

export class TransactionManager {
    private readonly logger: Logger;
    private activeTransactions: Map<string, Transaction>;
    private transactionCounter: number;

    constructor(private readonly storage?: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TransactionManager' });
        this.activeTransactions = new Map();
        this.transactionCounter = 0;
    }

    /**
     * Begins a new transaction
     */
    async begin(): Promise<Transaction> {
        const id = this.generateTransactionId();
        const transaction: Transaction = {
            id,
            operations: [],
            timestamp: Date.now(),
            status: 'pending'
        };

        this.activeTransactions.set(id, transaction);
        
        this.logger.debug('Transaction started', { 
            transactionId: id,
            timestamp: transaction.timestamp 
        });

        return transaction;
    }

    /**
     * Commits a transaction
     */
    async commit(transaction: Transaction): Promise<TransactionResult> {
        try {
            if (!this.activeTransactions.has(transaction.id)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Transaction ${transaction.id} not found`
                );
            }

            if (transaction.status !== 'pending') {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Transaction ${transaction.id} is already ${transaction.status}`
                );
            }

            // If storage is provided, persist the transaction
            if (this.storage) {
                await this.persistTransaction(transaction);
            }

            transaction.status = 'committed';
            this.activeTransactions.delete(transaction.id);

            this.logger.debug('Transaction committed', { 
                transactionId: transaction.id,
                operationCount: transaction.operations.length 
            });

            return {
                success: true,
                transactionId: transaction.id
            };
        } catch (error) {
            this.logger.error('Failed to commit transaction', { 
                error,
                transactionId: transaction.id 
            });

            await this.rollback(transaction);

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Rolls back a transaction
     */
    async rollback(transaction: Transaction): Promise<TransactionResult> {
        try {
            if (!this.activeTransactions.has(transaction.id)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Transaction ${transaction.id} not found`
                );
            }

            // Reverse operations in reverse order
            for (const operation of [...transaction.operations].reverse()) {
                await this.rollbackOperation(operation);
            }

            transaction.status = 'rolled_back';
            this.activeTransactions.delete(transaction.id);

            this.logger.debug('Transaction rolled back', { 
                transactionId: transaction.id,
                operationCount: transaction.operations.length 
            });

            return {
                success: true,
                transactionId: transaction.id
            };
        } catch (error) {
            this.logger.error('Failed to rollback transaction', { 
                error,
                transactionId: transaction.id 
            });

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Gets active transaction by ID
     */
    getTransaction(id: string): Transaction | undefined {
        return this.activeTransactions.get(id);
    }

    /**
     * Generates a unique transaction ID
     */
    private generateTransactionId(): string {
        this.transactionCounter++;
        return `txn_${Date.now()}_${this.transactionCounter}`;
    }

    /**
     * Persists a transaction to storage
     */
    private async persistTransaction(transaction: Transaction): Promise<void> {
        if (!this.storage) return;

        try {
            // Implementation depends on storage interface
            // Could store in a transactions table or log
            this.logger.debug('Transaction persisted', { 
                transactionId: transaction.id 
            });
        } catch (error) {
            this.logger.error('Failed to persist transaction', { 
                error,
                transactionId: transaction.id 
            });
            throw error;
        }
    }

    /**
     * Rolls back a single operation
     */
    private async rollbackOperation(operation: Operation): Promise<void> {
        if (!this.storage) return;

        try {
            switch (operation.type) {
                case 'delete':
                    // Restore deleted tasks
                    await this.storage.saveTasks(operation.tasks);
                    break;

                case 'update':
                    // Revert task to previous state
                    // Would need to store previous state in operation
                    break;

                case 'create':
                    // Delete created task
                    await this.storage.deleteTasks([operation.task.path]);
                    break;
            }
        } catch (error) {
            this.logger.error('Failed to rollback operation', { 
                error,
                operationType: operation.type 
            });
            throw error;
        }
    }
}

================
File: src/task/core/transactions/transaction-types.ts
================
/**
 * Transaction types for atomic task operations
 */

import { Task } from '../../../types/task.js';

export interface Transaction {
    id: string;
    operations: Operation[];
    timestamp: number;
    status: TransactionStatus;
}

export type TransactionStatus = 'pending' | 'committed' | 'rolled_back';

export type Operation = 
    | DeleteOperation
    | UpdateOperation
    | CreateOperation;

export interface DeleteOperation {
    type: 'delete';
    paths: string[];
    tasks: Task[];
}

export interface UpdateOperation {
    type: 'update';
    path: string;
    task: Task;
}

export interface CreateOperation {
    type: 'create';
    task: Task;
}

export interface TransactionResult {
    success: boolean;
    transactionId: string;
    error?: Error;
}

================
File: src/task/core/dependency-validator.ts
================
/**
 * Task dependency validation
 */
import { Logger } from '../../logging/index.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { Task, TaskStatus } from '../../types/task.js';

export type GetTaskByPath = (path: string) => Promise<Task | null>;

interface DependencyNode {
    path: string;
    dependencies: Set<string>;
    dependents: Set<string>;
    visited: boolean;
    inPath: boolean;
}

export class DependencyValidator {
    private readonly logger: Logger;
    private readonly nodes: Map<string, DependencyNode>;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'DependencyValidator' });
        this.nodes = new Map();
    }

    /**
     * Validates task dependencies
     */
    async validateDependencies(
        taskPath: string,
        dependencies: string[],
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        try {
            // Pre-validate dependencies exist
            await this.preValidateDependencies(dependencies, getTaskByPath);

            // Reset validation state
            this.nodes.clear();

            // Build dependency graph
            await this.buildDependencyGraph(taskPath, dependencies, getTaskByPath);

            // Check for cycles
            this.detectCycles(taskPath);

            // Validate dependency statuses
            await this.validateDependencyStatuses(getTaskByPath);

            this.logger.debug('Dependencies validated successfully', {
                taskPath,
                dependencies,
                validationSteps: [
                    'pre-validation',
                    'graph-building',
                    'cycle-detection',
                    'status-validation'
                ]
            });
        } catch (error) {
            this.logger.error('Dependency validation failed', {
                taskPath,
                dependencies,
                error
            });
            throw error;
        }
    }

    /**
     * Validates dependencies for a status change
     */
    async validateDependenciesForStatus(
        task: Task,
        newStatus: TaskStatus,
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        if (newStatus === TaskStatus.COMPLETED) {
            await this.validateDependenciesForCompletion(task, getTaskByPath);
        }

        // For other status transitions, validate basic dependencies
        await this.validateDependencies(task.path, task.dependencies, getTaskByPath);
    }

    /**
     * Validates dependencies for task completion
     */
    async validateDependenciesForCompletion(
        task: Task,
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        // Reset validation state
        this.nodes.clear();

        // Build dependency graph
        await this.buildDependencyGraph(task.path, task.dependencies, getTaskByPath);

        // Check for cycles first
        this.detectCycles(task.path);

        // Get all dependencies in topological order
        const sortedDeps = await this.getTopologicalOrder(task.path);
        
        // Check all dependencies are completed in order
        for (const path of sortedDeps) {
            if (path === task.path) continue;

            const depTask = await getTaskByPath(path);
            if (!depTask) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    `Dependency task not found: ${path}`
                );
            }

            if (depTask.status !== TaskStatus.COMPLETED) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    `Cannot complete task: dependency ${path} is not completed`
                );
            }
        }
    }

    /**
     * Gets dependencies in topological order
     */
    private async getTopologicalOrder(startPath: string): Promise<string[]> {
        const order: string[] = [];
        const visited = new Set<string>();

        const visit = async (path: string) => {
            if (visited.has(path)) return;
            visited.add(path);

            const node = this.nodes.get(path);
            if (!node) return;

            for (const depPath of node.dependencies) {
                await visit(depPath);
            }

            order.push(path);
        };

        await visit(startPath);
        return order;
    }

    /**
     * Builds the dependency graph
     */
    /**
     * Pre-validates all dependencies exist before building the graph
     */
    private async preValidateDependencies(
        dependencies: string[],
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        const missingDeps: string[] = [];
        
        for (const depPath of dependencies) {
            const depTask = await getTaskByPath(depPath);
            if (!depTask) {
                missingDeps.push(depPath);
            }
        }

        if (missingDeps.length > 0) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                {
                    message: 'One or more dependency tasks not found',
                    context: {
                        missingDependencies: missingDeps,
                        totalDependencies: dependencies.length
                    }
                },
                `Missing dependencies: ${missingDeps.join(', ')}`,
                'Ensure all dependency tasks exist before creating relationships'
            );
        }
    }

    private async buildDependencyGraph(
        taskPath: string,
        dependencies: string[],
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        try {
            // Create node for current task
            const node = this.getOrCreateNode(taskPath);

            // Process each dependency
            for (const depPath of dependencies) {
                const depTask = await getTaskByPath(depPath);
                if (!depTask) {
                    // This shouldn't happen due to pre-validation, but handle just in case
                    throw createError(
                        ErrorCodes.TASK_NOT_FOUND,
                        {
                            message: 'Dependency task not found during graph building',
                            context: {
                                taskPath,
                                dependencyPath: depPath,
                                graphState: this.getGraphState()
                            }
                        }
                    );
                }

                // Add dependency relationship
                node.dependencies.add(depPath);
                const depNode = this.getOrCreateNode(depPath);
                depNode.dependents.add(taskPath);

                // Process transitive dependencies
                await this.buildDependencyGraph(
                    depPath,
                    depTask.dependencies,
                    getTaskByPath
                );
            }
        } catch (error) {
            this.logger.error('Error building dependency graph', {
                taskPath,
                dependencies,
                error,
                graphState: this.getGraphState()
            });
            throw error;
        }
    }

    /**
     * Detects cycles in the dependency graph
     */
    private detectCycles(startPath: string): void {
        const node = this.nodes.get(startPath);
        if (!node) {
            return;
        }

        node.visited = true;
        node.inPath = true;

        for (const depPath of node.dependencies) {
            const depNode = this.nodes.get(depPath);
            if (!depNode) {
                continue;
            }

            if (!depNode.visited) {
                this.detectCycles(depPath);
            } else if (depNode.inPath) {
                const cyclePath = this.getCyclePath(depPath);
                throw createError(
                    ErrorCodes.TASK_CYCLE,
                    {
                        message: 'Circular dependency detected in task graph',
                        context: {
                            cyclePath,
                            startPath,
                            affectedTasks: Array.from(this.nodes.keys()),
                            graphState: this.getGraphState()
                        }
                    },
                    `Circular dependency: ${cyclePath}`,
                    'Remove one of the dependencies to break the cycle'
                );
            }
        }

        node.inPath = false;
    }

    /**
     * Gets the path of a dependency cycle
     */
    private getCyclePath(startPath: string): string {
        const cycle: string[] = [startPath];
        let current = startPath;

        while (true) {
            const node = this.nodes.get(current);
            if (!node) {
                break;
            }

            for (const depPath of node.dependencies) {
                const depNode = this.nodes.get(depPath);
                if (depNode?.inPath) {
                    cycle.push(depPath);
                    if (depPath === startPath) {
                        return cycle.join(' -> ');
                    }
                    current = depPath;
                    break;
                }
            }
        }

        return cycle.join(' -> ');
    }

    /**
     * Validates dependency task statuses
     */
    private async validateDependencyStatuses(
        getTaskByPath: GetTaskByPath
    ): Promise<void> {
        const statusIssues: Array<{ path: string; status: TaskStatus; issue: string }> = [];

        for (const [path] of this.nodes) {
            const task = await getTaskByPath(path);
            if (!task) {
                continue;
            }

            if (task.status === TaskStatus.FAILED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task has failed'
                });
            }

            if (task.status === TaskStatus.BLOCKED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task is blocked'
                });
            }
        }

        if (statusIssues.length > 0) {
            throw createError(
                ErrorCodes.TASK_DEPENDENCY,
                {
                    message: 'Dependency status validation failed',
                    context: {
                        statusIssues,
                        graphState: this.getGraphState()
                    }
                },
                `Invalid dependency statuses: ${statusIssues.map(i => `${i.path} (${i.status})`).join(', ')}`,
                'Ensure all dependencies are in a valid state before proceeding'
            );
        }
    }

    /**
     * Gets or creates a dependency node
     */
    private getOrCreateNode(path: string): DependencyNode {
        let node = this.nodes.get(path);
        if (!node) {
            node = {
                path,
                dependencies: new Set(),
                dependents: new Set(),
                visited: false,
                inPath: false
            };
            this.nodes.set(path, node);
        }
        return node;
    }

    /**
     * Gets the current state of the dependency graph for debugging
     */
    private getGraphState(): Record<string, unknown> {
        const graphState: Record<string, unknown> = {};
        for (const [path, node] of this.nodes) {
            graphState[path] = {
                dependencies: Array.from(node.dependencies),
                dependents: Array.from(node.dependents),
                visited: node.visited,
                inPath: node.inPath
            };
        }
        return graphState;
    }
}

================
File: src/task/core/index.ts
================
/**
 * Task Core Module
 * 
 * Provides core task management functionality:
 * - Task storage and persistence
 * - Dependency validation
 * - Status management
 */

export * from './dependency-validator.js';
export * from './status-manager.js';
export * from './task-store.js';

================
File: src/task/core/status-manager.ts
================
/**
 * Task Status Manager
 * 
 * Handles task status transitions and propagation, including:
 * - Status transition validation with rollback
 * - Parent status updates with deadlock prevention
 * - Child status propagation with race condition handling
 * - Status dependency enforcement with transaction support
 * - Automatic dependency-based blocking
 */

import { Task, TaskStatus } from '../../types/task.js';
import { TaskError, ErrorCodes } from '../../errors/index.js';
import { DependencyValidator } from './dependency-validator.js';
import { Logger } from '../../logging/index.js';
import { generateShortId } from '../../utils/id-generator.js';

interface StatusUpdate {
    taskPath: string;
    oldStatus: TaskStatus;
    newStatus: TaskStatus;
    timestamp: number;
}

interface StatusTransaction {
    id: string;
    updates: StatusUpdate[];
    timestamp: number;
}

type CompletedOrFailed = TaskStatus.COMPLETED | TaskStatus.FAILED;
type PendingOrInProgress = TaskStatus.PENDING | TaskStatus.IN_PROGRESS;
type GetTaskByPath = (path: string) => Promise<Task | null>;

// Status transition guidance for error messages
const STATUS_TRANSITION_GUIDE: Record<TaskStatus, Partial<Record<TaskStatus, string>>> = {
    [TaskStatus.PENDING]: {
        [TaskStatus.IN_PROGRESS]: "Begin task execution",
        [TaskStatus.BLOCKED]: "Set blocked state due to dependencies"
    },
    [TaskStatus.IN_PROGRESS]: {
        [TaskStatus.COMPLETED]: "Set completion state",
        [TaskStatus.FAILED]: "Set failed state due to execution errors",
        [TaskStatus.BLOCKED]: "Set blocked state due to dependencies"
    },
    [TaskStatus.COMPLETED]: {
        [TaskStatus.FAILED]: "Set failed state after validation errors"
    },
    [TaskStatus.FAILED]: {
        [TaskStatus.IN_PROGRESS]: "Retry task execution"
    },
    [TaskStatus.BLOCKED]: {
        [TaskStatus.IN_PROGRESS]: "Resume execution after dependency resolution",
        [TaskStatus.FAILED]: "Set failed state due to unresolvable dependencies"
    }
};

export class StatusManager {
    private dependencyValidator: DependencyValidator;
    private logger: Logger;
    private transactions: Map<string, StatusTransaction>;
    private processingTasks: Map<string, { timestamp: number; retryCount: number }>;
    private readonly LOCK_TIMEOUT = 1000; // Reduced to 1 second
    private readonly MAX_RETRIES = 3;
    private readonly RETRY_DELAY = 200; // 200ms between retries

    constructor() {
        this.dependencyValidator = new DependencyValidator();
        this.logger = Logger.getInstance().child({ component: 'StatusManager' });
        this.transactions = new Map();
        this.processingTasks = new Map();

        // Cleanup stale locks periodically
        setInterval(() => this.cleanupStaleLocks(), this.LOCK_TIMEOUT);
    }

    /**
     * Cleanup stale locks
     */
    private cleanupStaleLocks(): void {
        const now = Date.now();
        for (const [taskId, { timestamp }] of this.processingTasks.entries()) {
            if (now - timestamp > this.LOCK_TIMEOUT) {
                this.processingTasks.delete(taskId);
                this.logger.warn('Cleaned up stale lock', { taskId });
            }
        }
    }

    /**
     * Determines if a task should be blocked based on dependencies
     * Updated to handle bulk operations and dependency states
     */
    async isBlocked(
        task: Task, 
        getTaskByPath: GetTaskByPath,
        context: { isBulkOperation?: boolean } = {}
    ): Promise<{ blocked: boolean; reason?: string }> {
        // Don't block completed or failed tasks
        if (task.status === TaskStatus.COMPLETED || task.status === TaskStatus.FAILED) {
            return { blocked: false };
        }

        if (task.dependencies.length === 0) {
            return { blocked: false };
        }

        const depTasks = await Promise.all(task.dependencies.map(depPath => getTaskByPath(depPath)));
        
        // In bulk operations, only block if dependencies have failed
        if (context.isBulkOperation) {
            const hasFailedDeps = depTasks.some(depTask => depTask?.status === TaskStatus.FAILED);
            return {
                blocked: hasFailedDeps,
                reason: hasFailedDeps ? 'One or more dependencies have failed' : undefined
            };
        }

        // For completion, all dependencies must be completed
        if (task.status === TaskStatus.IN_PROGRESS) {
            const incompleteDeps = depTasks.filter(
                depTask => !depTask || depTask.status !== TaskStatus.COMPLETED
            );
            if (incompleteDeps.length > 0) {
                return {
                    blocked: true,
                    reason: `Dependencies not completed: ${incompleteDeps.map(d => d?.path).join(', ')}`
                };
            }
        }

        // For other transitions, block if any dependency has failed
        const failedDeps = depTasks.filter(depTask => depTask?.status === TaskStatus.FAILED);
        if (failedDeps.length > 0) {
            return {
                blocked: true,
                reason: `Failed dependencies: ${failedDeps.map(d => d?.path).join(', ')}`
            };
        }

        return { blocked: false };
    }

    /**
     * Validates and processes a status transition with rollback support
     * @param isBulkOperation Set to true to enable bulk operation mode with relaxed transition rules
     */
    async validateAndProcessStatusChange(
        task: Task,
        newStatus: TaskStatus,
        getTaskByPath: GetTaskByPath,
        updateTask: (path: string, updates: { status: TaskStatus }) => Promise<void>,
        isBulkOperation: boolean = false
    ): Promise<void> {
        const transactionId = generateShortId();
        this.transactions.set(transactionId, {
            id: transactionId,
            updates: [],
            timestamp: Date.now()
        });

        try {
            // Try to acquire lock with retries
            await this.acquireLockWithRetry(task.path);

            // Check if task should be automatically blocked
            const { blocked, reason } = await this.isBlocked(task, getTaskByPath, { isBulkOperation });
            if (blocked && newStatus !== TaskStatus.BLOCKED) {
                throw new TaskError(
                    ErrorCodes.TASK_STATUS,
                    'Task is blocked by dependencies',
                    {
                        path: task.path,
                        currentStatus: task.status,
                        requestedStatus: newStatus,
                        reason,
                        suggestion: reason || 'Resolve dependency issues before proceeding'
                    }
                );
            }

            // Validate the transition with bulk operation context
            await this.validateStatusTransition(task, newStatus, getTaskByPath, { isBulkOperation });

            // Process status change effects
            await this.propagateStatusChange(
                task,
                newStatus,
                getTaskByPath,
                updateTask,
                transactionId
            );

            // Commit transaction
            await this.commitTransaction(transactionId, updateTask);
        } catch (error) {
            // Rollback on error
            await this.rollbackTransaction(transactionId, updateTask);
            throw error;
        } finally {
            // Release lock
            this.releaseLock(task.path);
            this.transactions.delete(transactionId);
        }
    }

    /**
     * Acquires a lock for a task with retries
     */
    private async acquireLockWithRetry(taskPath: string): Promise<void> {
        let retryCount = 0;
        while (retryCount < this.MAX_RETRIES) {
            try {
                await this.acquireLock(taskPath);
                return;
            } catch (error) {
                retryCount++;
                if (retryCount === this.MAX_RETRIES) {
                    throw error;
                }
                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
            }
        }
    }

    /**
     * Acquires a lock for a task
     */
    private async acquireLock(taskPath: string): Promise<void> {
        const taskLock = this.processingTasks.get(taskPath);
        if (taskLock) {
            const timeSinceLock = Date.now() - taskLock.timestamp;
            if (timeSinceLock < this.LOCK_TIMEOUT) {
                throw new TaskError(
                    ErrorCodes.OPERATION_FAILED,
                    'Task is currently being updated by another operation. Please try again shortly.',
                    {
                        path: taskPath,
                        timeout: this.LOCK_TIMEOUT - timeSinceLock,
                        retryAfter: Math.ceil((this.LOCK_TIMEOUT - timeSinceLock) / 1000),
                        suggestion: 'Retry operation after lock expiration'
                    }
                );
            }
            // Lock has expired, clean it up
            this.processingTasks.delete(taskPath);
        }
        this.processingTasks.set(taskPath, { timestamp: Date.now(), retryCount: 0 });
    }

    /**
     * Releases a lock for a task
     */
    private releaseLock(taskPath: string): void {
        this.processingTasks.delete(taskPath);
    }

    /**
     * Validates a status transition with support for bulk operations
     */
    private async validateStatusTransition(
        task: Task,
        newStatus: TaskStatus,
        getTaskByPath: GetTaskByPath,
        context: { isBulkOperation?: boolean } = {}
    ): Promise<void> {
        const isCompletedOrFailed = (status: TaskStatus): status is CompletedOrFailed => 
            status === TaskStatus.COMPLETED || status === TaskStatus.FAILED;
        
        const isPendingOrInProgress = (status: TaskStatus): status is PendingOrInProgress =>
            status === TaskStatus.PENDING || status === TaskStatus.IN_PROGRESS;

        // Special handling for bulk operations
        if (context.isBulkOperation) {
            // Allow direct completion in bulk operations when dependencies are satisfied
            if (newStatus === TaskStatus.COMPLETED) {
                const depTasks = await Promise.all(task.dependencies.map(depPath => getTaskByPath(depPath)));
                const dependenciesSatisfied = depTasks.every(depTask => depTask && depTask.status === TaskStatus.COMPLETED);

                if (dependenciesSatisfied) {
                    // Skip normal transition rules for bulk completion
                    return;
                }
            }

            // Allow resetting tasks in bulk operations
            if (newStatus === TaskStatus.PENDING) {
                return;
            }
        }

        // Allow reverting completed/failed tasks in bulk operations
        if (!context.isBulkOperation && isCompletedOrFailed(task.status) && isPendingOrInProgress(newStatus)) {
            throw new TaskError(
                ErrorCodes.TASK_STATUS,
                'Invalid status transition: Cannot revert completed or failed tasks to pending or in_progress state',
                { 
                    path: task.path, 
                    currentStatus: task.status, 
                    newStatus,
                    suggestion: 'Create new task for retry operations - completed/failed states are terminal'
                }
            );
        }

        // Validate dependencies for status transition
        if (!context.isBulkOperation) {
            await this.dependencyValidator.validateDependenciesForStatus(task, newStatus, getTaskByPath);
        }

        // Check dependencies and subtasks for completion
        if (newStatus === TaskStatus.COMPLETED && !context.isBulkOperation) {
            // Validate dependencies
            await this.dependencyValidator.validateDependenciesForCompletion(task, getTaskByPath);

            // Check subtasks for completion
            const subtasks = await Promise.all(task.subtasks.map(path => getTaskByPath(path)));
            const incompleteSubtasks = subtasks.filter(subtask => !subtask || subtask.status !== TaskStatus.COMPLETED);

            if (incompleteSubtasks.length > 0) {
                throw new TaskError(
                    ErrorCodes.TASK_STATUS,
                    'Cannot complete task: Some subtasks are still incomplete',
                    { 
                        path: task.path,
                        incompleteSubtasks: incompleteSubtasks.map(t => ({
                            path: t?.path,
                            status: t?.status,
                            name: t?.name
                        })),
                        suggestion: 'Parent completion requires all subtasks to be in completed state'
                    }
                );
            }
        }

        // Validate status transition based on current status
        this.validateStatusTransitionRules(task.status, newStatus, { 
            path: task.path,
            hasSubtasks: task.subtasks.length > 0,
            hasDependencies: task.dependencies.length > 0,
            isBulkOperation: context.isBulkOperation
        });
    }

    /**
     * Validates status transition rules with enhanced flexibility for bulk operations
     */
    private validateStatusTransitionRules(
        currentStatus: TaskStatus,
        newStatus: TaskStatus,
        context: { path: string; hasSubtasks: boolean; hasDependencies: boolean; isBulkOperation?: boolean } = { 
            path: 'unknown',
            hasSubtasks: false,
            hasDependencies: false,
            isBulkOperation: false
        }
    ): void {
        // Enhanced state machine with special handling for bulk operations
        const stateMachine: Record<TaskStatus, {
            allowedTransitions: Set<TaskStatus>;
            bulkAllowedTransitions?: Set<TaskStatus>; // Additional transitions allowed in bulk operations
            conditions?: (ctx: typeof context) => { allowed: boolean; reason?: string };
        }> = {
            [TaskStatus.PENDING]: {
                allowedTransitions: new Set([
                    TaskStatus.IN_PROGRESS,
                    TaskStatus.BLOCKED,
                    TaskStatus.FAILED,
                    TaskStatus.COMPLETED // Allow direct completion always
                ]),
                conditions: (ctx): { allowed: boolean; reason?: string } => {
                    // In bulk operations, allow any transition
                    if (ctx.isBulkOperation) {
                        return { allowed: true };
                    }
                    // For non-bulk operations, enforce normal rules
                    const allowed = !ctx.hasDependencies || newStatus === TaskStatus.BLOCKED || newStatus === TaskStatus.IN_PROGRESS;
                    const reason = ctx.hasDependencies ? 'Task has dependencies and must be blocked first' : undefined;
                    return { allowed, reason };
                }
            },
            [TaskStatus.IN_PROGRESS]: {
                allowedTransitions: new Set([
                    TaskStatus.COMPLETED,
                    TaskStatus.FAILED,
                    TaskStatus.BLOCKED,
                    TaskStatus.PENDING
                ]),
                conditions: (ctx): { allowed: boolean; reason?: string } => {
                    const allowed = (newStatus !== TaskStatus.COMPLETED || !ctx.hasSubtasks) || Boolean(ctx.isBulkOperation);
                    const reason = ctx.hasSubtasks && !ctx.isBulkOperation ? 'Cannot complete task with incomplete subtasks' : undefined;
                    return { allowed, reason };
                }
            },
            [TaskStatus.COMPLETED]: {
                allowedTransitions: new Set([
                    TaskStatus.FAILED,
                    TaskStatus.IN_PROGRESS
                ]),
                bulkAllowedTransitions: new Set([
                    TaskStatus.PENDING // Allow resetting in bulk operations
                ])
            },
            [TaskStatus.FAILED]: {
                allowedTransitions: new Set([
                    TaskStatus.IN_PROGRESS,
                    TaskStatus.PENDING
                ]),
                bulkAllowedTransitions: new Set([
                    TaskStatus.COMPLETED // Allow direct completion in bulk operations
                ])
            },
            [TaskStatus.BLOCKED]: {
                allowedTransitions: new Set([
                    TaskStatus.IN_PROGRESS,
                    TaskStatus.FAILED,
                    TaskStatus.PENDING
                ]),
                bulkAllowedTransitions: new Set([
                    TaskStatus.COMPLETED // Allow direct completion in bulk operations
                ]),
                conditions: (ctx): { allowed: boolean; reason?: string } => {
                    const allowed = (newStatus !== TaskStatus.IN_PROGRESS || !ctx.hasDependencies) || Boolean(ctx.isBulkOperation);
                    const reason = ctx.hasDependencies && !ctx.isBulkOperation ? 'Cannot start blocked task with incomplete dependencies' : undefined;
                    return { allowed, reason };
                }
            }
        };

        const stateConfig = stateMachine[currentStatus];
        const allowedTransitions = new Set([
            ...Array.from(stateConfig?.allowedTransitions || []),
            ...(context.isBulkOperation ? Array.from(stateConfig?.bulkAllowedTransitions || []) : [])
        ]);

        if (!allowedTransitions.has(newStatus)) {
            const allowedStates = Array.from(allowedTransitions);
            const guidance = allowedStates.map(state => {
                const guide = STATUS_TRANSITION_GUIDE[currentStatus]?.[state];
                return `${state}: ${guide || 'No specific guidance available'}`;
            });

            throw new TaskError(
                ErrorCodes.TASK_STATUS,
                'Invalid status transition',
                {
                    path: context.path,
                    currentStatus,
                    newStatus,
                    allowedTransitions: allowedStates,
                    guidance,
                    suggestion: `Consider these valid transitions from '${currentStatus}' status:\n${guidance.join('\n')}`
                }
            );
        }

        // Check additional conditions if they exist
        if (stateConfig.conditions) {
            const { allowed, reason } = stateConfig.conditions(context);
            if (!allowed) {
                throw new TaskError(
                    ErrorCodes.TASK_STATUS,
                    'Status transition condition failed',
                    {
                        path: context.path,
                        currentStatus,
                        newStatus,
                        reason,
                        suggestion: reason
                    }
                );
            }
        }
    }

    /**
     * Propagates status changes through task hierarchy with optimized locking
     */
    private async propagateStatusChange(
        task: Task,
        newStatus: TaskStatus,
        getTaskByPath: GetTaskByPath,
        updateTask: (path: string, updates: { status: TaskStatus }) => Promise<void>,
        transactionId: string
    ): Promise<void> {
        const transaction = this.transactions.get(transactionId)!;

        // Record status update
        transaction.updates.push({
            taskPath: task.path,
            oldStatus: task.status,
            newStatus,
            timestamp: Date.now()
        });

        // Update dependent tasks if task is being deleted or failed
        if (newStatus === TaskStatus.FAILED || task.status === TaskStatus.COMPLETED) {
            const dependentTasks = await this.getDependentTasks(task.path, getTaskByPath);
            await Promise.all(dependentTasks.map(async depTask => {
                if (depTask.status !== TaskStatus.BLOCKED && depTask.status !== TaskStatus.FAILED) {
                    try {
                        await this.acquireLockWithRetry(depTask.path);
                        await this.propagateStatusChange(
                            depTask,
                            TaskStatus.BLOCKED,
                            getTaskByPath,
                            updateTask,
                            transactionId
                        );
                    } finally {
                        this.releaseLock(depTask.path);
                    }
                }
            }));
        }

        // Update parent status if needed
        if (task.parentPath) {
            const parent = await getTaskByPath(task.parentPath);
            if (parent) {
                try {
                    await this.acquireLockWithRetry(parent.path);
                    const siblingTasks = await Promise.all(parent.subtasks.map(path => getTaskByPath(path)));
                    const siblings = siblingTasks.filter((t): t is Task => t !== null);

                    const newParentStatus = this.computeParentStatus(siblings, newStatus);
                    if (newParentStatus && newParentStatus !== parent.status) {
                        await this.propagateStatusChange(
                            parent,
                            newParentStatus,
                            getTaskByPath,
                            updateTask,
                            transactionId
                        );
                    }
                } finally {
                    this.releaseLock(parent.path);
                }
            }
        }

        // Update subtask status if needed
        if (newStatus === TaskStatus.BLOCKED) {
            await Promise.all(task.subtasks.map(async subtaskPath => {
                const subtask = await getTaskByPath(subtaskPath);
                if (subtask && subtask.status !== TaskStatus.BLOCKED) {
                    try {
                        await this.acquireLockWithRetry(subtaskPath);
                        await this.propagateStatusChange(
                            subtask,
                            TaskStatus.BLOCKED,
                            getTaskByPath,
                            updateTask,
                            transactionId
                        );
                    } finally {
                        this.releaseLock(subtaskPath);
                    }
                }
            }));
        }
    }

    /**
     * Gets tasks that depend on a given task
     */
    private async getDependentTasks(taskPath: string, getTaskByPath: GetTaskByPath): Promise<Task[]> {
        const taskPaths = Array.from(this.processingTasks.keys());
        const tasks = await Promise.all(taskPaths.map(path => getTaskByPath(path)));
        const validTasks = tasks.filter((t): t is Task => t !== null);
            
        return validTasks.filter(task => task.dependencies.includes(taskPath));
    }

    /**
     * Computes the appropriate parent status based on child statuses
     */
    private computeParentStatus(
        children: Task[],
        updatedChildStatus: TaskStatus
    ): TaskStatus | null {
        const statuses = new Set(children.map(c => c.status));
        statuses.add(updatedChildStatus);

        // Only update parent status in specific cases:
        
        // All completed -> completed
        if (Array.from(statuses).every(s => s === TaskStatus.COMPLETED)) {
            return TaskStatus.COMPLETED;
        }

        // All failed -> failed (don't propagate individual failures)
        if (Array.from(statuses).every(s => s === TaskStatus.FAILED)) {
            return TaskStatus.FAILED;
        }

        // All blocked -> blocked (don't propagate individual blocks)
        if (Array.from(statuses).every(s => s === TaskStatus.BLOCKED)) {
            return TaskStatus.BLOCKED;
        }

        // Don't automatically change parent status for in_progress
        // Let parent status be explicitly set
        return null;
    }

    /**
     * Commits a status transaction
     */
    private async commitTransaction(
        transactionId: string,
        updateTask: (path: string, updates: { status: TaskStatus }) => Promise<void>
    ): Promise<void> {
        const transaction = this.transactions.get(transactionId);
        if (!transaction) {
            throw new TaskError(
                ErrorCodes.OPERATION_FAILED,
                'Transaction not found - status update failed',
                { 
                    transactionId,
                    suggestion: 'Retry the status update operation'
                }
            );
        }

        // Apply all updates in order
        for (const update of transaction.updates) {
            await updateTask(update.taskPath, { status: update.newStatus });
        }
    }

    /**
     * Rolls back a status transaction
     */
    private async rollbackTransaction(
        transactionId: string,
        updateTask: (path: string, updates: { status: TaskStatus }) => Promise<void>
    ): Promise<void> {
        const transaction = this.transactions.get(transactionId);
        if (!transaction) {
            return;
        }

        // Rollback updates in reverse order
        for (const update of transaction.updates.reverse()) {
            try {
                await updateTask(update.taskPath, { status: update.oldStatus });
            } catch (error) {
                this.logger.error('Failed to rollback status update', {
                    transactionId,
                    path: update.taskPath,
                    error,
                    suggestion: 'Manual intervention may be required to restore task status'
                });
            }
        }
    }

    /**
     * Gets the computed status for a task based on its subtasks
     */
    async computeStatus(task: Task, getTaskByPath: GetTaskByPath): Promise<TaskStatus> {
        const subtaskTasks = await Promise.all(task.subtasks.map(path => getTaskByPath(path)));
        const subtasks = subtaskTasks.filter((t): t is Task => t !== null);

        if (subtasks.length === 0) {
            return task.status;
        }

        return this.computeParentStatus(subtasks, task.status) || task.status;
    }
}

================
File: src/task/core/task-store.ts
================
/**
 * Path-based task storage with caching, indexing, and transaction support
 */
import { Task, TaskStatus, validateTaskPath, isValidTaskHierarchy, getParentPath } from '../../types/task.js';
import { TaskStorage } from '../../types/storage.js';
import { Logger } from '../../logging/index.js';
import { TaskIndexManager } from './indexing/index-manager.js';
import { EnhancedCacheManager } from './cache/cache-manager.js';
import { DependencyValidator } from './dependency-validator.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionManager } from './transactions/transaction-manager.js';

const BATCH_SIZE = 50; // Maximum number of tasks to process in parallel

export class TaskStore {
    private readonly logger: Logger;
    private readonly indexManager: TaskIndexManager;
    private readonly cacheManager: EnhancedCacheManager;
    private readonly dependencyValidator: DependencyValidator;
    private readonly transactionManager: TransactionManager;

    constructor(private readonly storage: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskStore' });
        this.indexManager = new TaskIndexManager();
        this.cacheManager = new EnhancedCacheManager({
            maxSize: 1000,
            baseTTL: 60000,
            maxTTL: 300000
        });
        this.dependencyValidator = new DependencyValidator();
        this.transactionManager = new TransactionManager(storage);
    }

    /**
     * Processes tasks in batches
     */
    private async processBatch<T>(
        items: T[],
        processor: (item: T) => Promise<void>
    ): Promise<void> {
        for (let i = 0; i < items.length; i += BATCH_SIZE) {
            const batch = items.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(processor));
        }
    }

    /**
     * Gets a task by path, checking cache first
     */
    private async getTaskByPath(path: string): Promise<Task | null> {
        if (!validateTaskPath(path)) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                `Invalid task path: ${path}`
            );
        }

        // Check cache first
        const cachedTask = await this.cacheManager.get(path);
        if (cachedTask) {
            return cachedTask;
        }

        // Check index
        const indexedTask = await this.indexManager.getTaskByPath(path);
        if (indexedTask) {
            await this.cacheManager.set(path, indexedTask);
            return indexedTask;
        }

        // Load from storage
        const task = await this.storage.getTask(path);
        if (task) {
            await this.cacheManager.set(path, task);
            await this.indexManager.indexTask(task);
        }

        return task;
    }

    /**
     * Updates dependent task statuses
     */
    private async updateDependentStatuses(task: Task): Promise<void> {
        const dependentTasks = await this.indexManager.getDependentTasks(task.path);
        
        for (const depTask of dependentTasks) {
            const taskPath = depTask.path;
            const updatedTask = await this.getTaskByPath(taskPath);
            if (!updatedTask) continue;

            // If a dependency fails or is blocked, block the dependent task
            if (task.status === TaskStatus.FAILED || task.status === TaskStatus.BLOCKED) {
                updatedTask.status = TaskStatus.BLOCKED;
                await this.saveTasks([updatedTask]);
            }
            // If all dependencies are complete, unblock the dependent task
            else if (task.status === TaskStatus.COMPLETED) {
                const allDepsCompleted = await this.checkAllDependenciesCompleted(updatedTask);
                if (allDepsCompleted) {
                    updatedTask.status = TaskStatus.PENDING;
                    await this.saveTasks([updatedTask]);
                }
            }
        }
    }

    /**
     * Checks if all dependencies are completed
     */
    private async checkAllDependenciesCompleted(task: Task): Promise<boolean> {
        for (const depPath of task.dependencies) {
            const depTask = await this.getTaskByPath(depPath);
            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
                return false;
            }
        }
        return true;
    }

    /**
     * Saves tasks with validation, indexing, and transaction support
     */
    async saveTasks(tasks: Task[]): Promise<void> {
        // Validate paths and collect parent updates
        for (const task of tasks) {
            if (!validateTaskPath(task.path)) {
                throw createError(
                    ErrorCodes.TASK_INVALID_PATH,
                    `Invalid task path: ${task.path}`
                );
            }
        }

        const transaction = await this.transactionManager.begin();

        try {
            // First pass: validate all tasks and collect parent paths
            const parentPaths = new Set<string>();
            const tasksToSave = new Map<string, Task>();

            for (const task of tasks) {
                // Ensure task has required arrays
                if (!task.subtasks) task.subtasks = [];
                if (!task.dependencies) task.dependencies = [];

                // Get and validate parent path
                const parentPath = task.parentPath || getParentPath(task.path);
                if (parentPath) {
                    task.parentPath = parentPath;
                    parentPaths.add(parentPath);
                }

                tasksToSave.set(task.path, task);
            }

            // Second pass: load and validate all parents
            const parentUpdates = new Map<string, Task>();
            for (const parentPath of parentPaths) {
                const parent = await this.getTaskByPath(parentPath);
                if (!parent) {
                    throw createError(
                        ErrorCodes.TASK_PARENT_NOT_FOUND,
                        `Parent task not found: ${parentPath}. Parent tasks must be created before their children.`
                    );
                }
                parentUpdates.set(parentPath, parent);
            }

            // Third pass: validate relationships and update parent subtasks
            for (const task of tasksToSave.values()) {
                if (task.parentPath) {
                    const parent = parentUpdates.get(task.parentPath);
                    if (!parent) continue; // Already handled in second pass

                    // Validate task type hierarchy
                    if (!isValidTaskHierarchy(parent.type, task.type)) {
                        throw createError(
                            ErrorCodes.TASK_PARENT_TYPE,
                            `Invalid parent-child relationship: ${parent.type} cannot contain ${task.type}`
                        );
                    }

            // Update and index parent's subtasks if needed
            if (!parent.subtasks.includes(task.path)) {
                parent.subtasks = [...parent.subtasks, task.path];
                parentUpdates.set(parent.path, parent);
                
                // Ensure parent-child relationship is indexed
                await this.indexManager.unindexTask(parent);
                await this.indexManager.indexTask({
                    ...parent,
                    subtasks: parent.subtasks
                });
            }
                }
            }

            // Prepare final task list with updated relationships
            const allTasks = [...parentUpdates.values(), ...tasksToSave.values()];
            await this.storage.saveTasks(allTasks);

            // Clear cache for all affected tasks
            await Promise.all(allTasks.map(task => this.cacheManager.delete(task.path)));

            // Reindex all tasks to ensure relationships are properly established
            for (const task of allTasks) {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
            }

            // Validate dependencies for original tasks
            for (const task of tasks) {
                await this.dependencyValidator.validateDependencies(
                    task.path,
                    task.dependencies,
                    this.getTaskByPath.bind(this)
                );
            }

            // Propagate status changes
            await this.processBatch(tasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Tasks saved successfully', {
                count: tasks.length,
                paths: tasks.map(t => t.path)
            });
        } catch (error) {
            // Rollback transaction
            await this.transactionManager.rollback(transaction);

            // Rollback cache and indexes
            await this.processBatch(tasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            this.logger.error('Failed to save tasks', { error, tasks });
            throw error;
        }
    }

    /**
     * Gets tasks by path pattern with efficient caching
     */
    async getTasksByPattern(pattern: string): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getProjectTasks(pattern);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByPattern(pattern);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by pattern', { error, pattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status with efficient caching
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByStatus(status, '');
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByStatus(status);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task with efficient caching
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        if (!validateTaskPath(parentPath)) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                `Invalid parent path: ${parentPath}`
            );
        }

        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByParent(parentPath);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getSubtasks(parentPath);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks with transaction support
     */
    async deleteTask(path: string): Promise<void> {
        if (!validateTaskPath(path)) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                `Invalid task path: ${path}`
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Get task and subtasks
            const task = await this.storage.getTask(path);
            if (!task) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    `Task not found: ${path}`
                );
            }

            const subtasks = await this.storage.getSubtasks(path);
            const allTasks = [task, ...subtasks];
            const allPaths = allTasks.map(t => t.path);

            // Add delete operation to transaction with both paths and tasks
            transaction.operations.push({
                type: 'delete',
                paths: allPaths,
                tasks: allTasks
            });

            // Delete from storage
            await this.storage.deleteTasks(allPaths);

            // Update cache and indexes
            await this.processBatch(allTasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            // Update dependent tasks
            await this.processBatch(allTasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Task and subtasks deleted', {
                path,
                subtaskCount: subtasks.length
            });
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to delete task', { error, path });
            throw error;
        }
    }

    /**
     * Clears cache and indexes with transaction support
     */
    /**
     * Clears all tasks and resets indexes
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Must explicitly confirm task deletion'
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Clear all tasks from storage
            await this.storage.clearAllTasks();
            
            // Clear cache and indexes
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.info('All tasks and indexes cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear tasks', { error });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            this.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            this.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        const transaction = await this.transactionManager.begin();

        try {
            // Get tasks to repair
            const tasks = pathPattern ? 
                await this.getTasksByPattern(pathPattern) :
                await this.storage.getTasks([]);

            // Clear cache for affected tasks
            await Promise.all(tasks.map(task => this.cacheManager.delete(task.path)));

            // Repair relationships
            const result = await this.storage.repairRelationships(dryRun);

            if (!dryRun) {
                // Reindex all tasks after repair
                await Promise.all(tasks.map(task => this.indexManager.indexTask(task)));
            }

            await this.transactionManager.commit(transaction);
            return result;
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Clears cache and indexes
     */
    async clearCache(): Promise<void> {
        const transaction = await this.transactionManager.begin();

        try {
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.debug('Cache cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear cache', { error });
            throw error;
        }
    }
}

================
File: src/tools/handler.ts
================
/**
 * Path-based task management tools
 */
import { TaskManager } from '../task-manager.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { TaskType, TaskStatus, CreateTaskInput, UpdateTaskInput } from '../types/task.js';
import {
    createTaskSchema,
    updateTaskSchema,
    getTasksByStatusSchema,
    getTasksByPathSchema,
    getSubtasksSchema,
    deleteTaskSchema,
    bulkTaskSchema,
    clearAllTasksSchema,
    vacuumDatabaseSchema,
    repairRelationshipsSchema
} from './schemas.js';
import { DependencyAwareBatchProcessor } from '../task/core/batch/dependency-aware-batch-processor.js';
import { BatchResult } from '../types/batch.js';

interface BulkOperation {
    type: 'create' | 'update' | 'delete';
    path: string;
    data?: Record<string, unknown>;
    id?: string;
    dependencies?: string[];
}

export interface Tool {
    name: string;
    description?: string;
    inputSchema: {
        type: "object";
        properties: Record<string, unknown>;
        required?: string[];
        description?: string;
    };
}

export interface ToolResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

export class ToolHandler {
    private readonly logger: Logger;
    private readonly tools: Map<string, Tool> = new Map();
    private readonly toolHandlers: Map<string, (args: Record<string, unknown>) => Promise<ToolResponse>> = new Map();

    constructor(private readonly taskManager: TaskManager) {
        this.logger = Logger.getInstance().child({ component: 'ToolHandler' });
        this.registerDefaultTools();
    }

    /**
     * Validates task hierarchy rules
     */
    private async validateTaskHierarchy(args: Record<string, unknown>, operation: 'create' | 'update'): Promise<void> {
        const taskType = (args.type || 'TASK').toString().toUpperCase();
        const parentPath = args.parentPath as string | undefined;

        // Validate task type is uppercase
        if (taskType !== taskType.toUpperCase()) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Task type must be uppercase (TASK, GROUP, or MILESTONE)'
            );
        }

        // Validate task type is valid
        if (!['TASK', 'GROUP', 'MILESTONE'].includes(taskType)) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Invalid task type. Must be TASK, GROUP, or MILESTONE'
            );
        }

        // If parent path is provided, validate parent type compatibility
        if (parentPath) {
            const parent = await this.taskManager.getTaskByPath(parentPath);
            if (!parent) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Parent task '${parentPath}' not found`
                );
            }

            // Validate parent-child type relationships
            switch (parent.type) {
                case TaskType.MILESTONE:
                    if (!['TASK', 'GROUP'].includes(taskType)) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'MILESTONE can only contain TASK or GROUP types'
                        );
                    }
                    break;
                case TaskType.GROUP:
                    if (taskType !== 'TASK') {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'GROUP can only contain TASK types'
                        );
                    }
                    break;
                case TaskType.TASK:
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'TASK type cannot contain subtasks'
                    );
            }
        }

        // For updates, validate type changes don't break hierarchy
        if (operation === 'update' && taskType) {
            const path = args.path as string;
            const task = await this.taskManager.getTaskByPath(path);
            if (!task) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Task '${path}' not found`
                );
            }

            // Check if task has subtasks and is being changed to TASK type
            if (taskType === 'TASK') {
                const subtasks = await this.taskManager.getSubtasks(path);
                if (subtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'Cannot change to TASK type while having subtasks'
                    );
                }
            }

            // Check if changing to GROUP with non-TASK subtasks
            if (taskType === 'GROUP') {
                const subtasks = await this.taskManager.getSubtasks(path);
                const invalidSubtasks = subtasks.filter(s => s.type !== TaskType.TASK);
                if (invalidSubtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'GROUP can only contain TASK type subtasks'
                    );
                }
            }
        }
    }

    private registerDefaultTools(): void {
        const defaultTools: Array<Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }> = [
            {
                name: 'create_task',
                description: createTaskSchema.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: createTaskSchema.properties,
                    required: createTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    // Validate hierarchy rules
                    await this.validateTaskHierarchy(args, 'create');
                    
                    // Validate required fields
                    if (!args.name || typeof args.name !== 'string') {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'Task name is required and must be a string'
                        );
                    }

                    // Create task input with proper type casting
                    const taskInput: CreateTaskInput = {
                        name: args.name,
                        path: args.path as string | undefined,
                        type: args.type ? (args.type as string).toUpperCase() as TaskType : TaskType.TASK,
                        description: args.description as string | undefined,
                        parentPath: args.parentPath as string | undefined,
                        dependencies: Array.isArray(args.dependencies) ? args.dependencies as string[] : [],
                        notes: Array.isArray(args.notes) ? args.notes as string[] : undefined,
                        reasoning: args.reasoning as string | undefined,
                        metadata: args.metadata as Record<string, unknown> || {}
                    };
                    
                    const result = await this.taskManager.createTask(taskInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'update_task',
                description: updateTaskSchema.properties.updates.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: updateTaskSchema.properties,
                    required: updateTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { path, updates } = args as { path: string; updates: Record<string, unknown> };
                    
                    // Validate hierarchy rules if type is being updated
                    if (updates.type) {
                        await this.validateTaskHierarchy({ ...updates, path }, 'update');
                    }
                    
                    // Create update input with proper type casting
                    const updateInput: UpdateTaskInput = {
                        name: updates.name as string | undefined,
                        type: updates.type ? (updates.type as string).toUpperCase() as TaskType : undefined,
                        description: updates.description as string | undefined,
                        status: updates.status as TaskStatus | undefined,
                        dependencies: Array.isArray(updates.dependencies) ? updates.dependencies as string[] : undefined,
                        notes: Array.isArray(updates.notes) ? updates.notes as string[] : undefined,
                        reasoning: updates.reasoning as string | undefined,
                        metadata: updates.metadata as Record<string, unknown> | undefined
                    };
                    
                    const result = await this.taskManager.updateTask(path, updateInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_status',
                description: getTasksByStatusSchema.properties.status.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByStatusSchema.properties,
                    required: getTasksByStatusSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getTasksByStatus(args.status as unknown as TaskStatus);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_path',
                description: getTasksByPathSchema.properties.pathPattern.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByPathSchema.properties,
                    required: getTasksByPathSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.listTasks(args.pathPattern as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_subtasks',
                description: getSubtasksSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: getSubtasksSchema.properties,
                    required: getSubtasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getSubtasks(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'delete_task',
                description: deleteTaskSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: deleteTaskSchema.properties,
                    required: deleteTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.deleteTask(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'bulk_task_operations',
                description: bulkTaskSchema.properties.operations.description,
                inputSchema: {
                    type: "object",
                    properties: bulkTaskSchema.properties,
                    required: bulkTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { operations } = args as { operations: BulkOperation[] };

                    // Add dependencies based on operation order
                    const operationsWithDeps = operations.map((op, index) => ({
                        ...op,
                        id: op.path,
                        // Each operation depends on the previous one
                        dependencies: index > 0 ? [operations[index - 1].path] : []
                    }));

                    const batchProcessor = new DependencyAwareBatchProcessor<BulkOperation>({
                        batchSize: 1,
                        concurrentBatches: 1,
                        retryCount: 3,
                        retryDelay: 1000
                    });
                    
                    // Process operations sequentially with dependency ordering
                    const result = await batchProcessor.processInBatches(operationsWithDeps, 1, async (operation: BulkOperation) => {
                        try {
                            switch (operation.type) {
                                case 'create': {
                                    // Extract parent path from task path if not provided
                                    const pathSegments = operation.path.split('/');
                                    const parentPath = operation.data?.parentPath as string || 
                                        (pathSegments.length > 1 ? pathSegments.slice(0, -1).join('/') : undefined);

                                    const taskData: CreateTaskInput = {
                                        path: operation.path,
                                        name: operation.data?.name as string || pathSegments[pathSegments.length - 1] || 'Unnamed Task',
                                        type: (operation.data?.type as string || 'TASK').toUpperCase() as TaskType,
                                        description: operation.data?.description as string,
                                        dependencies: operation.data?.dependencies as string[] || [],
                                        parentPath,
                                        metadata: {
                                            ...(operation.data?.metadata || {}),
                                            created: Date.now(),
                                            updated: Date.now()
                                        }
                                    };

                                    // Validate hierarchy rules
                                    await this.validateTaskHierarchy(taskData, 'create');

                                    await this.taskManager.createTask(taskData);
                                    break;
                                }
                                case 'update': {
                                    const updateData: UpdateTaskInput = {
                                        status: operation.data?.status as TaskStatus,
                                        metadata: operation.data?.metadata as Record<string, unknown>,
                                        notes: operation.data?.notes as string[],
                                        dependencies: operation.data?.dependencies as string[],
                                        description: operation.data?.description as string,
                                        name: operation.data?.name as string,
                                        type: operation.data?.type ? (operation.data.type as string).toUpperCase() as TaskType : undefined
                                    };

                                    // Validate hierarchy rules if type is being updated
                                    if (updateData.type) {
                                        await this.validateTaskHierarchy({ ...updateData, path: operation.path }, 'update');
                                    }

                                    await this.taskManager.updateTask(operation.path, updateData);
                                    break;
                                }
                                case 'delete':
                                    await this.taskManager.deleteTask(operation.path);
                                    break;
                                default:
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        `Invalid operation type: ${operation.type}`
                                    );
                            }
                        } catch (error) {
                            this.logger.error('Operation failed', {
                                operation,
                                error
                            });
                            throw error;
                        }
                    });

                    return this.formatResponse({
                        success: result.success,
                        processedCount: result.processedCount,
                        failedCount: result.failedCount,
                        errors: result.errors.map((err: BatchResult['errors'][0]) => ({
                            operation: err.item,
                            error: err.error.message,
                            context: err.context
                        }))
                    });
                }
            },
            {
                name: 'clear_all_tasks',
                description: clearAllTasksSchema.properties.confirm.description,
                inputSchema: {
                    type: "object",
                    properties: clearAllTasksSchema.properties,
                    required: clearAllTasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.clearAllTasks(args.confirm as boolean);
                    return this.formatResponse({ success: true, message: 'All tasks cleared' });
                }
            },
            {
                name: 'vacuum_database',
                description: vacuumDatabaseSchema.properties.analyze.description,
                inputSchema: {
                    type: "object",
                    properties: vacuumDatabaseSchema.properties,
                    required: vacuumDatabaseSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.vacuumDatabase(args.analyze as boolean);
                    return this.formatResponse({ success: true, message: 'Database optimized' });
                }
            },
            {
                name: 'repair_relationships',
                description: repairRelationshipsSchema.properties.dryRun.description,
                inputSchema: {
                    type: "object",
                    properties: repairRelationshipsSchema.properties,
                    required: repairRelationshipsSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.repairRelationships(
                        args.dryRun as boolean,
                        args.pathPattern as string | undefined
                    );
                    return this.formatResponse(result);
                }
            }
        ];

        for (const tool of defaultTools) {
            this.registerTool(tool);
        }
    }

    private registerTool(tool: Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }): void {
        const { handler, ...toolDef } = tool;
        this.tools.set(tool.name, toolDef);
        this.toolHandlers.set(tool.name, handler);
        this.logger.debug('Registered tool', { name: tool.name });
    }

    async listTools(): Promise<{ tools: Tool[] }> {
        const tools = Array.from(this.tools.values());
        this.logger.info('Listed tools', { 
            count: tools.length,
            tools: tools.map(t => ({
                name: t.name,
                schema: t.inputSchema
            }))
        });
        return { tools };
    }

    async handleToolCall(request: { params: { name: string; arguments?: Record<string, unknown> } }): Promise<{
        _meta?: Record<string, unknown>;
        content: Array<{ type: string; text: string }>;
    }> {
        const { name, arguments: args = {} } = request.params;

        const tool = this.tools.get(name);
        if (!tool) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                { tool: name },
                'Unknown tool'
            );
        }

        const handler = this.toolHandlers.get(name);
        if (!handler) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                { tool: name },
                'Tool handler not found'
            );
        }

        try {
            // Validate dependencies are at root level
            if ((name === 'create_task' || name === 'update_task') && 
                (args as any).metadata?.dependencies) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    'Dependencies must be specified at root level, not in metadata'
                );
            }

            this.logger.debug('Executing tool', { name, args });
            const result = await handler(args);
            this.logger.debug('Tool execution completed', { name });
            return {
                _meta: {},
                ...result
            };
        } catch (error) {
            this.logger.error('Tool execution failed', {
                tool: name,
                error
            });
            throw error;
        }
    }

    async getStorageMetrics(): Promise<any> {
        return await this.taskManager.storage.getMetrics();
    }

    private formatResponse(result: unknown): ToolResponse {
        try {
            const sanitizedResult = JSON.parse(JSON.stringify(result, (key, value) => {
                if (typeof value === 'bigint') {
                    return value.toString();
                }
                if (key.toLowerCase().includes('secret') || 
                    key.toLowerCase().includes('password') ||
                    key.toLowerCase().includes('token')) {
                    return undefined;
                }
                return value;
            }));

            return {
                content: [{
                    type: 'text',
                    text: JSON.stringify(sanitizedResult, null, 2)
                }]
            };
        } catch (error) {
            this.logger.error('Failed to format response', { error });
            throw createError(
                ErrorCodes.INTERNAL_ERROR,
                'Failed to format response'
            );
        }
    }
}

================
File: src/tools/index.ts
================
/**
 * Tools module exports
 * Centralizes exports for tools-related functionality
 */

export * from './handler.js';
export * from './schemas.js';
export * from './utils.js';

================
File: src/tools/schemas.ts
================
/**
 * Path-based task management schemas for LLM agents
 */
import { TaskStatus, CONSTRAINTS } from '../types/task.js';

// Schema validation messages
const VALIDATION_MESSAGES = {
    PATH_FORMAT: 'Path can only contain alphanumeric characters, underscores, dots, and hyphens',
    PATH_DEPTH: `Path depth cannot exceed ${CONSTRAINTS.MAX_PATH_DEPTH} levels`,
    NAME_LENGTH: `Name cannot exceed ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
    DESC_LENGTH: `Description cannot exceed ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
    NOTE_LENGTH: `Notes cannot exceed ${CONSTRAINTS.NOTE_MAX_LENGTH} characters each`,
    REASONING_LENGTH: `Reasoning cannot exceed ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
    DEPENDENCIES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_DEPENDENCIES} dependencies`,
    SUBTASKS_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_SUBTASKS} subtasks`,
    NOTES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_NOTES} notes`,
    METADATA_LENGTH: `Metadata string fields cannot exceed ${CONSTRAINTS.METADATA_STRING_MAX_LENGTH} characters`,
    METADATA_ARRAY: `Metadata arrays cannot exceed ${CONSTRAINTS.MAX_ARRAY_ITEMS} items`
};

/** Creates a new task with path-based hierarchy and validation */
export const createTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Hierarchical task path (e.g., "server/api/authentication"). Use paths to organize related tasks.\n' +
                        `Constraints:\n` +
                        `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                        `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
            pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
            maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50 // Reasonable max length per segment
        },
        name: {
            type: 'string',
            description: 'Clear, action-oriented task name (e.g., "Implement JWT authentication", "Refactor database queries").\n' +
                        `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.NAME_MAX_LENGTH
        },
        parentPath: {
            type: 'string',
            description: 'Path of the parent task. Parent must be MILESTONE or GROUP type.\n' +
                        'Examples:\n' +
                        '- "project/backend" (under project backend milestone)\n' +
                        '- "project/backend/auth" (under auth group)',
        },
        description: {
            type: 'string',
            description: 'Detailed task description including:\n' +
                        '- Objective: What needs to be accomplished\n' +
                        '- Context: Why this task is needed\n' +
                        '- Technical details: Implementation considerations\n' +
                        '- Success criteria: How to verify completion\n' +
                        `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
        },
        type: {
            type: 'string',
            enum: ['TASK', 'MILESTONE', 'GROUP'],
            description: '⚠️ Task Type Hierarchy Rules (MUST BE UPPERCASE):\n\n' +
                        '1. MILESTONE (Top Level Container):\n' +
                        '   • CAN contain: TASK and GROUP types\n' +
                        '   • Purpose: Project phases, major deliverables\n' +
                        '   • Example: "Backend Development", "Security Hardening"\n' +
                        '   • Status: Completed when all subtasks done\n\n' +
                        '2. GROUP (Middle Level Container):\n' +
                        '   • CAN contain: Only TASK types\n' +
                        '   • CANNOT contain: Other GROUPs or MILESTONEs\n' +
                        '   • Purpose: Feature sets, related task collections\n' +
                        '   • Example: "Authentication Features", "API Endpoints"\n' +
                        '   • Status: Reflects aggregate of subtask states\n\n' +
                        '3. TASK (Leaf Level):\n' +
                        '   • CANNOT contain any subtasks\n' +
                        '   • Purpose: Atomic units of work\n' +
                        '   • Example: "Implement JWT", "Add Rate Limiting"\n' +
                        '   • Status: Independently managed\n\n' +
                        'Common Errors to Avoid:\n' +
                        '- Adding subtasks to TASK type\n' +
                        '- Adding non-TASK items under GROUP\n' +
                        '- Creating circular dependencies\n' +
                        '- Exceeding path depth limits',
        },
        dependencies: {
            type: 'array',
            items: { 
                type: 'string',
                pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
            },
            maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
            description: 'Paths of tasks that must be completed first. Tasks will be automatically blocked if dependencies are not met.\n' +
                        `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                        'Dependencies can be specified here (recommended) or in metadata.dependencies (legacy).',
            uniqueItems: true
        },
        metadata: {
            type: 'object',
            properties: {
                priority: {
                    type: 'string',
                    enum: ['low', 'medium', 'high'],
                    description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                },
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                    description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                    uniqueItems: true
                },
                assignee: {
                    type: 'string',
                    description: 'System or component responsible for the task. Used for task distribution and filtering.'
                },
                reasoning: {
                    type: 'string',
                    description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                },
                notes: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                    },
                    maxItems: CONSTRAINTS.MAX_NOTES,
                    description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                }
            },
            description: 'Additional task context and tracking information. Fields affect:\n' +
                        '- Task organization (priority, tags, assignee)\n' +
                        '- Progress tracking (notes)\n' +
                        '- Decision history (reasoning)\n\n' +
                        'Note: dependencies in metadata.dependencies will be migrated to the main dependencies array.',
        }
    },
    required: ['name'],
};

/** Updates an existing task */
export const updateTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Path of the task to update.',
        },
        updates: {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Updated task name with current action focus.\n' +
                                `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.NAME_MAX_LENGTH
                },
                description: {
                    type: 'string',
                    description: 'Updated description with latest context, findings, and next steps.\n' +
                                `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
                },
                type: {
                    type: 'string',
                    enum: ['TASK', 'MILESTONE', 'GROUP'],
                    description: '⚠️ Task Type Rules (MUST BE UPPERCASE):\n' +
                                '- MILESTONE can contain TASK and GROUP\n' +
                                '- GROUP can only contain TASK\n' +
                                '- TASK cannot contain subtasks\n' +
                                'Changing type may require restructuring subtasks.',
                },
                status: {
                    type: 'string',
                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                    description: 'Current execution state:\n' +
                               '- PENDING: Not yet started\n' +
                               '- IN_PROGRESS: Currently being processed\n' +
                               '- COMPLETED: Successfully finished\n' +
                               '- FAILED: Encountered unresolvable issues\n' +
                               '- BLOCKED: Waiting on dependencies or external factors\n\n' +
                               'Status Propagation Rules:\n' +
                               '- MILESTONE: Completed when all subtasks done\n' +
                               '- GROUP: Status based on subtask states\n' +
                               '- TASK: Independent status management',
                },
                dependencies: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
                    },
                    maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
                    description: 'Updated task dependencies. Tasks will be automatically blocked if new dependencies are not met.\n' +
                                `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                                'Status changes propagate through dependency chain.',
                    uniqueItems: true
                },
                metadata: {
                    type: 'object',
                    properties: {
                        priority: {
                            type: 'string',
                            enum: ['low', 'medium', 'high'],
                            description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                        },
                        tags: {
                            type: 'array',
                            items: { type: 'string' },
                            maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                            description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                      `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                            uniqueItems: true
                        },
                        assignee: {
                            type: 'string',
                            description: 'Updated system/component assignment'
                        },
                        reasoning: {
                            type: 'string',
                            description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                      `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                            maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                        },
                        notes: {
                            type: 'array',
                            items: { 
                                type: 'string',
                                maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                            },
                            maxItems: CONSTRAINTS.MAX_NOTES,
                            description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                      `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                      `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                        }
                    },
                    description: 'Task metadata fields affect:\n' +
                                '- Task organization (priority, tags, assignee)\n' +
                                '- Progress tracking (notes)\n' +
                                '- Decision history (reasoning)',
                },
            },
            description: 'Fields to update. Available fields:\n' +
                        '- name: Update task name\n' +
                        '- description: Update task details\n' +
                        '- type: Change task type (task/milestone/group)\n' +
                        '- status: Update execution state with automatic dependency checks\n' +
                        '- dependencies: Add/remove dependencies with validation\n' +
                        '- metadata: Update task metadata (priority, tags, notes, etc.)\n\n' +
                        'Status changes trigger:\n' +
                        '- Automatic dependency validation\n' +
                        '- Status propagation to parent tasks\n' +
                        '- Dependent task blocking\n' +
                        '- Child task status updates',
        },
    },
    required: ['path', 'updates'],
};

/** Gets tasks by status */
export const getTasksByStatusSchema = {
    type: 'object',
    properties: {
        status: {
            type: 'string',
            enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'] as TaskStatus[],
            description: 'Filter tasks by their execution state. Use to find tasks needing attention or verify completion.',
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to filter by path (e.g., "server/api/*"). Use to focus on specific subsystems.',
        }
    },
    required: ['status'],
};

/** Gets tasks by path pattern */
export const getTasksByPathSchema = {
    type: 'object',
    properties: {
        pathPattern: {
            type: 'string',
            description: 'Glob pattern to match task paths. Use to analyze specific areas of work (e.g., "server/*/security/*").',
        }
    },
    required: ['pathPattern'],
};

/** Gets subtasks of a task */
export const getSubtasksSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Parent task path. Returns immediate subtasks to analyze task breakdown and progress.',
        }
    },
    required: ['path'],
};

/** Deletes a task */
export const deleteTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Task path to delete. Will recursively remove all subtasks. Use with caution.',
        }
    },
    required: ['path'],
};

/** Clears all tasks from the database */
export const clearAllTasksSchema = {
    type: 'object',
    properties: {
        confirm: {
            type: 'boolean',
            description: 'Must be set to true to confirm deletion of all tasks. This operation cannot be undone.',
        }
    },
    required: ['confirm'],
};

/** Optimizes database storage and performance */
export const vacuumDatabaseSchema = {
    type: 'object',
    properties: {
        analyze: {
            type: 'boolean',
            description: 'Whether to analyze tables for query optimization after vacuum.',
            default: true
        }
    },
    required: [],
};

/** Repairs parent-child relationships and fixes inconsistencies */
export const repairRelationshipsSchema = {
    type: 'object',
    properties: {
        dryRun: {
            type: 'boolean',
            description: 'If true, only reports issues without fixing them.',
            default: false
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to limit repair scope (e.g., "project/*").'
        }
    },
    required: [],
};

/** Bulk task operations with validation */
export const bulkTaskSchema = {
    type: 'object',
    properties: {
        operations: {
            type: 'array',
            description: 'Sequence of atomic task operations. Use for coordinated updates and maintaining task relationships.',
            items: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['create', 'update', 'delete'],
                        description: 'Operation type:\n' +
                                   '- create: Add new task with full context\n' +
                                   '- update: Modify task with latest findings\n' +
                                   '- delete: Remove completed or obsolete task'
                    },
                    path: {
                        type: 'string',
                        description: 'Task path for the operation. For create, this sets the desired hierarchy.\n' +
                                   `Constraints:\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
                        maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50
                    },
                    data: {
                        type: 'object',
                        description: 'Operation-specific data:\n' +
                                   '- create: Full task definition including dependencies and context\n' +
                                   '- update: Fields to modify including status and dependencies\n' +
                                   '- delete: Optional deletion context\n\n' +
                                   'Dependency handling:\n' +
                                   '- Dependencies are validated across all operations\n' +
                                   '- Status changes respect dependency constraints\n' +
                                   '- Circular dependencies are prevented\n' +
                                   '- Failed operations trigger rollback'
                    },
                },
                required: ['type', 'path'],
            },
        },
    },
    required: ['operations'],
};

================
File: src/tools/session-schemas.ts
================
/**
 * Session and Task List Management Schemas
 * Defines schemas for managing work sessions and task organization
 */

/** Creates a new task list in the current session. IMPORTANT: Requires an active session - use create_session first if you haven't already. Task lists organize related tasks and provide structure for task management. */
export const createTaskListSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the task list. Best practice: Use descriptive names that reflect the purpose or theme (e.g., "Q1 Feature Development", "Security Improvements").',
        },
        description: {
            type: 'string',
            description: 'Description of the task list. Best practice: Include goals, success criteria, and any relevant timelines or constraints.',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the task list. Best practice: Use consistent prefixes (e.g., "project:", "team:", "quarter:") for better organization.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the task list. Best practice: Include links to project documentation, milestones, or related resources.',
                }
            },
            description: 'Additional task list metadata. Best practice: Use for cross-referencing and organization.',
        },
        persistent: {
            type: 'boolean',
            description: 'Whether the task list should persist across sessions. Best practice: Use true for long-term projects, false for temporary task groupings.',
            default: true
        }
    },
    required: ['name'],
};

/** Switches to a different task list in the current session */
export const switchTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to switch to. Best practice: Verify task list exists and contains active tasks before switching.',
        }
    },
    required: ['taskListId'],
};

/** Lists all task lists in the current session */
export const listTaskListsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived task lists. Best practice: Use true when reviewing historical data or reactivating old projects.',
            default: false
        }
    }
};

/** Archives a task list */
export const archiveTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to archive. Best practice: Ensure all tasks are completed or properly transferred before archiving.',
        }
    },
    required: ['taskListId'],
};

/** Creates a new session. IMPORTANT: This must be called first before any task operations can be performed. A session provides the required context for managing tasks and task lists. */
export const createSessionSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the session. Best practice: Use descriptive names that include purpose and date (e.g., "Feature Development - March 2024").',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the session. Best practice: Include project phase, team, and priority indicators.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the session. Best practice: Document goals, participants, and key decisions made during the session.',
                }
            },
            description: 'Additional session metadata. Best practice: Use for tracking session objectives and outcomes.',
        }
    },
    required: ['name'],
};

/** Switches to a different session */
export const switchSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to switch to. Best practice: Save any pending changes in current session before switching.',
        }
    },
    required: ['sessionId'],
};

/** Lists all available sessions */
export const listSessionsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived sessions. Best practice: Use for auditing or reviewing historical work patterns.',
            default: false
        }
    }
};

/** Archives a session */
export const archiveSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to archive. Best practice: Document session outcomes and ensure all task lists are properly resolved before archiving.'
        }
    },
    required: ['sessionId']
};

/**
 * Best Practices for Session Management:
 * 
 * 1. Session Organization:
 *    - Create sessions for focused work periods or project phases
 *    - Use consistent naming conventions for better tracking
 *    - Document session goals and outcomes
 * 
 * 2. Task List Management:
 *    - Group related tasks into logical task lists
 *    - Keep task lists focused and manageable
 *    - Use metadata and tags for easy filtering
 * 
 * 3. Archiving Strategy:
 *    - Archive completed sessions with proper documentation
 *    - Ensure all tasks are resolved before archiving
 *    - Use archiving for maintaining clean workspace
 * 
 * 4. Metadata Usage:
 *    - Use consistent tag prefixes
 *    - Include relevant links and context
 *    - Track important decisions and rationale
 * 
 * 5. Session Switching:
 *    - Save work before switching sessions
 *    - Verify task list status when switching
 *    - Maintain context between sessions
 */

================
File: src/tools/utils.ts
================
/**
 * Utility functions for tool operations
 */

/**
 * Formats a response object for consistent output
 * @param response The response object to format
 * @returns Formatted response string
 */
export function formatResponse(response: unknown): string {
    return JSON.stringify(response, null, 2);
}

/**
 * Validates that required parameters are present in a request
 * @param params The parameters object to validate
 * @param required Array of required parameter names
 * @throws Error if any required parameter is missing
 */
export function validateRequiredParams(params: Record<string, unknown>, required: string[]): void {
    for (const param of required) {
        if (!(param in params)) {
            throw new Error(`Missing required parameter: ${param}`);
        }
    }
}

/**
 * Sanitizes a string for safe usage
 * @param input The string to sanitize
 * @returns Sanitized string
 */
export function sanitizeString(input: string): string {
    return input.trim();
}

/**
 * Validates string length is within limits
 * @param input The string to validate
 * @param maxLength Maximum allowed length
 * @param fieldName Name of the field for error message
 * @throws Error if string exceeds maximum length
 */
export function validateStringLength(input: string, maxLength: number, fieldName: string): void {
    if (input.length > maxLength) {
        throw new Error(`${fieldName} exceeds maximum length of ${maxLength} characters`);
    }
}

================
File: src/types/batch.ts
================
import { Task } from './task.js';

/**
 * Configuration for batch processing operations
 */
export interface BatchConfig {
    /** Maximum number of items per batch */
    batchSize: number;
    /** Maximum number of concurrent batch operations */
    concurrentBatches: number;
    /** Number of retry attempts for failed operations */
    retryCount: number;
    /** Delay between retry attempts in milliseconds */
    retryDelay: number;
}

/**
 * Result of a batch processing operation
 */
export interface BatchResult {
    /** Whether the batch operation was successful */
    success: boolean;
    /** Number of successfully processed items */
    processedCount: number;
    /** Number of failed items */
    failedCount: number;
    /** Detailed error information for failed items */
    errors: Array<BatchError>;
}

/**
 * Error information for a failed batch item
 */
export interface BatchError {
    /** The item that failed processing */
    item: unknown;
    /** The error that occurred */
    error: Error;
    /** Additional context about the failure */
    context?: BatchErrorContext;
}

/**
 * Context information for batch errors
 */
export interface BatchErrorContext {
    /** Size of the batch being processed */
    batchSize: number;
    /** Index of the current item in the batch */
    currentIndex: number;
    /** Number of items processed so far */
    processedCount: number;
    /** Reason for the failure */
    failureReason?: string;
    /** Additional context properties */
    [key: string]: unknown;
}

/**
 * Callbacks for tracking batch processing progress
 */
export interface BatchProgressCallback {
    /** Called when a batch starts processing */
    onBatchStart?: (batchIndex: number, totalBatches: number) => void;
    /** Called when a batch completes processing */
    onBatchComplete?: (batchIndex: number, result: BatchResult) => void;
    /** Called when an individual operation completes */
    onOperationComplete?: (itemIndex: number, totalItems: number) => void;
}

/**
 * Base interface for batch processors
 */
export interface BatchProcessor {
    processBatch<T>(
        batch: T[],
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
    
    processInBatches<T>(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
}

/**
 * Interface for items with dependencies
 */
export interface DependentItem {
    /** Unique identifier for the item */
    id?: string;
    /** Path-based identifier for the item */
    path?: string;
    /** Dependencies that must be processed before this item */
    dependencies?: string[];
}

/**
 * Extended batch result for task operations
 */
export interface TaskBatchResult extends BatchResult {
    /** Paths of tasks affected by the operation */
    affectedTasks: string[];
    /** ID of the transaction if applicable */
    transactionId?: string;
    /** Validation errors encountered */
    validationErrors?: Array<{
        path: string;
        error: Error;
    }>;
}

/**
 * Configuration for task batch operations
 */
export interface TaskBatchOperation {
    /** Type of operation to perform */
    type: 'add' | 'update' | 'remove';
    /** Tasks to process */
    tasks: Task[];
    /** Additional options for the operation */
    options?: {
        /** Skip validation checks */
        skipValidation?: boolean;
        /** Force update even if conditions aren't met */
        forceUpdate?: boolean;
        /** Continue processing despite errors */
        ignoreErrors?: boolean;
    };
}

/**
 * Status update operation for tasks
 */
export interface StatusUpdate {
    /** Path of the task to update */
    taskPath: string;
    /** New status to apply */
    newStatus: Task['status'];
}

================
File: src/types/config.ts
================
/**
 * Configuration types
 */
import { LogLevel } from '../types/logging.js';

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

export type Environment = typeof Environments[keyof typeof Environments];

/**
 * Environment configuration
 */
export interface EnvironmentConfig {
    /** Node environment */
    NODE_ENV: Environment;
    /** Log level */
    LOG_LEVEL: LogLevel;
    /** Task storage directory */
    TASK_STORAGE_DIR: string;
}

/**
 * Logging configuration
 */
export interface LoggingConfig {
    /** Log level */
    level: LogLevel;
    /** Enable console logging */
    console: boolean;
    /** Enable file logging */
    file: boolean;
    /** Log directory */
    dir?: string;
    /** Maximum log files */
    maxFiles: number;
    /** Maximum log file size */
    maxSize: number;
}

/**
 * Storage configuration
 */
export interface StorageConfig {
    /** Base directory */
    baseDir: string;
    /** Storage name */
    name: string;
    /** Connection settings */
    connection?: {
        /** Maximum retries */
        maxRetries?: number;
        /** Retry delay in milliseconds */
        retryDelay?: number;
        /** Busy timeout in milliseconds */
        busyTimeout?: number;
    };
    /** Performance settings */
    performance?: {
        /** WAL mode checkpoint interval */
        checkpointInterval?: number;
        /** Cache size in pages */
        cacheSize?: number;
        /** Memory map size */
        mmapSize?: number;
        /** Page size */
        pageSize?: number;
    };
}

/**
 * Application configuration
 */
export interface Config {
    /** Environment */
    env: Environment;
    /** Logging configuration */
    logging: LoggingConfig;
    /** Storage configuration */
    storage: StorageConfig;
}

================
File: src/types/error.ts
================
/**
 * Error-related type definitions
 */

/**
 * Error codes enumeration
 * @description Defines all possible error codes in the system
 */
export const ErrorCodes = {
    // Task-related errors
    TASK_NOT_FOUND: 'TASK_NOT_FOUND',
    TASK_VALIDATION: 'TASK_VALIDATION',
    TASK_DEPENDENCY: 'TASK_DEPENDENCY',
    TASK_STATUS: 'TASK_STATUS',
    TASK_DUPLICATE: 'TASK_DUPLICATE',
    TASK_INVALID_TYPE: 'TASK_INVALID_TYPE',
    TASK_INVALID_STATUS: 'TASK_INVALID_STATUS',
    TASK_INVALID_PARENT: 'TASK_INVALID_PARENT',
    TASK_OPERATION_FAILED: 'TASK_OPERATION_FAILED',
    
    // Storage-related errors
    STORAGE_READ: 'STORAGE_READ',
    STORAGE_WRITE: 'STORAGE_WRITE',
    STORAGE_INIT: 'STORAGE_INIT',
    STORAGE_DELETE: 'STORAGE_DELETE',
    STORAGE_PERMISSION: 'STORAGE_PERMISSION',
    STORAGE_NOT_FOUND: 'STORAGE_NOT_FOUND',
    STORAGE_TRANSACTION: 'STORAGE_TRANSACTION',
    STORAGE_ROLLBACK: 'STORAGE_ROLLBACK',
    STORAGE_COMMIT: 'STORAGE_COMMIT',
    
    // Configuration errors
    CONFIG_MISSING: 'CONFIG_MISSING',
    CONFIG_INVALID: 'CONFIG_INVALID',
    CONFIG_TYPE: 'CONFIG_TYPE',
    CONFIG_VALIDATION: 'CONFIG_VALIDATION',
    CONFIG_REQUIRED: 'CONFIG_REQUIRED',
    
    // Server errors
    SERVER_INIT: 'SERVER_INIT',
    SERVER_SHUTDOWN: 'SERVER_SHUTDOWN',
    SERVER_CONNECTION: 'SERVER_CONNECTION',
    SERVER_TIMEOUT: 'SERVER_TIMEOUT',
    SERVER_OVERLOAD: 'SERVER_OVERLOAD',
    
    // Tool-related errors
    TOOL_NOT_FOUND: 'TOOL_NOT_FOUND',
    TOOL_EXECUTION: 'TOOL_EXECUTION',
    TOOL_VALIDATION: 'TOOL_VALIDATION',
    TOOL_TIMEOUT: 'TOOL_TIMEOUT',
    TOOL_PERMISSION: 'TOOL_PERMISSION',
    
    // General errors
    INTERNAL_ERROR: 'INTERNAL_ERROR',
    INVALID_INPUT: 'INVALID_INPUT',
    OPERATION_FAILED: 'OPERATION_FAILED',
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    PERMISSION_DENIED: 'PERMISSION_DENIED',
    NOT_IMPLEMENTED: 'NOT_IMPLEMENTED',
    TIMEOUT: 'TIMEOUT'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

/**
 * Base error interface
 * @description Common properties for all errors
 */
export interface BaseError {
    /** Error name/type */
    name: string;
    /** Error message */
    message: string;
    /** Error code */
    code: ErrorCode;
    /** Error stack trace */
    stack?: string;
    /** Additional error details */
    details?: unknown;
}

/**
 * Error severity levels
 * @description Defines the severity of errors for logging and handling
 */
export const ErrorSeverity = {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
    FATAL: 'fatal'
} as const;

export type ErrorSeverityLevel = typeof ErrorSeverity[keyof typeof ErrorSeverity];

/**
 * Extended error interface with severity
 * @description Error interface with additional severity information
 */
export interface ExtendedError extends BaseError {
    /** Error severity level */
    severity: ErrorSeverityLevel;
    /** Timestamp when the error occurred */
    timestamp: string;
    /** Request ID associated with the error */
    requestId?: string;
    /** Session ID associated with the error */
    sessionId?: string;
    /** User ID associated with the error */
    userId?: string;
    /** Additional context about the error */
    context?: Record<string, unknown>;
}

/**
 * Error response interface
 * @description Standard error response format
 */
export interface ErrorResponse {
    /** Operation success status (always false for errors) */
    success: false;
    /** Error information */
    error: {
        /** Error code */
        code: ErrorCode;
        /** Error message */
        message: string;
        /** Additional error details */
        details?: unknown;
    };
    /** Response metadata */
    metadata?: {
        /** Operation timestamp */
        timestamp: string;
        /** Request identifier */
        requestId: string;
        /** Session identifier */
        sessionId: string;
    };
}

/**
 * Error handler options interface
 * @description Configuration options for error handling
 */
export interface ErrorHandlerOptions {
    /** Whether to include stack traces in errors */
    includeStack?: boolean;
    /** Default error severity level */
    defaultSeverity?: ErrorSeverityLevel;
    /** Whether to log errors automatically */
    autoLog?: boolean;
    /** Custom error transformers */
    transformers?: {
        [key: string]: (error: unknown) => ErrorResponse;
    };
}

/**
 * Error category mapping
 * @description Maps error codes to their categories for better organization
 */
export const ErrorCategories = {
    TASK: [
        ErrorCodes.TASK_NOT_FOUND,
        ErrorCodes.TASK_VALIDATION,
        ErrorCodes.TASK_DEPENDENCY,
        ErrorCodes.TASK_STATUS,
        ErrorCodes.TASK_DUPLICATE,
        ErrorCodes.TASK_INVALID_TYPE,
        ErrorCodes.TASK_INVALID_STATUS,
        ErrorCodes.TASK_INVALID_PARENT,
        ErrorCodes.TASK_OPERATION_FAILED
    ],
    STORAGE: [
        ErrorCodes.STORAGE_READ,
        ErrorCodes.STORAGE_WRITE,
        ErrorCodes.STORAGE_INIT,
        ErrorCodes.STORAGE_DELETE,
        ErrorCodes.STORAGE_PERMISSION,
        ErrorCodes.STORAGE_NOT_FOUND,
        ErrorCodes.STORAGE_TRANSACTION,
        ErrorCodes.STORAGE_ROLLBACK,
        ErrorCodes.STORAGE_COMMIT
    ],
    CONFIG: [
        ErrorCodes.CONFIG_MISSING,
        ErrorCodes.CONFIG_INVALID,
        ErrorCodes.CONFIG_TYPE,
        ErrorCodes.CONFIG_VALIDATION,
        ErrorCodes.CONFIG_REQUIRED
    ],
    SERVER: [
        ErrorCodes.SERVER_INIT,
        ErrorCodes.SERVER_SHUTDOWN,
        ErrorCodes.SERVER_CONNECTION,
        ErrorCodes.SERVER_TIMEOUT,
        ErrorCodes.SERVER_OVERLOAD
    ],
    TOOL: [
        ErrorCodes.TOOL_NOT_FOUND,
        ErrorCodes.TOOL_EXECUTION,
        ErrorCodes.TOOL_VALIDATION,
        ErrorCodes.TOOL_TIMEOUT,
        ErrorCodes.TOOL_PERMISSION
    ],
    GENERAL: [
        ErrorCodes.INTERNAL_ERROR,
        ErrorCodes.INVALID_INPUT,
        ErrorCodes.OPERATION_FAILED,
        ErrorCodes.VALIDATION_ERROR,
        ErrorCodes.PERMISSION_DENIED,
        ErrorCodes.NOT_IMPLEMENTED,
        ErrorCodes.TIMEOUT
    ]
} as const;

export type ErrorCategory = keyof typeof ErrorCategories;

/**
 * Error metadata interface
 * @description Additional metadata for error tracking and analysis
 */
export interface ErrorMetadata {
    /** Error category */
    category: ErrorCategory;
    /** Error severity */
    severity: ErrorSeverityLevel;
    /** Whether the error is retryable */
    retryable: boolean;
    /** Suggested recovery action */
    recovery?: string;
    /** Related documentation link */
    docs?: string;
    /** Additional metadata */
    [key: string]: unknown;
}

/**
 * Error mapping type
 * @description Maps error codes to their metadata
 */
export type ErrorMapping = {
    [K in ErrorCode]: ErrorMetadata;
};

================
File: src/types/index.ts
================
/**
 * Common type definitions
 */
export * from './indexing.js';

/**
 * Validation result interface
 */
export interface ValidationResult<T = unknown> {
    /** Whether validation succeeded */
    success: boolean;
    /** Validated data if successful */
    data?: T;
    /** Validation errors if failed */
    errors?: Array<{
        /** Field path */
        path: string[];
        /** Error message */
        message: string;
        /** Received value */
        received?: unknown;
        /** Expected type/value */
        expected?: string;
    }>;
}

/**
 * Utility type for making all properties optional recursively
 */
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Utility type for making all properties required recursively
 */
export type DeepRequired<T> = {
    [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

/**
 * Utility type for making all properties readonly recursively
 */
export type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

/**
 * Utility type for extracting keys of type from object
 */
export type KeysOfType<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

/**
 * Utility type for omitting properties by type
 */
export type OmitByType<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};

/**
 * Utility type for picking properties by type
 */
export type PickByType<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};

/**
 * Utility type for making properties mutable
 */
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

/**
 * Utility type for making properties immutable
 */
export type Immutable<T> = {
    readonly [P in keyof T]: T[P];
};

/**
 * Utility type for type predicate functions
 */
export type TypePredicate = (value: unknown) => boolean;

/**
 * Utility type for async functions
 */
export type AsyncFunction<T = void> = () => Promise<T>;

/**
 * Utility type for constructor functions
 */
export type Constructor<T = object> = new (...args: any[]) => T;

/**
 * Utility type for function parameters
 */
export type Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;

/**
 * Utility type for function return type
 */
export type ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never;

/**
 * Utility type for promise value type
 */
export type PromiseType<T extends Promise<any>> = T extends Promise<infer U> ? U : never;

/**
 * Utility type for array element type
 */
export type ArrayElement<T extends readonly any[]> = T extends readonly (infer U)[] ? U : never;

/**
 * Utility type for object values
 */
export type ObjectValues<T> = T[keyof T];

/**
 * Utility type for object keys
 */
export type ObjectKeys<T> = keyof T;

/**
 * Utility type for non-undefined values
 */
export type NonUndefined<T> = T extends undefined ? never : T;

/**
 * Utility type for non-null values
 */
export type NonNull<T> = T extends null ? never : T;

/**
 * Utility type for non-nullable values
 */
export type NonNullable<T> = T extends null | undefined ? never : T;

/**
 * Utility type for required keys
 */
export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

/**
 * Utility type for optional keys
 */
export type OptionalKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

================
File: src/types/indexing.ts
================
/**
 * Task indexing type definitions
 */

import { Task, TaskStatus } from './task.js';

/**
 * Task index structure
 */
export interface TaskIndex extends Task {
    path: string;
    status: TaskStatus;
    parentPath?: string;
    dependencies: string[];
    subtasks: string[];
}

/**
 * Index manager configuration
 */
export interface IndexConfig {
    batchSize: number;
    parallelOperations: boolean;
}

/**
 * Index operation result
 */
export interface IndexOperationResult {
    success: boolean;
    error?: Error;
}

/**
 * Index manager interface
 */
export interface IndexManager {
    /**
     * Indexes a task and its dependencies
     */
    indexTask(task: Task): Promise<void>;

    /**
     * Removes a task from all indexes
     */
    unindexTask(task: Task): Promise<void>;

    /**
     * Gets a task by its exact path
     */
    getTaskByPath(path: string): Promise<TaskIndex | null>;

    /**
     * Gets tasks by path pattern (supports * and ** wildcards)
     */
    getTasksByPattern(pattern: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by status with optional pattern filtering
     */
    getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by parent path
     */
    getTasksByParent(parentPath: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks that depend on a task
     */
    getDependentTasks(path: string): Promise<TaskIndex[]>;

    /**
     * Gets project tasks by pattern
     */
    getProjectTasks(pattern: string): Promise<TaskIndex[]>;

    /**
     * Clears all indexes
     */
    clear(): void;

    /**
     * Gets index statistics
     */
    getStats(): IndexStats;
}

/**
 * Index statistics
 */
export interface IndexStats {
    totalTasks: number;
    byStatus: Record<TaskStatus, number>;
    byDepth: Record<number, number>;
    averageDepth: number;
}

================
File: src/types/logging.ts
================
/**
 * Logging-related type definitions
 */

/**
 * Log levels enumeration
 * @description Defines the possible log levels using Winston's standard levels
 */
export const LogLevels = {
    ERROR: 'error',   // 0
    WARN: 'warn',     // 1
    INFO: 'info',     // 2
    HTTP: 'http',     // 3
    VERBOSE: 'verbose', // 4
    DEBUG: 'debug',   // 5
    SILLY: 'silly'    // 6
} as const;

export type LogLevel = typeof LogLevels[keyof typeof LogLevels];

/**
 * Log entry interface
 * @description Represents a single log entry
 */
export interface LogEntry {
    /** Log timestamp */
    timestamp: string;
    /** Log level */
    level: LogLevel;
    /** Log message */
    message: string;
    /** Additional context */
    context?: Record<string, unknown>;
    /** Error information if applicable */
    error?: {
        /** Error name */
        name: string;
        /** Error message */
        message: string;
        /** Error stack trace */
        stack?: string;
        /** Error code */
        code?: string;
        /** Additional error details */
        details?: unknown;
    };
}

/**
 * Logger configuration interface
 * @description Configuration options for the logger
 */
export interface LoggerConfig {
    /** Minimum log level to record */
    minLevel: LogLevel;
    /** Log directory path */
    logDir?: string;
    /** Whether to log to console */
    console?: boolean;
    /** Whether to log to file */
    file?: boolean;
    /** Maximum number of log files */
    maxFiles?: number;
    /** Maximum size of each log file in bytes */
    maxFileSize?: number;
    /** Whether to disable colored console output */
    noColors?: boolean;
}

/**
 * Log formatter interface
 * @description Interface for log formatters
 */
export interface LogFormatter {
    /** Format a log entry */
    format(entry: LogEntry): string;
}

/**
 * Log transport interface
 * @description Interface for log transports (console, file, etc.)
 */
export interface LogTransport {
    /** Write a log entry */
    write(entry: LogEntry): Promise<void>;
    /** Initialize the transport */
    initialize?(): Promise<void>;
    /** Close the transport */
    close?(): Promise<void>;
}

/**
 * Child logger context interface
 * @description Context for child loggers
 */
export interface ChildLoggerContext {
    /** Component name */
    component?: string;
    /** Request ID */
    requestId?: string;
    /** Session ID */
    sessionId?: string;
    /** User ID */
    userId?: string;
    /** Additional context */
    [key: string]: unknown;
}

/**
 * Logger interface
 * @description Interface for logger instances
 */
export interface Logger {
    /** Log at DEBUG level */
    debug(message: string, context?: Record<string, unknown>): void;
    /** Log at INFO level */
    info(message: string, context?: Record<string, unknown>): void;
    /** Log at WARN level */
    warn(message: string, context?: Record<string, unknown>): void;
    /** Log at ERROR level */
    error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Log at ERROR level (alias for error, maintains backward compatibility) */
    fatal(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Create a child logger with additional context */
    child(context: ChildLoggerContext): Logger;
    /** Initialize the logger */
    initialize(): Promise<void>;
}

/**
 * Log file info interface
 * @description Information about a log file
 */
export interface LogFileInfo {
    /** File name */
    name: string;
    /** File path */
    path: string;
    /** File size in bytes */
    size: number;
    /** Creation timestamp */
    created: string;
    /** Last modified timestamp */
    modified: string;
}

/**
 * Log rotation options interface
 * @description Options for log rotation
 */
export interface LogRotationOptions {
    /** Maximum file size in bytes */
    maxSize: number;
    /** Maximum number of files */
    maxFiles: number;
    /** Whether to compress old logs */
    compress?: boolean;
    /** Pattern for date in file names */
    datePattern?: string;
}

/**
 * Log query options interface
 * @description Options for querying logs
 */
export interface LogQueryOptions {
    /** Start timestamp */
    from?: string;
    /** End timestamp */
    to?: string;
    /** Log levels to include */
    levels?: LogLevel[];
    /** Search text */
    search?: string;
    /** Context filters */
    context?: Record<string, unknown>;
    /** Maximum number of entries */
    limit?: number;
    /** Number of entries to skip */
    offset?: number;
    /** Sort direction */
    order?: 'asc' | 'desc';
}

/**
 * Log query result interface
 * @description Result of a log query
 */
export interface LogQueryResult {
    /** Log entries */
    entries: LogEntry[];
    /** Total number of matching entries */
    total: number;
    /** Query metadata */
    metadata: {
        /** Query timestamp */
        timestamp: string;
        /** Query duration in milliseconds */
        duration: number;
        /** Applied filters */
        filters: Record<string, unknown>;
    };
}

================
File: src/types/project.ts
================
/**
 * Project-related type definitions
 */

/**
 * Project status enumeration
 */
export enum ProjectStatus {
    ACTIVE = 'active',
    ARCHIVED = 'archived',
    COMPLETED = 'completed'
}

/**
 * Project metadata interface
 */
export interface ProjectMetadata {
    created: number;
    updated: number;
    owner: string;
    tags?: string[];
    status: ProjectStatus;
    version: number;
    description?: string;
    category?: string;
    priority?: 'low' | 'medium' | 'high';
    dueDate?: number;
    customFields?: Record<string, unknown>;
}

/**
 * Project interface
 */
export interface Project {
    path: string;           // Unique project identifier (e.g., "auth-system")
    name: string;           // Display name
    description?: string;
    metadata: ProjectMetadata;
    rootTaskPaths: string[];  // Top-level task paths
}

/**
 * Project creation input
 */
export interface CreateProjectInput {
    path: string;
    name: string;
    description?: string;
    metadata?: {
        owner?: string;
        tags?: string[];
        category?: string;
        priority?: 'low' | 'medium' | 'high';
        dueDate?: number;
        customFields?: Record<string, unknown>;
    };
}

/**
 * Project update input
 */
export interface UpdateProjectInput {
    name?: string;
    description?: string;
    metadata?: Partial<Omit<ProjectMetadata, 'created' | 'updated' | 'version'>>;
}

/**
 * Project operation response
 */
export interface ProjectResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: unknown;
    };
    metadata?: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedTasks?: string[];
        transactionId?: string;
    };
}

/**
 * Project validation utilities
 */
export const PROJECT_PATH_REGEX = /^[a-z0-9][a-z0-9-]*[a-z0-9]$/;
export const MAX_PROJECT_PATH_LENGTH = 64;
export const MAX_PROJECT_NAME_LENGTH = 100;
export const MAX_PROJECT_DESCRIPTION_LENGTH = 1000;

export function validateProjectPath(path: string): boolean {
    return (
        PROJECT_PATH_REGEX.test(path) &&
        path.length <= MAX_PROJECT_PATH_LENGTH &&
        !path.includes('/')
    );
}

export function validateProjectName(name: string): boolean {
    return (
        name.trim().length > 0 &&
        name.length <= MAX_PROJECT_NAME_LENGTH
    );
}

export function validateProjectDescription(description?: string): boolean {
    return !description || description.length <= MAX_PROJECT_DESCRIPTION_LENGTH;
}

/**
 * Project error codes
 */
export enum ProjectErrorCode {
    INVALID_PATH = 'PROJECT_INVALID_PATH',
    INVALID_NAME = 'PROJECT_INVALID_NAME',
    INVALID_DESCRIPTION = 'PROJECT_INVALID_DESCRIPTION',
    DUPLICATE_PATH = 'PROJECT_DUPLICATE_PATH',
    NOT_FOUND = 'PROJECT_NOT_FOUND',
    ARCHIVED = 'PROJECT_ARCHIVED',
    INVALID_STATUS = 'PROJECT_INVALID_STATUS',
    INVALID_METADATA = 'PROJECT_INVALID_METADATA'
}

================
File: src/types/session.ts
================
/**
 * Session and Task List Types
 */

/**
 * Session metadata
 */
export interface SessionMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Session tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the session is archived */
    archived?: boolean;
}

/**
 * Session storage interface
 */
export interface SessionStorage {
    /** Initialize storage */
    initialize(): Promise<void>;
    /** Save session */
    saveSession(session: Session): Promise<void>;
    /** Load session by ID */
    loadSession(sessionId: string): Promise<Session>;
    /** Load all sessions */
    loadAllSessions(): Promise<Session[]>;
    /** Delete session */
    deleteSession(sessionId: string): Promise<void>;
    /** Save task list */
    saveTaskList(taskList: TaskList): Promise<void>;
    /** Load task list by ID */
    loadTaskList(taskListId: string): Promise<TaskList>;
    /** Load all task lists */
    loadAllTaskLists(): Promise<TaskList[]>;
    /** Delete task list */
    deleteTaskList(taskListId: string): Promise<void>;
    /** Save active state */
    saveActiveState(state: {
        activeSessionId?: string;
        activeTaskListId?: string;
    }): Promise<void>;
    /** Load active state */
    loadActiveState(): Promise<{
        activeSessionId?: string;
        activeTaskListId?: string;
    }>;
    /** Close storage */
    close(): Promise<void>;
}

/**
 * Session manager interface
 */
export interface SessionManager {
    /** Initialize manager */
    initialize(): Promise<void>;
    /** Create new session */
    createSession(input: CreateSessionInput): Promise<Session>;
    /** Get session by ID */
    getSession(sessionId: string): Promise<Session>;
    /** List all sessions */
    listSessions(includeArchived?: boolean): Promise<Session[]>;
    /** Archive session */
    archiveSession(sessionId: string): Promise<void>;
    /** Create task list */
    createTaskList(input: CreateTaskListInput): Promise<TaskList>;
    /** Get task list by ID */
    getTaskList(taskListId: string): Promise<TaskList>;
    /** List all task lists */
    listTaskLists(includeArchived?: boolean): Promise<TaskList[]>;
    /** Archive task list */
    archiveTaskList(taskListId: string): Promise<void>;
    /** Switch active session */
    switchSession(sessionId: string): Promise<void>;
    /** Switch active task list */
    switchTaskList(taskListId: string): Promise<void>;
    /** Get active session */
    getActiveSession(): Promise<Session | null>;
    /** Get active task list */
    getActiveTaskList(): Promise<TaskList | null>;
}

/**
 * Session entity
 */
export interface Session {
    /** Unique session ID */
    id: string;
    /** Session name */
    name: string;
    /** Session metadata */
    metadata: SessionMetadata;
    /** Active task list ID */
    activeTaskListId?: string;
    /** Task list IDs in this session */
    taskListIds: string[];
}

/**
 * Task list metadata
 */
export interface TaskListMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Task list tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the task list is archived */
    archived?: boolean;
    /** Whether the task list persists across sessions */
    persistent?: boolean;
}

/**
 * Task list entity
 */
export interface TaskList {
    /** Unique task list ID */
    id: string;
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata: TaskListMetadata;
    /** Root task IDs */
    rootTaskIds: string[];
}

/**
 * Session creation input
 */
export interface CreateSessionInput {
    /** Session name */
    name: string;
    /** Session metadata */
    metadata?: {
        /** Session tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
}

/**
 * Task list creation input
 */
export interface CreateTaskListInput {
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata?: {
        /** Task list tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
    /** Whether the task list should persist across sessions */
    persistent?: boolean;
}

/**
 * Session response wrapper
 */
export interface SessionResponse {
    /** Response data */
    data: Session;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Task list response wrapper
 */
export interface TaskListResponse {
    /** Response data */
    data: TaskList;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Session error codes
 */
export enum SessionErrorCode {
    /** Session not found */
    SESSION_NOT_FOUND = 'SESSION_NOT_FOUND',
    /** Session validation failed */
    SESSION_VALIDATION = 'SESSION_VALIDATION',
    /** Session already exists */
    SESSION_EXISTS = 'SESSION_EXISTS',
    /** Session limit exceeded */
    SESSION_LIMIT = 'SESSION_LIMIT',
    /** Invalid session operation */
    SESSION_INVALID_OP = 'SESSION_INVALID_OP'
}

/**
 * Task list error codes
 */
export enum TaskListErrorCode {
    /** Task list not found */
    TASK_LIST_NOT_FOUND = 'TASK_LIST_NOT_FOUND',
    /** Task list validation failed */
    TASK_LIST_VALIDATION = 'TASK_LIST_VALIDATION',
    /** Task list already exists */
    TASK_LIST_EXISTS = 'TASK_LIST_EXISTS',
    /** Task list limit exceeded */
    TASK_LIST_LIMIT = 'TASK_LIST_LIMIT',
    /** Invalid task list operation */
    TASK_LIST_INVALID_OP = 'TASK_LIST_INVALID_OP'
}

================
File: src/types/storage.ts
================
/**
 * Path-based task storage types
 */
import { Task, TaskStatus } from './task.js';

/**
 * Storage configuration
 */
export interface StorageConfig {
    /** Base directory for storage */
    baseDir: string;
    /** Storage name */
    name: string;
    /** Connection settings */
    connection?: {
        /** Maximum retries for operations */
        maxRetries?: number;
        /** Retry delay in milliseconds */
        retryDelay?: number;
        /** Busy timeout in milliseconds */
        busyTimeout?: number;
    };
    /** Performance settings */
    performance?: {
        /** WAL mode checkpoint interval */
        checkpointInterval?: number;
        /** Cache size in pages */
        cacheSize?: number;
        /** Memory map size */
        mmapSize?: number;
        /** Page size */
        pageSize?: number;
        /** Maximum memory usage in bytes */
        maxMemory?: number;
        /** Maximum cache memory usage in bytes */
        maxCacheMemory?: number;
    };
}

/**
 * Storage interface for task operations
 */
/**
 * Cache management interface
 */
export interface CacheManager {
    clearCache(): Promise<void>;
    getCacheStats(): Promise<CacheStats>;
}

/**
 * Cache statistics
 */
export interface CacheStats {
    size: number;
    hitRate: number;
    memoryUsage: number;
}

/**
 * Storage interface for task operations with cache management
 */
export interface TaskStorage extends CacheManager {
    // Lifecycle
    initialize(): Promise<void>;
    close(): Promise<void>;
    
    // Transaction management
    beginTransaction(): Promise<void>;
    commitTransaction(): Promise<void>;
    rollbackTransaction(): Promise<void>;
    
    // Task operations
    saveTask(task: Task): Promise<void>;
    saveTasks(tasks: Task[]): Promise<void>;
    getTask(path: string): Promise<Task | null>;
    getTasks(paths: string[]): Promise<Task[]>;
    getTasksByPattern(pattern: string): Promise<Task[]>;
    getTasksByStatus(status: TaskStatus): Promise<Task[]>;
    getSubtasks(parentPath: string): Promise<Task[]>;
    deleteTask(path: string): Promise<void>;
    deleteTasks(paths: string[]): Promise<void>;
    
    // Maintenance
    vacuum(): Promise<void>;
    analyze(): Promise<void>;
    checkpoint(): Promise<void>;
    getMetrics(): Promise<StorageMetrics & {
        cache?: CacheStats;
        memory?: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
    }>;
    clearAllTasks(): Promise<void>;
    repairRelationships(dryRun?: boolean): Promise<{ fixed: number, issues: string[] }>;
}

/**
 * Storage metrics
 */
/**
 * Storage metrics with memory usage
 */
export interface StorageMetrics {
    /** Task metrics */
    tasks: {
        /** Total number of tasks */
        total: number;
        /** Tasks by status */
        byStatus: Record<string, number>;
        /** Number of task notes */
        noteCount: number;
        /** Number of task dependencies */
        dependencyCount: number;
        /** Path depth metrics */
        pathMetrics?: {
            /** Average path depth */
            averageDepth: number;
            /** Maximum path depth */
            maxDepth: number;
            /** Tasks by depth level */
            byDepth: Record<number, number>;
        };
    };
    /** Storage metrics */
    storage: {
        /** Total storage size in bytes */
        totalSize: number;
        /** WAL file size in bytes */
        walSize: number;
        /** Database page size */
        pageSize: number;
        /** Number of database pages */
        pageCount: number;
        /** Cache metrics */
        cache?: {
            /** Cache hit rate */
            hitRate: number;
            /** Cache memory usage */
            memoryUsage: number;
            /** Cache entry count */
            entryCount: number;
        };
    };
}

/**
 * Storage error types
 */
export enum StorageErrorType {
    INITIALIZATION = 'STORAGE_INIT',
    CONNECTION = 'CONNECTION',
    QUERY = 'QUERY',
    TRANSACTION = 'TRANSACTION',
    CONSTRAINT = 'CONSTRAINT',
    MAINTENANCE = 'MAINTENANCE',
    IO = 'IO'
}

/**
 * Storage error class
 */
export class StorageError extends Error {
    constructor(
        public readonly type: StorageErrorType,
        message: string,
        public readonly cause?: unknown
    ) {
        super(message);
        this.name = 'StorageError';
    }

    /**
     * Creates a storage error with appropriate type based on the error
     */
    static from(error: unknown, operation: string): StorageError {
        if (error instanceof StorageError) {
            return error;
        }

        const message = error instanceof Error ? error.message : String(error);

        // Determine error type from message/operation
        if (message.includes('SQLITE_BUSY') || message.includes('SQLITE_LOCKED')) {
            return new StorageError(
                StorageErrorType.CONNECTION,
                `Database busy during ${operation}: ${message}`,
                error
            );
        }

        if (message.includes('SQLITE_CONSTRAINT')) {
            return new StorageError(
                StorageErrorType.CONSTRAINT,
                `Constraint violation during ${operation}: ${message}`,
                error
            );
        }

        if (message.includes('SQLITE_IOERR')) {
            return new StorageError(
                StorageErrorType.IO,
                `I/O error during ${operation}: ${message}`,
                error
            );
        }

        return new StorageError(
            StorageErrorType.QUERY,
            `Error during ${operation}: ${message}`,
            error
        );
    }
}

/**
 * Storage transaction interface
 */
export interface Transaction {
    execute<T>(operation: () => Promise<T>): Promise<T>;
    commit(): Promise<void>;
    rollback(): Promise<void>;
}

/**
 * Storage transaction options
 */
export interface TransactionOptions {
    /** Maximum retries for the transaction */
    maxRetries?: number;
    /** Delay between retries in milliseconds */
    retryDelay?: number;
    /** Transaction timeout in milliseconds */
    timeout?: number;
}

================
File: src/types/task.ts
================
/**
 * Task type definitions
 */

export enum TaskType {
    TASK = 'TASK',
    MILESTONE = 'MILESTONE',
    GROUP = 'GROUP'
}

export enum TaskStatus {
    PENDING = 'PENDING',
    IN_PROGRESS = 'IN_PROGRESS',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    BLOCKED = 'BLOCKED'
}

export interface TaskMetadata {
    priority?: 'low' | 'medium' | 'high';
    tags?: string[];
    reasoning?: string;  // LLM's reasoning about task decisions
    toolsUsed?: string[];  // Tools used by LLM to accomplish task
    resourcesAccessed?: string[];  // Resources accessed by LLM
    contextUsed?: string[];  // Key context pieces used in decision making
    created: number;
    updated: number;
    projectPath: string;
    version: number;
    [key: string]: unknown;
}

export interface Task {
    path: string;  // Max depth of 8 levels
    name: string;  // Max 200 chars
    description?: string;  // Max 2000 chars
    type: TaskType;
    status: TaskStatus;
    parentPath?: string;
    notes?: string[];  // Each note max 1000 chars
    reasoning?: string;  // Max 2000 chars - LLM's reasoning about the task
    dependencies: string[];  // Max 50 dependencies
    subtasks: string[];  // Max 100 subtasks
    metadata: TaskMetadata;  // Each string field max 1000 chars, arrays max 100 items
}

export interface CreateTaskInput extends Record<string, unknown> {
    path?: string;
    name: string;
    parentPath?: string;
    description?: string;
    type?: TaskType;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface UpdateTaskInput extends Record<string, unknown> {
    name?: string;
    description?: string;
    type?: TaskType;
    status?: TaskStatus;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface TaskResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
    };
    metadata: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedPaths: string[];
    };
}

// Field length constraints
export const CONSTRAINTS = {
    NAME_MAX_LENGTH: 200,
    DESCRIPTION_MAX_LENGTH: 2000,
    NOTE_MAX_LENGTH: 1000,
    REASONING_MAX_LENGTH: 2000,
    METADATA_STRING_MAX_LENGTH: 1000,
    MAX_DEPENDENCIES: 50,
    MAX_SUBTASKS: 100,
    MAX_NOTES: 100,
    MAX_ARRAY_ITEMS: 100,
    MAX_PATH_DEPTH: 8
} as const;

/**
 * Validates a task path format and depth
 */
export function validateTaskPath(path: string): { valid: boolean; error?: string } {
    // Path must be non-empty
    if (!path) {
        return { valid: false, error: 'Path cannot be empty' };
    }

    // Path must contain only allowed characters
    if (!path.match(/^[a-zA-Z0-9_.-]+(?:\/[a-zA-Z0-9_.-]+)*$/)) {
        return { 
            valid: false, 
            error: 'Path can only contain alphanumeric characters, underscores, dots, and hyphens' 
        };
    }
    
    // Check path depth
    if (path.split('/').length > CONSTRAINTS.MAX_PATH_DEPTH) {
        return { 
            valid: false, 
            error: `Path depth cannot exceed ${CONSTRAINTS.MAX_PATH_DEPTH} levels` 
        };
    }

    return { valid: true };
}

/**
 * Validates field length constraints
 */
export function validateFieldLength(
    field: string | undefined,
    maxLength: number,
    fieldName: string
): { valid: boolean; error?: string } {
    if (!field) return { valid: true };
    
    if (field.length > maxLength) {
        return {
            valid: false,
            error: `${fieldName} length cannot exceed ${maxLength} characters`
        };
    }
    
    return { valid: true };
}

/**
 * Validates array size constraints
 */
export function validateArraySize<T>(
    array: T[] | undefined,
    maxSize: number,
    arrayName: string
): { valid: boolean; error?: string } {
    if (!array) return { valid: true };
    
    if (array.length > maxSize) {
        return {
            valid: false,
            error: `${arrayName} cannot contain more than ${maxSize} items`
        };
    }
    
    return { valid: true };
}

/**
 * Validates a complete task
 */
export function validateTask(task: Task): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate path
    const pathValidation = validateTaskPath(task.path);
    if (!pathValidation.valid && pathValidation.error) {
        errors.push(pathValidation.error);
    }

    // Validate field lengths
    const fieldValidations = [
        validateFieldLength(task.name, CONSTRAINTS.NAME_MAX_LENGTH, 'Name'),
        validateFieldLength(task.description, CONSTRAINTS.DESCRIPTION_MAX_LENGTH, 'Description'),
        validateFieldLength(task.reasoning, CONSTRAINTS.REASONING_MAX_LENGTH, 'Reasoning')
    ];

    fieldValidations.forEach(validation => {
        if (!validation.valid && validation.error) {
            errors.push(validation.error);
        }
    });

    // Validate array sizes
    const arrayValidations = [
        validateArraySize(task.dependencies, CONSTRAINTS.MAX_DEPENDENCIES, 'Dependencies'),
        validateArraySize(task.subtasks, CONSTRAINTS.MAX_SUBTASKS, 'Subtasks'),
        validateArraySize(task.notes, CONSTRAINTS.MAX_NOTES, 'Notes')
    ];

    arrayValidations.forEach(validation => {
        if (!validation.valid && validation.error) {
            errors.push(validation.error);
        }
    });

    // Validate notes length
    task.notes?.forEach((note, index) => {
        const noteValidation = validateFieldLength(note, CONSTRAINTS.NOTE_MAX_LENGTH, `Note ${index + 1}`);
        if (!noteValidation.valid && noteValidation.error) {
            errors.push(noteValidation.error);
        }
    });

    // Validate metadata
    if (task.metadata) {
        Object.entries(task.metadata).forEach(([key, value]) => {
            if (typeof value === 'string' && value.length > CONSTRAINTS.METADATA_STRING_MAX_LENGTH) {
                errors.push(`Metadata field '${key}' exceeds maximum length of ${CONSTRAINTS.METADATA_STRING_MAX_LENGTH} characters`);
            }
            if (Array.isArray(value) && value.length > CONSTRAINTS.MAX_ARRAY_ITEMS) {
                errors.push(`Metadata array '${key}' exceeds maximum size of ${CONSTRAINTS.MAX_ARRAY_ITEMS} items`);
            }
        });
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Validates parent-child task type relationships
 */
export function isValidTaskHierarchy(parentType: TaskType, childType: TaskType): { valid: boolean; reason?: string } {
    switch (parentType) {
        case TaskType.MILESTONE:
            // Milestones can contain tasks and groups
            return {
                valid: childType === TaskType.TASK || childType === TaskType.GROUP,
                reason: childType !== TaskType.TASK && childType !== TaskType.GROUP ?
                    `MILESTONE can only contain TASK or GROUP types, not ${childType}` : undefined
            };
        case TaskType.GROUP:
            // Groups can contain tasks
            return {
                valid: childType === TaskType.TASK,
                reason: childType !== TaskType.TASK ?
                    `GROUP can only contain TASK type, not ${childType}` : undefined
            };
        case TaskType.TASK:
            // Tasks cannot contain other tasks
            return {
                valid: false,
                reason: `TASK type cannot contain any subtasks (attempted to add ${childType})`
            };
        default:
            return {
                valid: false,
                reason: `Unknown task type: ${parentType}`
            };
    }
}

/**
 * Gets the task name from a path
 */
export function getTaskName(path: string): string {
    const segments = path.split('/');
    return segments[segments.length - 1];
}

/**
 * Gets the parent path from a task path
 */
export function getParentPath(path: string): string | undefined {
    const segments = path.split('/');
    return segments.length > 1 ? segments.slice(0, -1).join('/') : undefined;
}

================
File: src/utils/id-generator.ts
================
/**
 * ID Generator Utility
 * Generates short, unique identifiers for tasks, sessions, and other entities
 * 
 * Using 8 characters from a 62-character alphabet (a-z, A-Z, 0-9) gives:
 * - 62^8 = 218,340,105,584,896 possible combinations
 * - Collision probability of ~0.1% after 13.5 million IDs (birthday problem)
 * - At 1000 IDs/second, would take ~6.9 years to have a 1% collision probability
 */

import { customAlphabet } from 'nanoid';

// Constants
const ID_LENGTH = 8;
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

// Sequence counters for readable IDs
let sessionCounter = 1;
let taskCounter = 1;

// Create ID generator with specified alphabet and length
const generateId = customAlphabet(ALPHABET, ID_LENGTH);

/**
 * Generates a readable session ID
 * Format: session-XXX where XXX is a sequential number
 */
export function generateSessionId(): string {
    const id = `session-${sessionCounter.toString().padStart(3, '0')}`;
    sessionCounter++;
    return id;
}

/**
 * Generates a readable task ID
 * Format: task-XXX where XXX is a sequential number
 */
export function generateTaskId(): string {
    const id = `task-${taskCounter.toString().padStart(3, '0')}`;
    taskCounter++;
    return id;
}

/**
 * Generates a short, unique identifier (for other entities)
 * Format: 8 characters using [0-9A-Za-z]
 * Example: "xK7cPq2Z"
 */
export function generateShortId(): string {
    return generateId();
}

/**
 * Validates if a string matches any of the valid ID formats
 */
export function isValidShortId(value: string): boolean {
    if (!value) return false;
    return new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`).test(value);
}

/**
 * Generates a deterministic ID for testing/development
 * @param prefix - Optional 2-character prefix
 * @param sequence - Sequence number (0-999999)
 */
export function generateTestId(prefix = 'ts', sequence = 0): string {
    const seq = sequence.toString().padStart(6, '0');
    return `${prefix}${seq}`.slice(0, ID_LENGTH);
}

// Export constants for use in validation schemas
export const ID_CONSTANTS = {
    LENGTH: ID_LENGTH,
    ALPHABET,
    PATTERN: new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`)
} as const;

================
File: src/utils/pattern-matcher.ts
================
/**
 * Pattern matching utilities for task paths
 */

/**
 * Converts a glob pattern to a regular expression
 * Supports:
 * - * for single level matching
 * - ** for recursive matching
 * - ? for single character matching
 */
export function globToRegex(pattern: string): RegExp {
    const escapedPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
        .replace(/\*\*/g, '{{RECURSIVE}}') // Temp placeholder for **
        .replace(/\*/g, '[^/]+') // * matches anything except /
        .replace(/\?/g, '.') // ? matches single char
        .replace(/{{RECURSIVE}}/g, '.*'); // ** matches anything including /

    return new RegExp(`^${escapedPattern}$`);
}

/**
 * Converts a glob pattern to an SQL LIKE/GLOB pattern
 */
export function globToSqlPattern(pattern: string): string {
    return pattern
        .replace(/\*\*/g, '%') // ** for recursive match
        .replace(/\*/g, '%') // * for single level match
        .replace(/\?/g, '_'); // ? for single character
}

/**
 * Generates all possible glob patterns for a given path
 * Example: "a/b/c" generates:
 * - "a/b/c"
 * - "a/b/*"
 * - "a/*\/c"
 * - "a/**"
 * - "*\/b/c"
 * - etc.
 */
export function generatePathPatterns(path: string): string[] {
    const segments = path.split('/');
    const patterns: Set<string> = new Set();

    // Add exact path
    patterns.add(path);

    // Add single wildcard patterns
    for (let i = 0; i < segments.length; i++) {
        const pattern = [
            ...segments.slice(0, i),
            '*',
            ...segments.slice(i + 1)
        ].join('/');
        patterns.add(pattern);
    }

    // Add recursive patterns
    for (let i = 0; i < segments.length - 1; i++) {
        const pattern = [...segments.slice(0, i), '**'].join('/');
        patterns.add(pattern);
    }

    // Add combinations of * and **
    for (let i = 0; i < segments.length - 1; i++) {
        for (let j = i + 1; j < segments.length; j++) {
            const pattern = [
                ...segments.slice(0, i),
                '*',
                ...segments.slice(i + 1, j),
                '**'
            ].join('/');
            patterns.add(pattern);
        }
    }

    return Array.from(patterns);
}

/**
 * Tests if a path matches a glob pattern
 */
export function matchesPattern(path: string, pattern: string): boolean {
    return globToRegex(pattern).test(path);
}

================
File: src/validation/config.ts
================
/**
 * Configuration validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';
import { Environments } from '../types/config.js';

/**
 * Environment variables validation schema
 */
export const envVarsSchema = z.object({
    NODE_ENV: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]).optional(),
    LOG_LEVEL: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]).optional(),
    TASK_STORAGE_DIR: z.string().optional()
});

/**
 * Logging configuration validation schema
 */
export const loggingConfigSchema = z.object({
    level: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    dir: z.string().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Storage connection configuration validation schema
 */
export const storageConnectionConfigSchema = z.object({
    maxRetries: z.number().int().positive().optional(),
    retryDelay: z.number().int().nonnegative().optional(),
    busyTimeout: z.number().int().nonnegative().optional()
});

/**
 * Storage performance configuration validation schema
 */
export const storagePerformanceConfigSchema = z.object({
    checkpointInterval: z.number().int().nonnegative().optional(),
    cacheSize: z.number().int().nonnegative().optional(),
    mmapSize: z.number().int().nonnegative().optional(),
    pageSize: z.number().int().nonnegative().optional()
});

/**
 * Storage configuration validation schema
 */
export const storageConfigSchema = z.object({
    baseDir: z.string(),
    name: z.string(),
    connection: storageConnectionConfigSchema.optional(),
    performance: storagePerformanceConfigSchema.optional()
});

/**
 * Complete configuration validation schema
 */
export const configSchema = z.object({
    env: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]),
    logging: loggingConfigSchema,
    storage: storageConfigSchema
});

================
File: src/validation/id-schema.ts
================
/**
 * Shared ID validation schemas using the new short ID format
 */

import { z } from 'zod';
import { ID_CONSTANTS } from '../utils/id-generator.js';

// Legacy UUID pattern
const UUID_PATTERN = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

// Base ID schema for reuse across different entity types
export const baseIdSchema = z.string().regex(
    ID_CONSTANTS.PATTERN,
    `Task/Entity ID must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. Example: "xK7cPq2Z". You cannot use descriptive names like "Project Setup" as IDs.`
);

// Helper function to validate ID format
export function validateIdFormat(id: string, context: string = 'ID'): void {
    if (!ID_CONSTANTS.PATTERN.test(id)) {
        throw new Error(
            `Invalid ${context}: Must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. ` +
            `Received: "${id}". Example valid ID: "xK7cPq2Z"`
        );
    }
}

// Transitional schema that accepts both short IDs and UUIDs
export const transitionalIdSchema = z.string().refine(
    (val) => ID_CONSTANTS.PATTERN.test(val) || UUID_PATTERN.test(val),
    `ID must be either ${ID_CONSTANTS.LENGTH} characters long containing only [${ID_CONSTANTS.ALPHABET}] or a valid UUID`
);

// Specific entity ID schemas with custom error messages
export const taskIdSchema = baseIdSchema.describe('Task ID');
export const sessionIdSchema = transitionalIdSchema.describe('Session ID');
export const taskListIdSchema = baseIdSchema.describe('Task List ID');

// Array of IDs schema for dependencies, subtasks, etc.
export const idArraySchema = z.array(baseIdSchema);

// Optional ID schema for nullable fields
export const optionalIdSchema = baseIdSchema.optional();

// Example usage in a task schema:
export const taskReferenceSchema = z.object({
    id: taskIdSchema,
    parentId: optionalIdSchema,
    dependencies: idArraySchema.default([]),
    subtasks: idArraySchema.default([])
});

// Example usage in a session schema:
export const sessionReferenceSchema = z.object({
    id: sessionIdSchema,
    activeTaskListId: optionalIdSchema,
    taskListIds: idArraySchema.default([])
});

// Export types for use in other modules
export type TaskReference = z.infer<typeof taskReferenceSchema>;
export type SessionReference = z.infer<typeof sessionReferenceSchema>;

================
File: src/validation/index.ts
================
/**
 * Validation module exports
 * Provides a centralized point for all validation functionality
 */

export * from './task.js';
export * from './config.js';
export * from './logging.js';

import { z } from 'zod';
import { ValidationResult } from '../types/index.js';

/**
 * Convert Zod validation error to ValidationResult format
 */
export function formatZodError(error: z.ZodError): ValidationResult {
    return {
        success: false,
        errors: error.errors.map(err => ({
            path: err.path.map(String),
            message: err.message,
            received: err instanceof z.ZodError ? err.code : undefined,
            expected: getExpectedValue(err)
        }))
    };
}

/**
 * Get expected value from Zod error
 */
function getExpectedValue(error: z.ZodIssue): string | undefined {
    switch (error.code) {
        case z.ZodIssueCode.invalid_type:
            return error.expected;
        case z.ZodIssueCode.invalid_enum_value:
            return error.options.join(' | ');
        case z.ZodIssueCode.too_small:
            return `${error.type === 'string' ? 'length' : 'value'} >= ${error.minimum}`;
        case z.ZodIssueCode.too_big:
            return `${error.type === 'string' ? 'length' : 'value'} <= ${error.maximum}`;
        default:
            return undefined;
    }
}

/**
 * Create a safe validator function that returns ValidationResult
 */
export function createSafeValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): ValidationResult & { value?: T } => {
        const result = schema.safeParse(value);
        if (result.success) {
            return {
                success: true,
                data: result.data
            };
        } else {
            return formatZodError(result.error);
        }
    };
}

/**
 * Create a validator function that throws on invalid input
 */
export function createValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): T => schema.parse(value);
}

/**
 * Validation error messages
 */
export const ValidationErrorMessages = {
    INVALID_INPUT: 'Invalid input provided',
    VALIDATION_FAILED: 'Validation failed',
    TYPE_ERROR: 'Type validation failed',
    CONSTRAINT_ERROR: 'Constraint validation failed',
    REQUIRED_FIELD: 'Required field is missing',
    INVALID_FORMAT: 'Invalid format',
    INVALID_VALUE: 'Invalid value provided',
    OUT_OF_RANGE: 'Value is out of allowed range',
    PATTERN_MISMATCH: 'Value does not match required pattern',
    UNIQUE_VIOLATION: 'Value must be unique',
    REFERENCE_ERROR: 'Invalid reference',
    CUSTOM_ERROR: 'Custom validation failed'
} as const;

/**
 * Validation utilities
 */
export const ValidationUtils = {
    /**
     * Check if a value is defined (not null or undefined)
     */
    isDefined: <T>(value: T | null | undefined): value is T => {
        return value !== null && value !== undefined;
    },

    /**
     * Check if a value is a non-empty string
     */
    isNonEmptyString: (value: unknown): value is string => {
        return typeof value === 'string' && value.trim().length > 0;
    },

    /**
     * Check if a value is a valid number
     */
    isValidNumber: (value: unknown): value is number => {
        return typeof value === 'number' && !isNaN(value) && isFinite(value);
    },

    /**
     * Check if a value is a valid integer
     */
    isValidInteger: (value: unknown): value is number => {
        return ValidationUtils.isValidNumber(value) && Number.isInteger(value);
    },

    /**
     * Check if a value is a valid date string
     */
    isValidDateString: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const date = new Date(value);
        return !isNaN(date.getTime());
    },

    /**
     * Check if a value is a valid UUID
     */
    isValidUUID: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(value);
    },

    /**
     * Check if a value is a valid email
     */
    isValidEmail: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(value);
    },

    /**
     * Check if a value is a valid URL
     */
    isValidURL: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        try {
            new URL(value);
            return true;
        } catch {
            return false;
        }
    },

    /**
     * Check if an array contains only unique values
     */
    hasUniqueValues: <T>(array: T[]): boolean => {
        return new Set(array).size === array.length;
    },

    /**
     * Check if an object has all required properties
     */
    hasRequiredProperties: (obj: unknown, properties: string[]): boolean => {
        if (typeof obj !== 'object' || obj === null) return false;
        return properties.every(prop => prop in obj);
    }
} as const;

================
File: src/validation/logging.ts
================
/**
 * Logging validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';

/**
 * Log level validation schema
 */
export const logLevelSchema = z.enum([
    LogLevels.ERROR,
    LogLevels.WARN,
    LogLevels.INFO,
    LogLevels.HTTP,
    LogLevels.VERBOSE,
    LogLevels.DEBUG,
    LogLevels.SILLY
]);

/**
 * Log entry validation schema
 */
export const logEntrySchema = z.object({
    timestamp: z.string(),
    level: logLevelSchema,
    message: z.string(),
    context: z.record(z.unknown()).optional(),
    error: z.object({
        name: z.string(),
        message: z.string(),
        stack: z.string().optional(),
        code: z.string().optional(),
        details: z.unknown().optional()
    }).optional()
});

/**
 * Logger configuration validation schema
 */
export const loggerConfigSchema = z.object({
    minLevel: logLevelSchema,
    logDir: z.string().optional(),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxFileSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Log query options validation schema
 */
export const logQueryOptionsSchema = z.object({
    from: z.string().optional(),
    to: z.string().optional(),
    levels: z.array(logLevelSchema).optional(),
    search: z.string().optional(),
    context: z.record(z.unknown()).optional(),
    limit: z.number().int().positive().optional(),
    offset: z.number().int().nonnegative().optional(),
    order: z.enum(['asc', 'desc']).optional()
});

/**
 * Log rotation options validation schema
 */
export const logRotationOptionsSchema = z.object({
    maxSize: z.number().int().positive(),
    maxFiles: z.number().int().positive(),
    compress: z.boolean().optional(),
    datePattern: z.string().optional()
});

/**
 * Log file info validation schema
 */
export const logFileInfoSchema = z.object({
    name: z.string(),
    path: z.string(),
    size: z.number().int().nonnegative(),
    created: z.string(),
    modified: z.string()
});

================
File: src/validation/task.ts
================
/**
 * Task validation module
 */
import { z } from 'zod';
import { TaskType, TaskStatus } from '../types/task.js';

// Task metadata schema
const taskMetadataSchema = z.object({
    priority: z.enum(['low', 'medium', 'high']).optional(),
    tags: z.array(z.string().max(100)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    toolsUsed: z.array(z.string().max(100)).max(100).optional(),
    resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
    contextUsed: z.array(z.string().max(1000)).max(100).optional(),
    created: z.number(),
    updated: z.number(),
    projectPath: z.string().max(1000),
    version: z.number().positive()
}).passthrough(); // Allow additional properties with size limits

// Base task schema
const baseTaskSchema = z.object({
    path: z.string()
        .regex(/^[a-zA-Z0-9_.-]+(?:\/[a-zA-Z0-9_.-]+)*$/)
        .refine(
            (path) => path.split('/').length <= 8,
            'Path depth cannot exceed 8 levels'
        ),
    name: z.string().min(1).max(200),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType),
    status: z.nativeEnum(TaskStatus),
    parentPath: z.string().optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50),
    subtasks: z.array(z.string()).max(100),
    metadata: taskMetadataSchema
});

// Create task input schema
export const createTaskSchema = z.object({
    path: z.string()
        .regex(/^[a-zA-Z0-9_.-]+(?:\/[a-zA-Z0-9_.-]+)*$/)
        .refine(
            (path) => !path || path.split('/').length <= 8,
            'Path depth cannot exceed 8 levels'
        )
        .optional(),
    name: z.string().min(1).max(200),
    parentPath: z.string()
        .regex(/^[a-zA-Z0-9_.-]+(?:\/[a-zA-Z0-9_.-]+)*$/)
        .refine(
            (path) => path.split('/').length <= 7, // One less than max to allow for child
            'Parent path depth cannot exceed 7 levels'
        )
        .optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: z.object({
        priority: z.enum(['low', 'medium', 'high']).optional(),
        tags: z.array(z.string().max(100)).max(100).optional(),
        reasoning: z.string().max(2000).optional(),
        toolsUsed: z.array(z.string().max(100)).max(100).optional(),
        resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
        contextUsed: z.array(z.string().max(1000)).max(100).optional(),
        dependencies: z.array(z.string()).max(50).optional() // Support legacy format
    }).partial().optional().transform(data => {
        if (data?.dependencies) {
            // Log migration of dependencies from metadata
            console.warn('Migrating dependencies from metadata to main task structure');
        }
        return data;
    })
});

// Update task input schema
export const updateTaskSchema = z.object({
    name: z.string().min(1).max(200).optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    status: z.nativeEnum(TaskStatus).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: z.object({
        priority: z.enum(['low', 'medium', 'high']).optional(),
        tags: z.array(z.string().max(100)).max(100).optional(),
        reasoning: z.string().max(2000).optional(),
        toolsUsed: z.array(z.string().max(100)).max(100).optional(),
        resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
        contextUsed: z.array(z.string().max(1000)).max(100).optional(),
        dependencies: z.array(z.string()).max(50).optional() // Support legacy format
    }).partial().optional().transform(data => {
        if (data?.dependencies) {
            // Log migration of dependencies from metadata
            console.warn('Migrating dependencies from metadata to main task structure');
        }
        const { dependencies: _, ...rest } = data || {};
        return rest;
    })
});

// Task response schema
export const taskResponseSchema = z.object({
    success: z.boolean(),
    data: z.unknown().optional(),
    error: z.object({
        code: z.string(),
        message: z.string()
    }).optional(),
    metadata: z.object({
        timestamp: z.number(),
        requestId: z.string(),
        projectPath: z.string(),
        affectedPaths: z.array(z.string())
    })
});

// Export type-safe validation functions
export function validateTask(task: unknown) {
    return baseTaskSchema.parse(task);
}

export function validateCreateTaskInput(input: unknown) {
    return createTaskSchema.parse(input);
}

export function validateUpdateTaskInput(input: unknown) {
    return updateTaskSchema.parse(input);
}

export function validateTaskResponse(response: unknown) {
    return taskResponseSchema.parse(response);
}

// Export schemas for use in other modules
export const schemas = {
    task: baseTaskSchema,
    createTask: createTaskSchema,
    updateTask: updateTaskSchema,
    taskResponse: taskResponseSchema,
    taskMetadata: taskMetadataSchema
};

================
File: src/index.ts
================
/**
 * Atlas MCP Server
 * Path-based task management system
 */
import { promises as fs } from 'fs';
import { TaskManager } from './task-manager.js';
import { Logger } from './logging/index.js';
import { StorageConfig, TaskStorage } from './types/storage.js';
import { createStorage } from './storage/index.js';
import { ToolHandler } from './tools/handler.js';
import { AtlasServer } from './server/index.js';

export class AtlasServerBootstrap {
    private readonly logger: Logger;
    private storage!: TaskStorage;
    private taskManager!: TaskManager;
    private toolHandler!: ToolHandler;
    private server!: AtlasServer;
    private readonly storageConfig: StorageConfig;

    constructor() {
        // Initialize logger
        this.logger = Logger.getInstance().child({ component: 'AtlasServerBootstrap' });

        // Log environment variables
        this.logger.debug('Environment variables:', {
            ATLAS_STORAGE_DIR: process.env.ATLAS_STORAGE_DIR,
            ATLAS_STORAGE_NAME: process.env.ATLAS_STORAGE_NAME,
            LOG_LEVEL: process.env.LOG_LEVEL,
            NODE_ENV: process.env.NODE_ENV
        });

        // Validate required environment variables
        if (!process.env.ATLAS_STORAGE_DIR) {
            throw new Error('ATLAS_STORAGE_DIR environment variable is required');
        }
        if (!process.env.ATLAS_STORAGE_NAME) {
            throw new Error('ATLAS_STORAGE_NAME environment variable is required');
        }

        // Set up storage configuration
        const storageDir = process.env.ATLAS_STORAGE_DIR;
        this.storageConfig = {
            baseDir: storageDir,
            name: process.env.ATLAS_STORAGE_NAME,
            connection: {
                maxRetries: Number(process.env.ATLAS_MAX_RETRIES) || 3,
                retryDelay: Number(process.env.ATLAS_RETRY_DELAY) || 1000,
                busyTimeout: Number(process.env.ATLAS_BUSY_TIMEOUT) || 5000
            },
            performance: {
                checkpointInterval: Number(process.env.ATLAS_CHECKPOINT_INTERVAL) || 300000,
                cacheSize: Number(process.env.ATLAS_CACHE_SIZE) || 2000,
                mmapSize: Number(process.env.ATLAS_MMAP_SIZE) || 30000000000,
                pageSize: Number(process.env.ATLAS_PAGE_SIZE) || 4096,
                maxMemory: Number(process.env.ATLAS_MAX_MEMORY) || 2 * 1024 * 1024 * 1024, // 2GB default
                maxCacheMemory: Number(process.env.ATLAS_MAX_CACHE_MEMORY) || 512 * 1024 * 1024 // 512MB default
            }
        };
    }

    private async initialize(): Promise<void> {
        try {
            // Ensure storage directory exists
            await fs.mkdir(this.storageConfig.baseDir, { recursive: true });

            // Initialize storage
            this.storage = await createStorage(this.storageConfig);
            this.logger.info('Storage initialized', { dir: this.storageConfig.baseDir });

            // Initialize task manager with existing storage
            this.taskManager = new TaskManager(this.storage);
            this.logger.info('Task manager initialized');

            // Create tool handler
            this.toolHandler = new ToolHandler(this.taskManager);
            this.logger.info('Tool handler initialized');

            // Create server instance
            this.server = new AtlasServer(
                {
                    name: 'atlas-mcp-server',
                    version: '0.1.0',
                    maxRequestsPerMinute: 100,
                    requestTimeout: 30000,
                    shutdownTimeout: 30000
                },
                this.toolHandler
            );
            this.logger.info('Server instance created');
        } catch (error) {
            this.logger.fatal('Failed to initialize server components', { error });
            throw error;
        }
    }

    async start(): Promise<void> {
        try {
            await this.initialize();
            await this.server.run();
            const maxMemory = this.storageConfig.performance?.maxMemory || 2 * 1024 * 1024 * 1024;
            const maxCacheMemory = this.storageConfig.performance?.maxCacheMemory || 512 * 1024 * 1024;

            this.logger.info('Atlas MCP server started', {
                storageDir: this.storageConfig.baseDir,
                storageName: this.storageConfig.name,
                version: '0.1.0',
                environment: process.env.NODE_ENV,
                logLevel: process.env.LOG_LEVEL,
                maxMemory: `${Math.round(maxMemory / 1024 / 1024)}MB`,
                maxCacheMemory: `${Math.round(maxCacheMemory / 1024 / 1024)}MB`
            });
        } catch (error) {
            this.logger.fatal('Failed to start server', { error });
            throw error;
        }
    }
}

// Start server if run directly
const isMainModule = import.meta.url === `file://${process.argv[1]}`;
if (isMainModule) {
    const server = new AtlasServerBootstrap();
    server.start().catch((error) => {
        console.error('Failed to start server:', error);
        process.exit(1);
    });
}

================
File: src/task-manager.ts
================
/**
 * Path-based task manager implementation
 */
import { Task, TaskStatus, TaskType, CreateTaskInput, UpdateTaskInput, TaskResponse } from './types/task.js';
import { TaskStorage } from './types/storage.js';
import { Logger } from './logging/index.js';
import { ErrorCodes, createError } from './errors/index.js';
import { validateTaskPath, isValidTaskHierarchy } from './types/task.js';

export class TaskManager {
    private logger: Logger;
    readonly storage: TaskStorage;
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_CACHE_MEMORY = 512 * 1024 * 1024; // 512MB cache limit
    private readonly MEMORY_CHECK_INTERVAL = 60000; // 1 minute

    constructor(storage: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskManager' });
        this.storage = storage;
        this.setupMemoryMonitoring();
    }

    /**
     * Creates a new task with path-based hierarchy
     */
    async createTask(input: CreateTaskInput): Promise<TaskResponse<Task>> {
        try {
            // Generate path if not provided
            const path = input.path || this.generateTaskPath(input);
            
            // Validate path
            const pathValidation = validateTaskPath(path);
            if (!pathValidation.valid) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    pathValidation.error || 'Invalid task path format'
                );
            }

            // Check for duplicate path
            const existingTask = await this.getTaskByPath(path);
            if (existingTask) {
                throw createError(
                    ErrorCodes.TASK_DUPLICATE,
                    {
                        path,
                        existingTask: {
                            name: existingTask.name,
                            type: existingTask.type,
                            status: existingTask.status
                        }
                    },
                    `Task with path '${path}' already exists. Use a different path or update the existing task.`
                );
            }

            // Start transaction for task creation
            await this.storage.beginTransaction();

            try {
                // Check parent path if provided
                if (input.parentPath) {
                    const parent = await this.getTaskByPath(input.parentPath);
                    if (!parent) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            `Parent task '${input.parentPath}' not found. Ensure the parent task exists before creating child tasks.`
                        );
                    }

                    // Validate hierarchy with detailed error message
                    const hierarchyValidation = isValidTaskHierarchy(parent.type, input.type || TaskType.TASK);
                    if (!hierarchyValidation.valid) {
                        const typeRules = [
                            'MILESTONE: Can contain TASK and GROUP types',
                            'GROUP: Can only contain TASK type',
                            'TASK: Cannot contain any subtasks'
                        ].join('\n');

                        throw createError(
                            ErrorCodes.TASK_INVALID_PARENT,
                            {
                                parentType: parent.type,
                                childType: input.type || TaskType.TASK,
                                parentPath: parent.path
                            },
                            hierarchyValidation.reason || 'Invalid parent-child task type combination',
                            `Task type hierarchy rules:\n${typeRules}\n\nAttempted to add ${input.type || TaskType.TASK} under ${parent.type}`
                        );
                    }
                }

                // Validate dependencies if provided
                if (input.dependencies?.length) {
                    const missingDeps = [];
                    for (const depPath of input.dependencies) {
                        const depTask = await this.getTaskByPath(depPath);
                        if (!depTask) {
                            missingDeps.push(depPath);
                        }
                    }
                    if (missingDeps.length > 0) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            `Missing dependency tasks: ${missingDeps.join(', ')}. All dependencies must exist before creating a task that depends on them.`
                        );
                    }
                }

                // Extract dependencies from metadata if present
                const metadataDeps = input.metadata?.dependencies as string[] | undefined;
                const dependencies = input.dependencies || metadataDeps || [];
                
                // Remove dependencies from metadata to avoid duplication
                const metadata = { ...input.metadata };
                delete metadata.dependencies;

                const task: Task = {
                    path,
                    name: input.name,
                    description: input.description,
                    type: input.type || TaskType.TASK,
                    status: TaskStatus.PENDING,
                    parentPath: input.parentPath,
                    notes: input.notes,
                    reasoning: input.reasoning,
                    dependencies,
                    subtasks: [],
                    metadata: {
                        ...metadata,
                        created: Date.now(),
                        updated: Date.now(),
                        projectPath: path.split('/')[0],
                        version: 1
                    }
                };

                await this.storage.saveTask(task);
                await this.storage.commitTransaction();

                return {
                    success: true,
                    data: task,
                    metadata: {
                        timestamp: Date.now(),
                        requestId: Math.random().toString(36).substring(7),
                        projectPath: task.metadata.projectPath,
                        affectedPaths: [task.path]
                    }
                };
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            this.logger.error('Failed to create task', {
                error,
                input,
                context: {
                    path: input.path,
                    parentPath: input.parentPath,
                    type: input.type,
                    dependencies: input.dependencies
                }
            });
            throw error;
        }
    }

    /**
     * Updates an existing task
     */
    async updateTask(path: string, updates: UpdateTaskInput): Promise<TaskResponse<Task>> {
        try {
            const task = await this.getTaskByPath(path);
            if (!task) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    {
                        path,
                        context: 'Task update'
                    },
                    `Task with path '${path}' not found. Verify the task exists before attempting to update.`
                );
            }

            // Start transaction for task update
            await this.storage.beginTransaction();

            try {
                // Extract dependencies from metadata if present
                const metadataDeps = updates.metadata?.dependencies as string[] | undefined;
                const dependencies = updates.dependencies || metadataDeps || task.dependencies;

                // Validate new dependencies if changed
                if (dependencies !== task.dependencies) {
                    const missingDeps = [];
                    for (const depPath of dependencies) {
                        const depTask = await this.getTaskByPath(depPath);
                        if (!depTask) {
                            missingDeps.push(depPath);
                        }
                    }
                    if (missingDeps.length > 0) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            {
                                path,
                                missingDependencies: missingDeps
                            },
                            `Missing dependency tasks: ${missingDeps.join(', ')}. All dependencies must exist before updating task dependencies.`
                        );
                    }
                }

                // Remove dependencies from metadata to avoid duplication
                const metadata = { ...updates.metadata };
                delete metadata?.dependencies;

                // Update task fields
                const updatedTask: Task = {
                    ...task,
                    name: updates.name || task.name,
                    description: updates.description !== undefined ? updates.description : task.description,
                    type: updates.type || task.type,
                    status: updates.status || task.status,
                    notes: updates.notes || task.notes,
                    reasoning: updates.reasoning || task.reasoning,
                    dependencies,
                    metadata: {
                        ...task.metadata,
                        ...metadata,
                        updated: Date.now(),
                        version: task.metadata.version + 1
                    }
                };

                await this.storage.saveTask(updatedTask);
                await this.storage.commitTransaction();

                return {
                    success: true,
                    data: updatedTask,
                    metadata: {
                        timestamp: Date.now(),
                        requestId: Math.random().toString(36).substring(7),
                        projectPath: updatedTask.metadata.projectPath,
                        affectedPaths: [updatedTask.path]
                    }
                };
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            // Ensure rollback if transaction was started
            try {
                await this.storage.rollbackTransaction();
            } catch (rollbackError) {
                // Log rollback error but throw original error
                this.logger.error('Failed to rollback transaction', {
                    error: rollbackError,
                    originalError: error,
                    context: {
                        path,
                        operation: 'updateTask'
                    }
                });
            }

            this.logger.error('Failed to update task', {
                error,
                context: {
                    path,
                    updates,
                    operation: 'updateTask'
                }
            });
            throw error;
        }
    }

    /**
     * Retrieves a task by its path
     */
    async getTaskByPath(path: string): Promise<Task | null> {
        try {
            return await this.storage.getTask(path);
        } catch (error) {
            this.logger.error('Failed to get task by path', { error, path });
            throw error;
        }
    }

    /**
     * Lists tasks matching a path pattern
     */
    async listTasks(pathPattern: string): Promise<Task[]> {
        try {
            return await this.storage.getTasksByPattern(pathPattern);
        } catch (error) {
            this.logger.error('Failed to list tasks', { error, pathPattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            return await this.storage.getTasksByStatus(status);
        } catch (error) {
            this.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        try {
            return await this.storage.getSubtasks(parentPath);
        } catch (error) {
            this.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks
     */
    async deleteTask(path: string): Promise<TaskResponse<void>> {
        try {
            // Start transaction for task deletion
            await this.storage.beginTransaction();

            try {
                // Verify task exists before attempting deletion
                const task = await this.getTaskByPath(path);
                if (!task) {
                    throw createError(
                        ErrorCodes.TASK_NOT_FOUND,
                        {
                            path,
                            context: 'Task deletion'
                        },
                        `Task with path '${path}' not found. Verify the task exists before attempting to delete.`
                    );
                }

                // Get subtasks to include in affected paths
                const subtasks = await this.storage.getSubtasks(path);
                const affectedPaths = [path, ...subtasks.map(t => t.path)];

                // Delete the task and its subtasks
                await this.storage.deleteTask(path);
                await this.storage.commitTransaction();

                return {
                    success: true,
                    metadata: {
                        timestamp: Date.now(),
                        requestId: Math.random().toString(36).substring(7),
                        projectPath: path.split('/')[0],
                        affectedPaths
                    }
                };
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            this.logger.error('Failed to delete task', {
                error,
                context: {
                    path,
                    operation: 'deleteTask'
                }
            });
            throw error;
        }
    }

    /**
     * Clears all tasks from the database
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                {
                    context: 'Clear all tasks',
                    required: 'explicit confirmation'
                },
                'Must explicitly confirm task deletion',
                'Set confirm parameter to true to proceed with clearing all tasks. This operation cannot be undone.'
            );
        }

        try {
            // Start transaction for clearing all tasks
            await this.storage.beginTransaction();

            try {
                // Get count of tasks before deletion for logging
                const tasks = await this.storage.getTasksByPattern('*');
                const taskCount = tasks.length;

                // Clear all tasks
                await this.storage.clearAllTasks();
                await this.storage.commitTransaction();

                this.logger.info('All tasks cleared from database', {
                    tasksCleared: taskCount,
                    operation: 'clearAllTasks'
                });
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            this.logger.error('Failed to clear tasks', {
                error,
                context: {
                    operation: 'clearAllTasks',
                    confirm
                }
            });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            this.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            this.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        try {
            const result = await this.storage.repairRelationships(dryRun);
            this.logger.info('Relationship repair completed', { 
                dryRun,
                pathPattern,
                fixed: result.fixed,
                issueCount: result.issues.length
            });
            return result;
        } catch (error) {
            this.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Generates a task path based on input
     */
    private generateTaskPath(input: CreateTaskInput): string {
        const segments: string[] = [];

        // Add parent path if provided
        if (input.parentPath) {
            segments.push(input.parentPath);
        }

        // Add task name as final segment
        segments.push(input.name.toLowerCase().replace(/[^a-z0-9]+/g, '-'));

        return segments.join('/');
    }

    /**
     * Sets up memory monitoring for cache management
     */
    private setupMemoryMonitoring(): void {
        this.memoryMonitor = setInterval(async () => {
            const memUsage = process.memoryUsage();
            
            // Log memory stats
            this.logger.debug('Task manager memory usage:', {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`
            });

            // Check if cache is using too much memory
            if (memUsage.heapUsed > this.MAX_CACHE_MEMORY) {
                this.logger.warn('Cache memory threshold exceeded, clearing caches', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(this.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
                });
                
                await this.clearCaches();
            }
        }, this.MEMORY_CHECK_INTERVAL);
    }

    /**
     * Clears all caches to free memory
     */
    async clearCaches(): Promise<void> {
        try {
            // Clear storage caches
            if ('clearCache' in this.storage) {
                await (this.storage as any).clearCache();
            }

            // Force garbage collection if available
            if (global.gc) {
                global.gc();
            }

            this.logger.info('Caches cleared successfully');
        } catch (error) {
            this.logger.error('Failed to clear caches', { error });
            throw error;
        }
    }

    /**
     * Cleans up resources and closes connections
     */
    async cleanup(): Promise<void> {
        try {
            // Stop memory monitoring
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }

            // Clear caches
            await this.clearCaches();

            // Close storage
            await this.storage.close();

            this.logger.info('Task manager cleanup completed');
        } catch (error) {
            this.logger.error('Failed to cleanup task manager', { error });
            throw error;
        }
    }

    /**
     * Gets current memory usage statistics
     */
    getMemoryStats(): { heapUsed: number; heapTotal: number; rss: number } {
        const memUsage = process.memoryUsage();
        return {
            heapUsed: memUsage.heapUsed,
            heapTotal: memUsage.heapTotal,
            rss: memUsage.rss
        };
    }

    /**
     * Closes the task manager and releases resources
     */
    async close(): Promise<void> {
        await this.cleanup();
    }
}

================
File: src/types.ts
================
export * from './types/task.js';

================
File: .eslintrc.json
================
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.json",
    "ecmaVersion": 2022,
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint",
    "jest",
    "import"
  ],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "plugin:jest/recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript"
  ],
  "env": {
    "node": true,
    "jest": true,
    "es2022": true
  },
  "rules": {
    "@typescript-eslint/explicit-function-return-type": ["error", {
      "allowExpressions": true,
      "allowTypedFunctionExpressions": true
    }],
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": ["error", {
      "argsIgnorePattern": "^_",
      "varsIgnorePattern": "^_"
    }],
    "@typescript-eslint/require-await": "error",
    "@typescript-eslint/no-floating-promises": "error",
    "@typescript-eslint/no-misused-promises": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error",
    "@typescript-eslint/strict-boolean-expressions": "error",
    "import/no-unresolved": "error",
    "import/order": ["error", {
      "groups": [
        ["builtin", "external"],
        "internal",
        ["parent", "sibling", "index"]
      ],
      "newlines-between": "always",
      "alphabetize": {
        "order": "asc",
        "caseInsensitive": true
      }
    }],
    "no-console": ["error", {
      "allow": ["warn", "error"]
    }],
    "no-return-await": "error",
    "prefer-const": "error",
    "eqeqeq": ["error", "always"],
    "curly": ["error", "all"],
    "no-var": "error",
    "require-await": "error"
  },
  "settings": {
    "import/parsers": {
      "@typescript-eslint/parser": [".ts", ".tsx"]
    },
    "import/resolver": {
      "typescript": {
        "alwaysTryTypes": true,
        "project": "./tsconfig.json"
      }
    }
  },
  "overrides": [
    {
      "files": ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"],
      "extends": ["plugin:jest/recommended"],
      "rules": {
        "@typescript-eslint/no-explicit-any": "off",
        "@typescript-eslint/no-non-null-assertion": "off"
      }
    }
  ]
}

================
File: implementation-plan.md
================
# Atlas MCP Server Implementation Plan

## Core System Improvements

### 1. Import Path Standardization & Index Files
```typescript
// Update all imports to use .js extension
import { Task, TaskStatus } from './types/task.js';
import { TaskStorage } from './types/storage.js';
import { Logger } from './logging/index.js';
import { ErrorCodes, createError } from './errors/index.js';

// Add missing index files
// /task/core/batch/index.ts
export * from './base-batch-processor.js';
export * from './dependency-aware-batch-processor.js';
export * from './generic-batch-processor.js';
export * from './task-status-batch-processor.js';

// /task/core/cache/index.ts
export * from './cache-manager.js';
export * from './cache-types.js';

// /task/core/indexing/index.ts
export * from './index-manager.js';

// /task/core/transactions/index.ts
export * from './transaction-manager.js';
export * from './transaction-types.js';
```

### 2. Batch Processing Architecture
```typescript
// src/task/core/batch/common/batch-utils.ts
export class BatchUtils {
  static validateBatch(batch: BatchData[]): ValidationResult {
    return {
      valid: true,
      errors: []
    };
  }

  static async processBatch<T>(
    batch: BatchData[],
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    const results: T[] = [];
    const errors: Error[] = [];
    
    for (const item of batch) {
      try {
        results.push(await processor(item));
      } catch (error) {
        errors.push(error);
      }
    }
    
    return { results, errors };
  }
}

// src/task/core/batch/base-batch-processor.ts
export abstract class BaseBatchProcessor {
  constructor(protected readonly dependencies: BatchDependencies) {}
  
  protected abstract process(): Promise<void>;
  protected abstract validate(): Promise<boolean>;
  
  async execute(): Promise<void> {
    if (await this.validate()) {
      await this.process();
    }
  }
}

// src/task/core/batch/dependency-aware-batch-processor.ts
export class DependencyAwareBatchProcessor extends BaseBatchProcessor {
  protected async process(): Promise<void> {
    const { validator, logger, storage } = this.dependencies;
    // Implementation
  }
  
  protected async validate(): Promise<boolean> {
    // Implementation
    return true;
  }
}
```

### 3. Event System Integration
```typescript
// src/events/event-manager.ts
export class EventManager {
  private static instance: EventManager;
  private emitter: EventEmitter;
  private logger: Logger;
  
  private constructor() {
    this.emitter = new EventEmitter();
    this.logger = Logger.getInstance().child({ component: 'EventManager' });
    this.setupErrorHandling();
  }
  
  static getInstance(): EventManager {
    if (!EventManager.instance) {
      EventManager.instance = new EventManager();
    }
    return EventManager.instance;
  }
  
  emit(event: EventTypes, data: unknown): void {
    try {
      this.logger.debug('Emitting event', { event, data });
      this.emitter.emit(event, data);
    } catch (error) {
      this.logger.error('Event emission failed', { event, error });
    }
  }
  
  on(event: EventTypes, handler: (data: unknown) => void): void {
    this.emitter.on(event, handler);
  }
  
  private setupErrorHandling(): void {
    this.emitter.on('error', (error) => {
      this.logger.error('Event emitter error', { error });
    });
  }
}

// src/types/events.ts
export enum EventTypes {
  TASK_CREATED = 'task:created',
  TASK_UPDATED = 'task:updated',
  TASK_DELETED = 'task:deleted',
  TASK_STATUS_CHANGED = 'task:status:changed',
  CACHE_INVALIDATED = 'cache:invalidated',
  ERROR_OCCURRED = 'error:occurred',
  MEMORY_PRESSURE = 'memory:pressure',
  STORAGE_ERROR = 'storage:error',
  BATCH_COMPLETED = 'batch:completed'
}

export interface TaskEvent {
  task: Task;
  timestamp: number;
  metadata?: Record<string, unknown>;
}

export interface CacheEvent {
  type: 'invalidated' | 'cleared' | 'pressure';
  timestamp: number;
  metadata?: {
    reason?: string;
    memoryUsage?: number;
  };
}
```

### 4. Task Management Architecture
```typescript
// src/task/operations/task-operations.ts
export class TaskOperations {
  constructor(
    private storage: TaskStorage,
    private validator: TaskValidator,
    private eventManager: EventManager,
    private logger: Logger
  ) {}

  async createTask(input: CreateTaskInput): Promise<Task> {
    await this.validator.validateCreate(input);
    const task = await this.storage.createTask(input);
    this.eventManager.emit(EventTypes.TASK_CREATED, { task, timestamp: Date.now() });
    return task;
  }

  async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
    await this.validator.validateUpdate(path, updates);
    const task = await this.storage.updateTask(path, updates);
    this.eventManager.emit(EventTypes.TASK_UPDATED, { task, timestamp: Date.now() });
    return task;
  }
}

// src/task/validation/task-validator.ts
export class TaskValidator {
  constructor(
    private storage: TaskStorage,
    private logger: Logger
  ) {}

  async validateCreate(input: CreateTaskInput): Promise<void> {
    // Implementation
  }

  async validateUpdate(path: string, updates: UpdateTaskInput): Promise<void> {
    // Implementation
  }
}

// src/task/relationships/task-relationships.ts
export class TaskRelationships {
  constructor(
    private storage: TaskStorage,
    private eventManager: EventManager,
    private logger: Logger
  ) {}

  async updateDependencies(task: Task, dependencies: string[]): Promise<void> {
    // Implementation
  }

  async validateHierarchy(parentPath: string, childType: TaskType): Promise<void> {
    // Implementation
  }
}

// src/task/memory/task-memory-manager.ts
export class TaskMemoryManager {
  constructor(
    private eventManager: EventManager,
    private logger: Logger
  ) {
    this.setupMemoryMonitoring();
  }

  private setupMemoryMonitoring(): void {
    // Implementation
  }

  async clearCaches(): Promise<void> {
    // Implementation
  }
}
```

### 5. Cache System Enhancement
```typescript
// src/task/core/cache/cache-coordinator.ts
export class CacheCoordinator {
  private metrics: CacheMetrics;
  
  constructor(
    private cacheManager: CacheManager,
    private eventManager: EventManager,
    private logger: Logger
  ) {
    this.metrics = new CacheMetrics();
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    this.eventManager.on(EventTypes.TASK_UPDATED, () => this.invalidateTaskCache());
    this.eventManager.on(EventTypes.MEMORY_PRESSURE, () => this.reduceCacheSize());
  }
  
  private async invalidateTaskCache(): Promise<void> {
    await this.cacheManager.invalidate();
    this.eventManager.emit(EventTypes.CACHE_INVALIDATED, {
      timestamp: Date.now(),
      metadata: { reason: 'task_update' }
    });
  }
  
  private async reduceCacheSize(): Promise<void> {
    const before = this.metrics.getCacheSize();
    await this.cacheManager.reduce();
    const after = this.metrics.getCacheSize();
    
    this.logger.info('Cache size reduced', {
      before,
      after,
      reduction: before - after
    });
  }
}

// src/task/core/cache/cache-metrics.ts
export class CacheMetrics {
  private hits = 0;
  private misses = 0;
  private size = 0;
  private lastCleanup: number = Date.now();
  
  recordHit(): void {
    this.hits++;
  }
  
  recordMiss(): void {
    this.misses++;
  }
  
  updateSize(newSize: number): void {
    this.size = newSize;
  }
  
  getMetrics(): CacheMetricsData {
    return {
      hits: this.hits,
      misses: this.misses,
      hitRatio: this.getHitRatio(),
      size: this.size,
      lastCleanup: this.lastCleanup
    };
  }
  
  private getHitRatio(): number {
    const total = this.hits + this.misses;
    return total === 0 ? 0 : this.hits / total;
  }
}
```

## Integration Testing

```typescript
// src/tests/integration/task-lifecycle.test.ts
describe('Task Lifecycle Integration', () => {
  let taskManager: TaskManager;
  let eventManager: EventManager;
  let events: any[] = [];

  beforeEach(() => {
    events = [];
    eventManager = EventManager.getInstance();
    eventManager.on(EventTypes.TASK_CREATED, (e) => events.push(e));
    eventManager.on(EventTypes.TASK_UPDATED, (e) => events.push(e));
  });

  it('should handle complete task lifecycle', async () => {
    // Create task
    const task = await taskManager.createTask({
      name: 'Test Task',
      type: TaskType.TASK
    });

    // Update task
    await taskManager.updateTask(task.path, {
      status: TaskStatus.IN_PROGRESS
    });

    // Verify events
    expect(events).toHaveLength(2);
    expect(events[0].type).toBe(EventTypes.TASK_CREATED);
    expect(events[1].type).toBe(EventTypes.TASK_UPDATED);
  });
});

// src/tests/integration/cache-coordination.test.ts
describe('Cache Coordination Integration', () => {
  let cacheCoordinator: CacheCoordinator;
  let eventManager: EventManager;

  it('should handle cache invalidation on task updates', async () => {
    const events: CacheEvent[] = [];
    eventManager.on(EventTypes.CACHE_INVALIDATED, (e) => events.push(e));

    // Trigger task update
    await taskManager.updateTask('test/task', { status: TaskStatus.COMPLETED });

    // Verify cache invalidation
    expect(events).toHaveLength(1);
    expect(events[0].type).toBe('invalidated');
  });
});
```

## System Validation

1. Code Quality Checks:
   - Run TypeScript compiler
   - Execute linting rules
   - Check code coverage
   - Run integration tests

2. Performance Validation:
   - Monitor memory usage
   - Track cache efficiency
   - Measure operation latency
   - Verify event processing

3. Reliability Checks:
   - Test error handling
   - Verify transaction rollbacks
   - Check memory pressure handling
   - Validate cache coordination

================
File: jest.config.js
================
/** @type {import('@jest/types').Config.InitialOptions} */
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  setupFilesAfterEnv: ['<rootDir>/tests/jest.setup.ts'],
  testMatch: [
    '<rootDir>/tests/**/*.test.ts',
  ],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/build/',
  ],
  globals: {
    'ts-jest': {
      useESM: true,
    },
  },
  verbose: true,
  testTimeout: 10000,
  roots: ['<rootDir>/src/', '<rootDir>/tests/'],
  moduleDirectories: ['node_modules', 'src'],
  testPathIgnorePatterns: ['/node_modules/', '/build/'],
};

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: package.json
================
{
  "name": "atlas-mcp-server",
  "version": "1.0.0",
  "description": "A Model Context Protocol server for hierarchical task management",
  "private": true,
  "type": "module",
  "bin": {
    "atlas-mcp-server": "./build/index.js"
  },
  "files": [
    "build"
  ],
  "scripts": {
    "build": "tsc && node --eval \"import('fs').then(fs => fs.promises.chmod('build/index.js', '755'))\"",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js",
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
    "start": "node build/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cyanheads/atlas-mcp-server.git"
  },
  "author": "cyanheads",
  "bugs": {
    "url": "https://github.com/cyanheads/atlas-mcp-server/issues"
  },
  "homepage": "https://github.com/cyanheads/atlas-mcp-server#readme",
  "dependencies": {
    "@modelcontextprotocol/sdk": "1.0.3",
    "@types/sqlite3": "^3.1.11",
    "@types/uuid": "^10.0.0",
    "@types/winston": "^2.4.4",
    "dotenv": "^16.4.7",
    "nanoid": "^5.0.9",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.0.3",
    "winston": "^3.17.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.17.10",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.3.3"
  }
}

================
File: README.md
================
# ATLAS MCP Server

[![TypeScript](https://img.shields.io/badge/TypeScript-5.3-blue.svg)](https://www.typescriptlang.org/)
[![Model Context Protocol](https://img.shields.io/badge/MCP-1.0.3-green.svg)](https://modelcontextprotocol.io/)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Status](https://img.shields.io/badge/Status-Stable-green.svg)]()
[![GitHub](https://img.shields.io/github/stars/cyanheads/atlas-mcp-server?style=social)](https://github.com/cyanheads/atlas-mcp-server)

ATLAS (Adaptive Task & Logic Automation System) is a Model Context Protocol server that provides hierarchical task management capabilities to Large Language Models. This tool provides LLMs with the structure and context needed to manage complex tasks and dependencies.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Configuration](#configuration)
- [Task Structure](#task-structure)
- [Tools](#tools)
- [Best Practices](#best-practices)
- [Development](#development)
- [Up Next](#up-next)
- [Contributing](#contributing)
- [License](#license)

## Overview

### Model Context Protocol Server

ATLAS implements the Model Context Protocol (MCP), created by Anthropic, which is a standardized communication protocol between LLMs and external systems. The architecture consists of:

- **Clients** (Claude Desktop, IDEs) that maintain server connections
- **Servers** that provide tools and resources to clients
- **LLMs** that interact with servers through client applications

This architecture creates a secure boundary between LLMs and external systems while enabling controlled access to functionality.

### Core Components

ATLAS is built on several robust core components organized into specialized subsystems:

#### Task Management
- **TaskStore**: Path-based task storage system with:
  * Memory-efficient caching (512MB limit)
  * Automatic cache invalidation
  * Path-based hierarchy management
  * Task validation and verification
  * Comprehensive error handling
  * Periodic memory monitoring
  * Cache cleanup on threshold

- **Status Management**:
  * Basic state transitions
  * Status propagation
  * Dependency validation
  * Parent-child status tracking
  * Status-based task filtering
  * Batch status updates
  * Status consistency checks

- **Dependency System**:
  * Path-based dependency tracking
  * Dependency validation
  * Circular dependency prevention
  * Parent-child relationship repair
  * Dependency cleanup on deletion
  * Cross-task dependency management
  * Dependency status tracking

- **Performance Features**:
  * Memory usage monitoring
  * Automatic cache management
  * Database optimization (vacuum)
  * Relationship repair tools
  * Efficient task retrieval
  * Path pattern matching
  * Memory threshold management

- **Error Handling**:
  * Detailed error logging
  * Operation validation
  * Path format verification
  * Dependency checks
  * Clear error messages
  * Recovery procedures

#### System Infrastructure
- **StorageManager**: Provides durable data persistence with SQLite integration
- **SessionManager**: Handles session lifecycle and task list management
- **ConfigManager**: Manages environment-based configuration
- **ValidationSystem**: Ensures data integrity with Zod schema integration

#### Performance & Monitoring
- **RateLimiter**: Controls request rates (100 req/min)
- **HealthMonitor**: Tracks system health with comprehensive metrics
- **MetricsCollector**: Gathers detailed performance statistics
- **RequestTracer**: Traces request flow with debugging capabilities

Through the MCP protocol, ATLAS empowers LLMs to break down complex projects into manageable tasks, track their progress, and maintain dependencies — all within an organized hierarchical structure.

## Features

### Task Organization
- Hierarchical task structures with parent-child relationships
- Dependency management and validation
- Status tracking and automatic propagation
- Bulk operations for efficient task management
- Session-based task isolation

### Content Support
- Markdown documentation with rich formatting
- Code snippets with multi-language syntax highlighting
- JSON data structures with schema validation
- Rich metadata and hierarchical tagging
- Comprehensive task reasoning documentation
- Decision-making history with context preservation
- Cross-reference support between tasks
- Version tracking for content changes

### System Features
- Memory Management
  * 512MB cache limit
  * 60-second memory monitoring
  * Automatic cache cleanup
  * Memory usage statistics
  * Resource cleanup on shutdown
- Health Monitoring
  * Memory usage tracking
  * Basic error monitoring
  * Component health checks
  * Resource utilization tracking
- Error Handling
  * Error categorization
  * Detailed logging
  * Recovery procedures
  * Context preservation
- Maintenance
  * Database optimization
  * Relationship repair
  * Cache management
  * Resource cleanup

### Performance
- Memory-Optimized Operations
  * Efficient task retrieval
  * Automatic cache management
  * Memory usage monitoring
  * Resource optimization
- Database Management
  * SQLite optimization
  * Vacuum operations
  * Relationship repair
  * Path-based indexing
- Resource Management
  * Memory threshold monitoring
  * Cache invalidation
  * Cleanup procedures
  * Connection management

## Installation

### Setup Steps

1. Clone the repository:
```bash
git clone https://github.com/cyanheads/atlas-mcp-server.git
```

2. Navigate to the project directory:
```bash
cd atlas-mcp-server
```

3. Install dependencies:
```bash
npm install
```

4. Build the project:
```bash
npm run build
```

5. Create a storage directory for tasks:
```bash
mkdir -p ~/Documents/atlas-tasks
```

The server is now ready to be configured and used with your MCP client.

## Configuration

ATLAS requires configuration in your MCP client settings:

```json
{
  "mcpServers": {
    "atlas": {
      "command": "node",
      "args": ["/path/to/atlas-mcp-server/build/index.js"],
      "env": {
        "ATLAS_STORAGE_DIR": "/path/to/storage/directory",
        "ATLAS_STORAGE_NAME": "atlas-tasks",
        "ATLAS_MAX_RETRIES": "3",
        "ATLAS_RETRY_DELAY": "1000",
        "ATLAS_BUSY_TIMEOUT": "5000",
        "ATLAS_CHECKPOINT_INTERVAL": "300000",
        "ATLAS_CACHE_SIZE": "2000",
        "ATLAS_MMAP_SIZE": "30000000000",
        "ATLAS_PAGE_SIZE": "4096"
      }
    }
  }
}
```

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| ATLAS_STORAGE_DIR | Directory for task data storage | ./data |
| ATLAS_STORAGE_NAME | Database file name | atlas-tasks |
| ATLAS_MAX_RETRIES | Maximum retry attempts | 3 |
| ATLAS_RETRY_DELAY | Delay between retries (ms) | 1000 |
| ATLAS_BUSY_TIMEOUT | SQLite busy timeout (ms) | 5000 |
| ATLAS_CHECKPOINT_INTERVAL | WAL checkpoint interval (ms) | 300000 |
| ATLAS_CACHE_SIZE | SQLite cache size | 2000 |
| ATLAS_MMAP_SIZE | SQLite mmap size | 30000000000 |
| ATLAS_PAGE_SIZE | SQLite page size | 4096 |

## Task Structure

Tasks support rich content, metadata, and reasoning documentation within a hierarchical structure (maximum 8 levels deep). All task operations are transactional with automatic validation using Zod schemas:

```typescript
{
  "name": "Implementation Task",
  "description": "Implement core functionality",
  "type": "task",
  "notes": [
    "# Requirements\n- Feature A\n- Feature B",
    "interface Feature {\n  name: string;\n  enabled: boolean;\n}"
  ],
  "reasoning": "Modular development approach chosen for reusability. Key considerations:\n- TypeScript support required\n- Features must be independently toggleable\n- Increased complexity balanced against maintainability\n- Backward compatibility required\n- Cross-browser support essential",
  "metadata": {
    "priority": "high",
    "tags": ["core", "implementation"],
    "reasoning": "Additional context about task decisions",
    "toolsUsed": ["npm", "typescript"],
    "resourcesAccessed": ["package.json", "tsconfig.json"],
    "contextUsed": ["project setup", "build configuration"],
    "created": 1703094689310,
    "updated": 1703094734316,
    "projectPath": "server/core",
    "version": 1
  }
}
```

The reasoning field provides a concise explanation of the task's decision-making process and key considerations. The metadata field includes:

- **priority**: Task urgency level (low/medium/high)
- **tags**: Categorization labels
- **reasoning**: Additional LLM context about decisions
- **toolsUsed**: Tools used by LLM for the task
- **resourcesAccessed**: Resources accessed during task
- **contextUsed**: Key context pieces used in decisions
- **created/updated**: Timestamps in milliseconds
- **projectPath**: Task's project context
- **version**: Task revision number

### Task Storage Features

- **Validation**: Zod schema validation for all fields
- **Caching**: Automatic caching with invalidation
- **Indexing**: Full-text search on content and metadata
- **Transactions**: ACID compliance for all operations
- **Performance**: Optimized retrieval with batch support
- **History**: Change tracking and version management

### Example Task List (Without reasoning)

The following example demonstrates a task breakdown for a personal portfolio website project, showcasing the hierarchical structure and metadata capabilities. The task list was generated from the following prompt:
> Create a comprehensive task plan for a modern, responsive personal portfolio website that showcases a web developer's projects, skills, and professional experience, incorporating best practices in UI/UX design, performance optimization, and accessibility. The site should feature an elegant, minimalist design with smooth animations, dark/light mode support, and interactive project demonstrations, while ensuring cross-browser compatibility and optimal load times.

<details>
<summary><b>Portfolio Website Development Task List</b></summary>

```json
{
  "success": true,
  "data": [
    {
      "id": "4ylBnk6B",
      "name": "Project Setup and Architecture",
      "description": "Initial project setup, tooling configuration, and architectural decisions",
      "notes": [
        {
          "type": "markdown",
          "content": "# Setup Considerations\n- Modern build tooling (Vite/Next.js)\n- TypeScript configuration\n- ESLint and Prettier setup\n- Git repository initialization\n- Folder structure organization"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "8cz24Z95",
        "GwqwfnSf",
        "gKayn2ha"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:29.310Z",
        "updated": "2024-12-20T18:52:14.316Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "setup",
          "architecture",
          "configuration"
        ],
        "resolvedSubtasks": [
          {
            "id": "8cz24Z95",
            "name": "Initialize Project with Build Tools",
            "description": "Set up the project with Vite and configure essential build tools",
            "notes": [
              {
                "type": "markdown",
                "content": "# Implementation Steps\n1. Initialize new Vite project with React/TypeScript template\n2. Configure project structure\n3. Set up path aliases\n4. Configure build optimization settings\n\n# Technical Considerations\n- Use Vite for fast development and optimized production builds\n- Configure TypeScript for type safety\n- Set up module resolution and aliases"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:51:59.902Z",
              "updated": "2024-12-20T18:51:59.902Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "setup",
                "build-tools",
                "vite"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "4ylBnk6B"
          },
          {
            "id": "GwqwfnSf",
            "name": "Configure Development Tools and Version Control",
            "description": "Set up code quality tools, linting, formatting, and version control",
            "notes": [
              {
                "type": "markdown",
                "content": "# Setup Tasks\n1. Initialize Git repository\n2. Configure ESLint with TypeScript rules\n3. Set up Prettier for code formatting\n4. Create .gitignore file\n5. Configure pre-commit hooks\n\n# Configuration Files\n- `.eslintrc.json`: ESLint configuration\n- `.prettierrc`: Prettier rules\n- `.editorconfig`: Editor settings\n- `husky`: Git hooks\n\n# Best Practices\n- Enforce consistent code style\n- Enable TypeScript strict mode\n- Set up automated code formatting\n- Configure Git hooks for pre-commit linting"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "8cz24Z95"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:06.869Z",
              "updated": "2024-12-20T18:52:06.869Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "tooling",
                "git",
                "code-quality"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "4ylBnk6B"
          },
          {
            "id": "gKayn2ha",
            "name": "Install and Configure Core Dependencies",
            "description": "Set up essential libraries and dependencies for the portfolio website",
            "notes": [
              {
                "type": "markdown",
                "content": "# Core Dependencies\n\n## UI Framework and Styling\n- React for UI components\n- TailwindCSS for styling\n- Framer Motion for animations\n- React Icons for iconography\n\n## State Management and Routing\n- React Router for navigation\n- Zustand/Jotai for state management\n\n## Development Dependencies\n- TypeScript for type safety\n- PostCSS for CSS processing\n- Autoprefixer for browser compatibility\n\n## Testing Framework\n- Vitest for unit testing\n- React Testing Library for component testing\n\n# Configuration Steps\n1. Install production dependencies\n2. Install development dependencies\n3. Configure TailwindCSS\n4. Set up PostCSS\n5. Configure testing environment"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "8cz24Z95"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:14.315Z",
              "updated": "2024-12-20T18:52:14.315Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "dependencies",
                "libraries",
                "configuration"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "4ylBnk6B"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    },
    {
      "id": "QTmaDu2O",
      "name": "UI/UX Design Implementation",
      "description": "Design system, component architecture, and responsive layout implementation",
      "notes": [
        {
          "type": "markdown",
          "content": "# Design Requirements\n- Minimalist, elegant design system\n- Dark/light mode theming\n- Responsive layouts\n- Smooth animations and transitions\n- Consistent typography and spacing"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "lmtqOVNC",
        "AllDgreE"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:34.428Z",
        "updated": "2024-12-20T18:52:31.900Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "design",
          "ui-ux",
          "frontend"
        ],
        "resolvedSubtasks": [
          {
            "id": "lmtqOVNC",
            "name": "Implement Design System and Theme Configuration",
            "description": "Create a comprehensive design system with dark/light mode support",
            "notes": [
              {
                "type": "markdown",
                "content": "# Design System Components\n\n## Color Palette\n- Primary and secondary colors\n- Neutral shades\n- Accent colors\n- Dark/light mode variants\n\n## Typography\n- Font families (heading and body)\n- Font sizes and line heights\n- Font weights\n- Letter spacing\n\n## Spacing System\n- Base spacing unit\n- Spacing scale\n- Layout margins and padding\n\n## Theme Implementation\n1. Create theme configuration file\n2. Implement theme context/provider\n3. Create theme switching mechanism\n4. Set up CSS custom properties\n5. Create utility classes\n\n# Technical Approach\n- Use CSS variables for dynamic theming\n- Implement theme persistence\n- Create theme toggle component\n- Set up system theme detection"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "gKayn2ha"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:23.627Z",
              "updated": "2024-12-20T18:52:23.627Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "design-system",
                "theming",
                "css",
                "dark-mode"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "QTmaDu2O"
          },
          {
            "id": "AllDgreE",
            "name": "Create Responsive Layout System and Core Components",
            "description": "Implement responsive layout system and reusable core components",
            "notes": [
              {
                "type": "markdown",
                "content": "# Layout System\n\n## Grid System\n- Implement responsive grid layout\n- Define breakpoints\n- Create container components\n- Set up layout utilities\n\n## Core Components\n1. Navigation\n   - Responsive navbar\n   - Mobile menu\n   - Navigation links\n\n2. Layout Components\n   - Container\n   - Section\n   - Grid\n   - Flex containers\n\n3. UI Components\n   - Buttons (primary, secondary, ghost)\n   - Cards\n   - Links\n   - Icons\n   - Input fields\n   - Loading states\n\n## Animation System\n- Define animation variables\n- Create transition utilities\n- Implement scroll animations\n- Set up interaction animations\n\n# Implementation Guidelines\n- Use CSS Grid and Flexbox\n- Mobile-first approach\n- Implement smooth transitions\n- Ensure consistent spacing\n- Create component documentation"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "lmtqOVNC"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:31.899Z",
              "updated": "2024-12-20T18:52:31.899Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "components",
                "layout",
                "responsive",
                "animations"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "QTmaDu2O"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    },
    {
      "id": "rvxqxsd8",
      "name": "Core Features Development",
      "description": "Implementation of main portfolio features and sections",
      "notes": [
        {
          "type": "markdown",
          "content": "# Key Features\n- Project showcase with interactive demos\n- Skills and expertise section\n- Professional experience timeline\n- Contact form and social links\n- Blog/articles section (optional)"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "NUD4rYDu",
        "4ItyKXEL",
        "8CR6zCks"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:39.220Z",
        "updated": "2024-12-20T18:53:00.751Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "features",
          "development",
          "core-functionality"
        ],
        "resolvedSubtasks": [
          {
            "id": "NUD4rYDu",
            "name": "Implement Project Showcase Section",
            "description": "Create an interactive project showcase with filtering and detailed project views",
            "notes": [
              {
                "type": "markdown",
                "content": "# Features\n\n## Project Grid/List\n- Responsive project grid layout\n- Project cards with hover effects\n- Image thumbnails with lazy loading\n- Category/tag filtering system\n\n## Project Details\n- Modal/page for detailed project view\n- Project description and technologies\n- Live demo links\n- GitHub repository links\n- Image gallery/carousel\n\n## Interactive Elements\n- Smooth transitions between views\n- Filter animations\n- Image loading states\n- Interactive demos embedding\n\n## Data Structure\n```typescript\ninterface Project {\n  id: string;\n  title: string;\n  description: string;\n  technologies: string[];\n  images: {\n    thumbnail: string;\n    gallery: string[];\n  };\n  links: {\n    demo?: string;\n    github?: string;\n    live?: string;\n  };\n  category: string[];\n  featured: boolean;\n}\n```\n\n# Implementation Steps\n1. Create project data structure\n2. Implement project grid component\n3. Create project card component\n4. Build filtering system\n5. Implement project detail view\n6. Add animations and transitions"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "AllDgreE"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:41.144Z",
              "updated": "2024-12-20T18:52:41.144Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "projects",
                "portfolio",
                "interactive"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "rvxqxsd8"
          },
          {
            "id": "4ItyKXEL",
            "name": "Create Skills and Experience Sections",
            "description": "Implement interactive skills showcase and professional experience timeline",
            "notes": [
              {
                "type": "markdown",
                "content": "# Skills Section\n\n## Skill Categories\n- Frontend Development\n- Backend Development\n- DevOps & Tools\n- Soft Skills\n\n## Visual Elements\n- Skill progress indicators\n- Interactive skill cards\n- Category grouping\n- Skill level visualization\n\n# Experience Timeline\n\n## Timeline Features\n- Vertical/horizontal timeline layout\n- Company/role cards\n- Date ranges\n- Key achievements\n- Technologies used\n\n## Interactive Elements\n- Scroll animations\n- Hover effects\n- Expandable details\n- Filter by technology/skill\n\n## Data Structures\n```typescript\ninterface Skill {\n  name: string;\n  category: string;\n  level: number; // 1-5\n  description?: string;\n  icon?: string;\n  yearStarted: number;\n}\n\ninterface Experience {\n  company: string;\n  role: string;\n  startDate: string;\n  endDate?: string;\n  description: string;\n  achievements: string[];\n  technologies: string[];\n  logo?: string;\n}\n```\n\n# Implementation Steps\n1. Create data structures\n2. Implement skills grid/list\n3. Build experience timeline\n4. Add interactive features\n5. Implement responsive layouts\n6. Add animations and transitions"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "AllDgreE"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:52:50.632Z",
              "updated": "2024-12-20T18:52:50.632Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "skills",
                "experience",
                "timeline"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "rvxqxsd8"
          },
          {
            "id": "8CR6zCks",
            "name": "Implement Contact Form and Social Integration",
            "description": "Create an interactive contact form and integrate social media links",
            "notes": [
              {
                "type": "markdown",
                "content": "# Contact Form\n\n## Form Features\n- Input validation\n- Error handling\n- Success feedback\n- Anti-spam measures\n- Loading states\n\n## Form Fields\n```typescript\ninterface ContactForm {\n  name: string;\n  email: string;\n  subject: string;\n  message: string;\n  recaptcha?: string;\n}\n```\n\n## Technical Implementation\n- Form state management\n- Client-side validation\n- Email service integration (e.g., EmailJS, SendGrid)\n- Rate limiting\n- Error boundaries\n\n# Social Integration\n\n## Features\n- Social media links\n- Professional network links\n- GitHub profile integration\n- Social sharing buttons\n\n## Components\n- Social icons grid\n- Animated hover effects\n- Click tracking\n- Dynamic link handling\n\n# Implementation Steps\n1. Create contact form component\n2. Implement form validation\n3. Set up email service\n4. Add social media integration\n5. Implement error handling\n6. Add loading states and animations\n7. Test form submission\n8. Add analytics tracking\n\n# Best Practices\n- Implement proper form accessibility\n- Add proper ARIA labels\n- Ensure keyboard navigation\n- Provide clear feedback\n- Handle all error states\n- Implement proper security measures"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "AllDgreE"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:53:00.751Z",
              "updated": "2024-12-20T18:53:00.751Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "contact",
                "forms",
                "social-media",
                "integration"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "rvxqxsd8"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    },
    {
      "id": "HOjqKU2N",
      "name": "Performance Optimization",
      "description": "Optimization for speed, performance, and user experience",
      "notes": [
        {
          "type": "markdown",
          "content": "# Optimization Areas\n- Image optimization and lazy loading\n- Code splitting and bundling\n- Caching strategies\n- Performance monitoring\n- Core Web Vitals optimization"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "FIheWpfk"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:44.218Z",
        "updated": "2024-12-20T18:53:11.631Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "performance",
          "optimization",
          "web-vitals"
        ],
        "resolvedSubtasks": [
          {
            "id": "FIheWpfk",
            "name": "Implement Performance Optimizations",
            "description": "Optimize website performance focusing on Core Web Vitals and loading speed",
            "notes": [
              {
                "type": "markdown",
                "content": "# Core Web Vitals Optimization\n\n## Largest Contentful Paint (LCP)\n- Optimize image loading\n- Implement responsive images\n- Use WebP format with fallbacks\n- Optimize critical rendering path\n- Implement preloading for key resources\n\n## First Input Delay (FID)\n- Optimize JavaScript execution\n- Implement code splitting\n- Defer non-critical JavaScript\n- Minimize main thread work\n- Optimize event handlers\n\n## Cumulative Layout Shift (CLS)\n- Reserve space for dynamic content\n- Optimize font loading\n- Handle image dimensions\n- Manage layout shifts\n\n# Asset Optimization\n\n## Image Optimization\n```typescript\ninterface ImageOptimization {\n  formats: ['webp', 'avif', 'jpg'];\n  sizes: ['thumbnail', 'medium', 'large'];\n  loading: 'lazy' | 'eager';\n  dimensions: {\n    width: number;\n    height: number;\n  };\n}\n```\n\n## Resource Loading\n- Implement resource hints\n- Use dynamic imports\n- Optimize bundle size\n- Configure caching strategies\n\n# Implementation Steps\n1. Set up performance monitoring\n2. Implement image optimization pipeline\n3. Configure code splitting\n4. Optimize resource loading\n5. Implement caching strategy\n6. Set up performance testing\n\n# Metrics to Track\n- Core Web Vitals\n- Time to Interactive (TTI)\n- First Contentful Paint (FCP)\n- Speed Index\n- Total Blocking Time (TBT)"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "4ItyKXEL",
              "8CR6zCks",
              "NUD4rYDu"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:53:11.630Z",
              "updated": "2024-12-20T18:53:11.630Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "performance",
                "optimization",
                "web-vitals"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "HOjqKU2N"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    },
    {
      "id": "qNXLmR1P",
      "name": "Accessibility and Cross-browser Compatibility",
      "description": "Ensuring the site is accessible and works across all modern browsers",
      "notes": [
        {
          "type": "markdown",
          "content": "# Requirements\n- WCAG 2.1 compliance\n- Semantic HTML structure\n- Keyboard navigation\n- Screen reader compatibility\n- Cross-browser testing"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "hwVSfypx"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:49.048Z",
        "updated": "2024-12-20T18:53:22.938Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "accessibility",
          "a11y",
          "cross-browser",
          "testing"
        ],
        "resolvedSubtasks": [
          {
            "id": "hwVSfypx",
            "name": "Implement Accessibility and Cross-browser Support",
            "description": "Ensure WCAG compliance and consistent experience across browsers",
            "notes": [
              {
                "type": "markdown",
                "content": "# Accessibility Implementation\n\n## Semantic HTML\n- Use proper heading hierarchy\n- Implement ARIA landmarks\n- Add descriptive alt text\n- Use semantic HTML elements\n\n## Keyboard Navigation\n- Implement focus management\n- Add skip links\n- Ensure logical tab order\n- Style focus indicators\n\n## Screen Reader Support\n- Add ARIA labels\n- Implement live regions\n- Manage focus announcements\n- Test with screen readers\n\n## Color and Contrast\n- Ensure sufficient contrast ratios\n- Provide visible focus states\n- Test color blindness support\n- Implement high contrast mode\n\n# Cross-browser Testing\n\n## Browser Support Matrix\n```typescript\ninterface BrowserSupport {\n  browsers: {\n    chrome: string[];\n    firefox: string[];\n    safari: string[];\n    edge: string[];\n  };\n  features: {\n    name: string;\n    support: 'full' | 'partial' | 'none';\n    fallback?: string;\n  }[];\n}\n```\n\n## Testing Checklist\n- Layout consistency\n- Animation performance\n- Touch interactions\n- Form behavior\n- Media playback\n- Font rendering\n\n# Implementation Steps\n1. Implement semantic HTML structure\n2. Add ARIA attributes and roles\n3. Implement keyboard navigation\n4. Set up cross-browser testing\n5. Add fallbacks for unsupported features\n6. Test with accessibility tools\n\n# Testing Tools\n- WAVE Evaluation Tool\n- Axe DevTools\n- NVDA/VoiceOver\n- Lighthouse\n- BrowserStack\n- Cross-browser testing suite"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "FIheWpfk"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:53:22.937Z",
              "updated": "2024-12-20T18:53:22.937Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "accessibility",
                "a11y",
                "cross-browser",
                "testing"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "qNXLmR1P"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    },
    {
      "id": "GDatxR51",
      "name": "Deployment and Documentation",
      "description": "Site deployment, documentation, and maintenance plan",
      "notes": [
        {
          "type": "markdown",
          "content": "# Deployment Checklist\n- CI/CD pipeline setup\n- Domain configuration\n- SSL certification\n- Documentation\n- Backup strategy"
        }
      ],
      "type": "group",
      "status": "pending",
      "dependencies": [],
      "subtasks": [
        "jJU9mtgM"
      ],
      "metadata": {
        "created": "2024-12-20T18:51:53.339Z",
        "updated": "2024-12-20T18:53:33.815Z",
        "sessionId": "session-001",
        "taskListId": "task-001",
        "tags": [
          "deployment",
          "documentation",
          "devops"
        ],
        "resolvedSubtasks": [
          {
            "id": "jJU9mtgM",
            "name": "Set Up Deployment and Documentation",
            "description": "Configure deployment pipeline and create comprehensive documentation",
            "notes": [
              {
                "type": "markdown",
                "content": "# Deployment Configuration\n\n## CI/CD Pipeline\n- Set up GitHub Actions workflow\n- Configure build process\n- Implement automated testing\n- Set up deployment environments\n- Configure SSL/TLS\n\n## Deployment Environments\n```typescript\ninterface DeploymentConfig {\n  environments: {\n    development: {\n      url: string;\n      variables: Record<string, string>;\n    };\n    staging: {\n      url: string;\n      variables: Record<string, string>;\n    };\n    production: {\n      url: string;\n      variables: Record<string, string>;\n    };\n  };\n  buildConfig: {\n    command: string;\n    output: string;\n    optimization: boolean;\n  };\n}\n```\n\n# Documentation\n\n## Technical Documentation\n- Project setup guide\n- Architecture overview\n- Component documentation\n- API documentation\n- Performance guidelines\n\n## Maintenance Guide\n- Deployment procedures\n- Update processes\n- Backup procedures\n- Monitoring setup\n- Security guidelines\n\n## Content Management\n- Content update guide\n- Image optimization guide\n- SEO guidelines\n- Analytics setup\n\n# Implementation Steps\n1. Set up deployment pipeline\n2. Configure domain and SSL\n3. Set up monitoring tools\n4. Create technical documentation\n5. Write maintenance guides\n6. Set up backup procedures\n\n# Deployment Checklist\n- SSL configuration\n- DNS setup\n- Environment variables\n- Build optimization\n- Cache configuration\n- Security headers\n- Monitoring tools\n- Backup system\n- Analytics integration"
              }
            ],
            "type": "task",
            "status": "pending",
            "dependencies": [
              "hwVSfypx"
            ],
            "subtasks": [],
            "metadata": {
              "created": "2024-12-20T18:53:33.814Z",
              "updated": "2024-12-20T18:53:33.814Z",
              "sessionId": "session-001",
              "taskListId": "task-001",
              "tags": [
                "deployment",
                "documentation",
                "devops",
                "maintenance"
              ],
              "resolvedSubtasks": []
            },
            "parentId": "GDatxR51"
          }
        ]
      },
      "parentId": "ROOT-session-001"
    }
  ],
  "metadata": {
    "timestamp": "2024-12-20T18:53:38.418Z",
    "requestId": "zcIC0XQG",
    "sessionId": "session-001"
  }
}
```

</details>

## Tools

### Task Management

#### create_task
Creates a new task with path-based hierarchy and dependency management. Example:

```typescript
{
  "name": "Implement Authentication",
  "path": "server/auth",
  "description": "Implement secure user authentication system",
  "type": "milestone",
  "notes": [
    "# Authentication System\n- JWT-based auth\n- Password reset flow\n- Session management",
    "interface AuthConfig {\n  tokenExpiry: number;\n  maxAttempts: number;\n}"
  ],
  "reasoning": "Using JWT with Redis for scalable session management. Considered session-based auth but chose JWT for better scalability.",
  "metadata": {
    "priority": "high",
    "tags": ["security", "api"],
    "toolsUsed": ["read_file", "write_to_file"],
    "resourcesAccessed": ["src/auth/*"],
    "contextUsed": ["Security best practices"],
    "created": 1703094689310,
    "updated": 1703094734316,
    "projectPath": "server/auth",
    "version": 1
  }
}
```

Key Features:
- Path-based hierarchy (max 8 levels)
- Rich task metadata and context
- LLM operation tracking
- Dependency management
- Status propagation rules

Features:
- Hierarchical validation with depth limits
- Duplicate name prevention within parent
- Circular dependency detection
- Rich content validation
- Automatic index management
- Transaction-based creation
- Status propagation handling
- Cache-aware operations

#### bulk_create_tasks
Creates multiple tasks efficiently with optimized processing:

```typescript
{
  "parentId": string | null,  // Common parent for batch (null for root)
  "tasks": Array<{
    name: string,            // Task name (required, unique within parent)
    description?: string,    // Optional description
    notes?: Note[],         // Optional rich content notes
    reasoning?: TaskReasoning, // Optional decision documentation
    type?: TaskType,        // Optional task type (default: "task")
    dependencies?: string[], // Optional dependencies
    metadata?: {            // Optional metadata
      context?: string,
      tags?: string[]
    },
    subtasks?: CreateTaskInput[] // Optional nested tasks
  }>
}
```

Features:
- Parallel processing with configurable batch size
- Atomic transaction handling
- Bulk validation optimization
- Efficient index updates
- Automatic rollback on failure
- Status propagation batching
- Memory-efficient processing
- Real-time progress tracking

#### update_task
Updates an existing task with comprehensive validation and impact analysis:

```typescript
{
  "taskId": string,         // Task ID to update
  "updates": {
    "name"?: string,        // New name (unique within parent)
    "description"?: string, // New description
    "notes"?: Note[],      // Updated notes with validation
    "reasoning"?: TaskReasoning, // Updated decision documentation
    "type"?: TaskType,     // New type with validation
    "status"?: TaskStatus, // New status with transition validation
    "dependencies"?: string[], // Updated dependencies with validation
    "metadata"?: {         // Updated metadata
      "context"?: string,
      "tags"?: string[]
    }
  }
}
```

Features:
- Optimistic concurrency control
- State machine-based status transitions
- Intelligent status propagation
- Dependency impact analysis
- Transaction-based updates
- Automatic rollback on failure
- Cache synchronization
- Index maintenance
- History preservation

#### delete_task
Safely removes a task with comprehensive cleanup and impact management:

Features:
- Recursive subtask deletion with validation
- Dependency relationship cleanup
- Status propagation to dependent tasks
- Reference removal from indexes
- Transaction-based deletion
- Automatic rollback on failure
- Cache invalidation
- Impact analysis before deletion
- Dependent task blocking
- In-progress task protection

### Task Retrieval

#### get_task
Retrieves a task by ID with comprehensive context and optimizations:

Features:
- Complete task details with rich content validation
- Status information with transition history
- Dependency data with validation state
- Metadata inheritance and context chain
- Error context with recovery suggestions
- Multi-level cache utilization
- Index-based fast retrieval
- Automatic cache refresh
- Transaction consistency
- Cross-reference resolution

#### get_subtasks
Lists subtasks with hierarchical context and relationship tracking:

Features:
- Direct child task enumeration
- Status aggregation and inheritance
- Dependency relationship validation
- Metadata context propagation
- Hierarchical depth tracking
- Index-optimized retrieval
- Parallel data fetching
- Cache-aware operations
- Batch loading support
- Real-time updates

#### get_task_tree
Retrieves the complete task hierarchy with advanced features:

Features:
- Full task tree with depth limits (max 5)
- Status aggregation and inheritance
- Dependency graph resolution
- Metadata context merging
- Optimized batch loading
- Cache utilization strategy
- Parallel tree construction
- Memory-efficient processing
- Index-based acceleration
- Real-time tree updates

#### get_tasks_by_status
Filters tasks by status with comprehensive querying:

Features:
- Multi-dimensional status filtering
- Parent/child hierarchy support
- Dependency context validation
- Metadata-based filtering
- Session/list scoping
- Index-optimized retrieval
- Parallel query processing
- Cache-aware operations
- Memory-efficient results
- Real-time updates

### Session Management

#### create_session
Creates a new session with comprehensive management features:

```typescript
{
  "name": string,           // Session name (required, unique)
  "metadata": {            // Optional session metadata
    "tags": string[],      // Categorization tags
    "context": string,     // Session context
    "created": string,     // Creation timestamp
    "updated": string,     // Last update timestamp
    "stats": {             // Session statistics
      "taskCount": number,
      "completedTasks": number,
      "activeTaskLists": number
    }
  }
}
```

Features:
- Unique session name validation
- Automatic ID generation
- Transaction-based creation
- Metadata indexing
- Statistics tracking
- Cache initialization
- Cross-session relationship handling
- Cleanup scheduling

#### create_task_list
Creates a task list with advanced organization features:

```typescript
{
  "name": string,           // List name (required, unique in session)
  "description": string,    // List description
  "metadata": {            // Optional metadata
    "tags": string[],      // Categorization tags
    "context": string,     // List context
    "created": string,     // Creation timestamp
    "updated": string,     // Last update timestamp
    "stats": {             // List statistics
      "taskCount": number,
      "completedTasks": number,
      "activeSubtasks": number
    }
  },
  "persistent": boolean    // Cross-session persistence
}
```

Features:
- Session-scoped uniqueness validation
- Automatic ID generation
- Transaction-based creation
- Metadata indexing
- Statistics tracking
- Cache initialization
- Cross-list relationship handling
- Cleanup scheduling

#### switch_session
Switches sessions with state preservation:

Features:
- Session existence validation
- State transition management
- Task context preservation
- Active session updating
- Cache synchronization
- Index updating
- Transaction handling
- Cross-session relationship maintenance
- Statistics updating
- Cleanup scheduling

#### switch_task_list
Switches task lists with context management:

Features:
- List existence validation
- State transition handling
- Context preservation
- Active list updating
- Cache synchronization
- Index updating
- Transaction handling
- Cross-list relationship maintenance
- Statistics updating
- Cleanup scheduling

#### list_sessions
Lists sessions with comprehensive information:

Features:
- Optional archive inclusion
- Rich metadata retrieval
- Statistics aggregation
- Creation/update tracking
- Task list summaries
- Cache utilization
- Parallel processing
- Memory optimization
- Real-time updates
- Filtering capabilities

#### list_task_lists
Lists task lists with detailed context:

Features:
- Optional archive inclusion
- Rich metadata retrieval
- Task statistics
- Status aggregation
- Cache utilization
- Parallel processing
- Memory optimization
- Real-time updates
- Filtering support
- Cross-reference resolution

### Storage Operations

#### Task Storage
- SQLite-based persistence with WAL mode
- ACID-compliant transactions
- Optimistic concurrency control
- Automatic schema migrations
- Connection pooling with retry logic
- Comprehensive error recovery
- Data integrity validation
- Checksum verification
- Efficient batch operations
- Recursive subtask support

#### Session Storage
- Session state persistence
- Task list management
- Active state tracking
- Cross-session relationships
- State transition validation
- Metadata indexing
- Statistics tracking
- Cache initialization
- Cleanup scheduling
- Real-time updates

#### Maintenance Operations
- Automated database analysis
- WAL checkpoint management
- Storage space optimization
- Index maintenance
- Backup rotation
- Resource monitoring
- Performance metrics
- Storage estimation
- Data persistence verification
- Directory structure management

### System Features

#### Rate Limiting
- 100 requests per minute limit
- Automatic request throttling
- Queue management
- Error handling
- Client feedback

#### Health Monitoring
- Component Health Checks
  * Storage system monitoring
  * Rate limiter status
  * Metrics system health
  * Component-level status tracking
  * Real-time health indicators

- Metrics Collection
  * Request count tracking
  * Error rate monitoring (10% threshold)
  * Average duration calculation
  * Per-tool metrics tracking
  * Error frequency analysis

- Rate Limiting
  * 60-second window tracking
  * Request count monitoring
  * Limit enforcement
  * Automatic request throttling
  * Status reporting

- Health Status Reporting
  * Component-level health status
  * Detailed error reporting
  * Timestamp-based tracking
  * Health check aggregation
  * System status overview

#### Performance Metrics
- Request Tracking
  * Success/failure counting
  * Duration measurements
  * Tool-specific metrics
  * Error categorization
  * Hourly statistics

- Tool Analytics
  * Per-tool success rates
  * Average operation duration
  * Error frequency tracking
  * Usage patterns
  * Performance trends

- System Metrics
  * Storage system stats
  * Memory usage tracking
  * Request rate monitoring
  * Component health status
  * Resource utilization

#### Error Handling
ATLAS provides comprehensive error handling:
- Validation errors with context
- Dependency conflict detection
- Task state inconsistencies
- System resource issues
- Transaction failures
- Rate limit violations
- Request timeout handling

## Best Practices

### Task Management
- Create parent tasks before subtasks
- Use task IDs for dependencies
- Provide clear context in metadata
- Use appropriate task types
- Document reasoning and assumptions
- Handle status transitions carefully
- Monitor dependency relationships
- Maintain task hierarchy

### Content Organization
- Use appropriate note types
- Include relevant code samples
- Maintain clear documentation
- Document decision-making process
- Keep metadata current
- Tag tasks appropriately
- Structure hierarchies logically

### Performance Optimization
- Use bulk operations for multiple tasks
- Monitor rate limits
- Handle long-running operations
- Implement proper error handling
- Optimize task retrieval
- Cache frequently accessed data
- Clean up completed tasks

### Error Recovery
- Handle validation errors gracefully
- Resolve dependency conflicts
- Manage status inconsistencies
- Recover from system issues
- Maintain data integrity
- Document error contexts
- Implement retry strategies

## Development

```bash
# Build the project
npm run build

# Watch for changes
npm run watch

# Run MCP inspector
npm run inspector

# Run tests
npm test

# Check types
npm run type-check
```

## Up Next

### Advanced Task Features
- Task templating system
- Task state machine customization
- Advanced task filtering
- Task history tracking
- Task archival system
- Task import/export

### Integration Capabilities
- Webhook support
- Event streaming
- External system integration
- Plugin architecture
- API versioning
- Custom tool support

### Performance Optimizations
- Query plan optimization
- Index usage analysis
- Transaction batching
- Parallel task processing
- Background task cleanup
- Resource usage analytics

### Monitoring Enhancements
- Real-time metrics dashboard
- Performance trend analysis
- Anomaly detection
- Resource usage alerts
- System health reporting
- Operational insights

### Developer Tools
- Task debugging utilities
- Development console
- Performance profiling
- Testing framework
- Documentation generator
- Schema validation tools

## Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

For bugs and feature requests, please [create an issue](https://github.com/cyanheads/atlas-mcp-server/issues).

## License

Apache License 2.0

---

<div align="center">
Built with the Model Context Protocol
</div>

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "build",
    "declaration": true,
    "sourceMap": true,
    "inlineSources": true,
    "resolveJsonModule": true,
    "rootDir": "src",
    "noImplicitAny": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "removeComments": false,
    "preserveConstEnums": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "build", "**/*.test.ts"]
}
