diff --git a/repo-tree.md b/repo-tree.md
index 3c570d2..47a2380 100644
--- a/repo-tree.md
+++ b/repo-tree.md
@@ -5,11 +5,25 @@
 |   |-- config/
 |   |   `-- index.ts
 |   |-- errors/
-|   |   `-- index.ts
+|   |   |-- README.md
+|   |   |-- base-error.ts
+|   |   |-- config-error.ts
+|   |   |-- error-factory.ts
+|   |   |-- index.ts
+|   |   |-- storage-error.ts
+|   |   |-- task-error.ts
+|   |   `-- tool-error.ts
 |   |-- events/
-|   |   `-- event-manager.ts
+|   |   |-- batch-processor.ts
+|   |   |-- event-manager.ts
+|   |   `-- health-monitor.ts
 |   |-- logging/
-|   |   `-- index.ts
+|   |   |-- error-formatter.ts
+|   |   |-- file-transport.ts
+|   |   |-- health-monitor.ts
+|   |   |-- index.ts
+|   |   |-- logger.ts
+|   |   `-- transport-manager.ts
 |   |-- server/
 |   |   |-- health-monitor.ts
 |   |   |-- index.ts
@@ -37,11 +51,15 @@
 |   |   |   |-- wal/
 |   |   |   |   `-- manager.ts
 |   |   |   `-- index.ts
+|   |   |-- factory/
+|   |   |   `-- error-handler.ts
 |   |   |-- monitoring/
 |   |   |   |-- health.ts
 |   |   |   |-- index.ts
 |   |   |   `-- metrics.ts
 |   |   |-- sqlite/
+|   |   |   |-- config.ts
+|   |   |   |-- error-handler.ts
 |   |   |   |-- index.ts
 |   |   |   |-- init.ts
 |   |   |   `-- storage.ts
@@ -70,17 +88,34 @@
 |   |   |   |   `-- index.ts
 |   |   |   |-- transactions/
 |   |   |   |   |-- index.ts
-|   |   |   |   |-- transaction-manager.ts
-|   |   |   |   `-- transaction-types.ts
+|   |   |   |   `-- transaction-manager.ts
+|   |   |   |-- error-handler.ts
 |   |   |   |-- index.ts
 |   |   |   `-- task-store.ts
+|   |   |-- manager/
+|   |   |   |-- error-handler.ts
+|   |   |   |-- index.ts
+|   |   |   `-- task-manager.ts
 |   |   |-- operations/
 |   |   |   |-- index.ts
 |   |   |   `-- task-operations.ts
 |   |   `-- validation/
+|   |       |-- schemas/
+|   |       |   |-- base-schema.ts
+|   |       |   |-- create-schema.ts
+|   |       |   |-- index.ts
+|   |       |   |-- metadata-schema.ts
+|   |       |   `-- update-schema.ts
+|   |       |-- utils/
+|   |       |-- validators/
+|   |       |   |-- dependency-validator.ts
+|   |       |   |-- hierarchy-validator.ts
+|   |       |   |-- index.ts
+|   |       |   `-- status-validator.ts
 |   |       |-- index.ts
 |   |       `-- task-validator.ts
 |   |-- tools/
+|   |   |-- error-handler.ts
 |   |   |-- handler.ts
 |   |   |-- index.ts
 |   |   |-- schemas.ts
@@ -114,9 +149,11 @@
 |   `-- task-manager.ts
 |-- LICENSE
 |-- README.md
+|-- improvements-v2.md
 |-- jest.config.js
 |-- package.json
 |-- repo-tree.md
+|-- repomix-output.txt
 `-- tsconfig.json
 
-29 directories, 89 files
+34 directories, 121 files
diff --git a/src/config/index.ts b/src/config/index.ts
index 5d10b6d..848110f 100644
--- a/src/config/index.ts
+++ b/src/config/index.ts
@@ -5,6 +5,7 @@
 
 import { ConfigError, ErrorCodes } from '../errors/index.js';
 import { LogLevel, LogLevels } from '../types/logging.js';
+import { ErrorContext, ErrorSeverity } from '../types/error.js';
 import { resolve, join } from 'path';
 import { homedir } from 'os';
 
@@ -64,122 +65,18 @@ export interface StorageConfig {
 export interface AppConfig {
     env: string;
     logging: LoggingConfig;
-    storage: StorageConfig;  // Make storage required
+    storage: StorageConfig;
 }
 
+/**
+ * Partial application configuration type
+ */
 export interface PartialAppConfig {
     env?: string;
     logging?: Partial<LoggingConfig>;
     storage?: Partial<StorageConfig>;
 }
 
-/**
- * Configuration schema
- */
-export const configSchema = {
-    env: {
-        type: 'string',
-        enum: [
-            Environments.DEVELOPMENT,
-            Environments.PRODUCTION,
-            Environments.TEST
-        ],
-        default: Environments.DEVELOPMENT
-    },
-    logging: {
-        type: 'object',
-        properties: {
-            level: {
-                type: 'string',
-                enum: Object.values(LogLevels),
-                default: LogLevels.INFO
-            },
-            console: {
-                type: 'boolean',
-                default: true
-            },
-            file: {
-                type: 'boolean',
-                default: false
-            },
-            dir: {
-                type: 'string',
-                optional: true
-            },
-            maxFiles: {
-                type: 'number',
-                minimum: 1,
-                default: 5
-            },
-            maxSize: {
-                type: 'number',
-                minimum: 1024,
-                default: 5242880 // 5MB
-            }
-        },
-        required: ['level']
-    },
-    storage: {
-        type: 'object',
-        properties: {
-            baseDir: {
-                type: 'string'
-            },
-            name: {
-                type: 'string'
-            },
-            connection: {
-                type: 'object',
-                properties: {
-                    maxRetries: {
-                        type: 'number',
-                        minimum: 1,
-                        optional: true
-                    },
-                    retryDelay: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    },
-                    busyTimeout: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    }
-                },
-                optional: true
-            },
-            performance: {
-                type: 'object',
-                properties: {
-                    checkpointInterval: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    },
-                    cacheSize: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    },
-                    mmapSize: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    },
-                    pageSize: {
-                        type: 'number',
-                        minimum: 0,
-                        optional: true
-                    }
-                },
-                optional: true
-            }
-        },
-        required: ['baseDir', 'name']
-    }
-};
-
 /**
  * Default logging configuration
  */
@@ -232,6 +129,22 @@ export class ConfigManager {
         this.config = defaultConfig;
     }
 
+    /**
+     * Creates an error context
+     */
+    private static createErrorContext(
+        operation: string,
+        metadata?: Record<string, unknown>
+    ): ErrorContext {
+        return {
+            operation,
+            timestamp: Date.now(),
+            severity: ErrorSeverity.HIGH,
+            metadata,
+            stackTrace: new Error().stack
+        };
+    }
+
     /**
      * Gets the configuration manager instance
      */
@@ -239,7 +152,8 @@ export class ConfigManager {
         if (!ConfigManager.instance || !ConfigManager.instance.initialized) {
             throw new ConfigError(
                 ErrorCodes.CONFIG_INVALID,
-                'Configuration not initialized. Call ConfigManager.initialize() first.'
+                'Configuration not initialized. Call ConfigManager.initialize() first.',
+                this.createErrorContext('ConfigManager.getInstance')
             );
         }
         return ConfigManager.instance;
@@ -276,7 +190,8 @@ export class ConfigManager {
             } catch (error) {
                 throw new ConfigError(
                     ErrorCodes.CONFIG_INVALID,
-                    `Failed to initialize configuration: ${error instanceof Error ? error.message : String(error)}`
+                    `Failed to initialize configuration: ${error instanceof Error ? error.message : String(error)}`,
+                    this.createErrorContext('ConfigManager.initialize', { error })
                 );
             } finally {
                 ConfigManager.initializationPromise = null;
@@ -378,7 +293,11 @@ export class ConfigManager {
         } catch (error) {
             throw new ConfigError(
                 ErrorCodes.CONFIG_INVALID,
-                `Failed to create storage directory: ${error instanceof Error ? error.message : String(error)}`
+                `Failed to create storage directory: ${error instanceof Error ? error.message : String(error)}`,
+                ConfigManager.createErrorContext('ConfigManager.loadEnvConfig', {
+                    storageDir,
+                    error
+                })
             );
         }
 
@@ -406,7 +325,10 @@ export class ConfigManager {
             if (!Object.values(Environments).includes(currentEnv as any)) {
                 throw new ConfigError(
                     ErrorCodes.CONFIG_INVALID,
-                    'Invalid environment'
+                    'Invalid environment',
+                    ConfigManager.createErrorContext('ConfigManager.loadEnvConfig', {
+                        currentEnv
+                    })
                 );
             }
             config.env = currentEnv;
@@ -417,7 +339,10 @@ export class ConfigManager {
             if (!Object.values(LogLevels).includes(level as any)) {
                 throw new ConfigError(
                     ErrorCodes.CONFIG_INVALID,
-                    'Invalid log level'
+                    'Invalid log level',
+                    ConfigManager.createErrorContext('ConfigManager.loadEnvConfig', {
+                        currentLogLevel
+                    })
                 );
             }
             config.logging.level = level as LogLevel;
@@ -433,21 +358,31 @@ export class ConfigManager {
         if (!config.storage?.baseDir) {
             throw new ConfigError(
                 ErrorCodes.CONFIG_MISSING,
-                'Storage directory must be provided'
+                'Storage directory must be provided',
+                ConfigManager.createErrorContext('ConfigManager.validateConfig', {
+                    config
+                })
             );
         }
 
         if (!config.storage?.name) {
             throw new ConfigError(
                 ErrorCodes.CONFIG_MISSING,
-                'Storage name must be provided'
+                'Storage name must be provided',
+                ConfigManager.createErrorContext('ConfigManager.validateConfig', {
+                    config
+                })
             );
         }
 
         if (config.logging?.level && !Object.values(LogLevels).includes(config.logging.level)) {
             throw new ConfigError(
                 ErrorCodes.CONFIG_INVALID,
-                'Invalid log level'
+                'Invalid log level',
+                ConfigManager.createErrorContext('ConfigManager.validateConfig', {
+                    level: config.logging.level,
+                    validLevels: Object.values(LogLevels)
+                })
             );
         }
     }
diff --git a/src/errors/index.ts b/src/errors/index.ts
index 799b48d..2aef716 100644
--- a/src/errors/index.ts
+++ b/src/errors/index.ts
@@ -1,159 +1,54 @@
-/**
- * Error codes and error creation utility
- */
-export const ErrorCodes = {
-    // Migration errors
-    MIGRATION_ERROR: 'MIGRATION_1001',
-    // Task errors (1000-1999)
-    TASK_NOT_FOUND: 'TASK_1001',
-    TASK_VALIDATION: 'TASK_1002',
-    TASK_DEPENDENCY: 'TASK_1003',
-    TASK_STATUS: 'TASK_1004',
-    TASK_DUPLICATE: 'TASK_1005',
-    TASK_CYCLE: 'TASK_1006',
-    TASK_INVALID_PATH: 'TASK_1007',
-    TASK_PARENT_NOT_FOUND: 'TASK_1008',
-    TASK_PARENT_TYPE: 'TASK_1009',
-
-    // Storage errors (2000-2999)
-    STORAGE_ERROR: 'STORAGE_2001',
-    STORAGE_READ: 'STORAGE_2002',
-    STORAGE_WRITE: 'STORAGE_2003',
-    STORAGE_DELETE: 'STORAGE_2004',
-    STORAGE_INIT: 'STORAGE_2005',
-    STORAGE_CLOSE: 'STORAGE_2006',
-
-    // Transaction errors (3000-3999)
-    TRANSACTION_ERROR: 'TRANSACTION_3001',
-    TRANSACTION_TIMEOUT: 'TRANSACTION_3002',
-    TRANSACTION_DEADLOCK: 'TRANSACTION_3003',
-    TRANSACTION_ROLLBACK: 'TRANSACTION_3004',
-    TRANSACTION_COMMIT: 'TRANSACTION_3005',
-    TRANSACTION_ISOLATION: 'TRANSACTION_3006',
-    TRANSACTION_NESTED: 'TRANSACTION_3007',
-
-    // Connection errors (4000-4999)
-    CONNECTION_ERROR: 'CONNECTION_4001',
-    CONNECTION_TIMEOUT: 'CONNECTION_4002',
-    CONNECTION_LIMIT: 'CONNECTION_4003',
-    CONNECTION_CLOSED: 'CONNECTION_4004',
-    CONNECTION_BUSY: 'CONNECTION_4005',
-
-    // Operation errors (5000-5999)
-    INVALID_INPUT: 'OPERATION_5001',
-    INVALID_STATE: 'OPERATION_5002',
-    CONCURRENT_MODIFICATION: 'OPERATION_5003',
-    INTERNAL_ERROR: 'OPERATION_5004',
-    TIMEOUT: 'OPERATION_5005',
-    OPERATION_FAILED: 'OPERATION_5006',
-    VALIDATION_ERROR: 'OPERATION_5007',
-
-    // Configuration errors (6000-6999)
-    CONFIG_INVALID: 'CONFIG_6001',
-    CONFIG_MISSING: 'CONFIG_6002'
-} as const;
+import { BaseError } from './base-error.js';
+import { ConfigError } from './config-error.js';
+import { TaskError } from './task-error.js';
+import { StorageError } from './storage-error.js';
+import { ToolError } from './tool-error.js';
+import { ErrorFactory } from './error-factory.js';
+import { ErrorCode, ErrorCodes as TypedErrorCodes } from '../types/error.js';
 
-export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];
-
-export interface ErrorDetails {
-    code: ErrorCode;
-    message: string;
-    operation?: string;
-    cause?: string;
-    details?: Record<string, unknown>;
-}
-
-export class BaseError extends Error {
-    readonly code: ErrorCode;
-    readonly operation?: string;
-    readonly details?: Record<string, unknown>;
-
-    constructor(details: ErrorDetails) {
-        super(details.message);
-        this.name = 'BaseError';
-        this.code = details.code;
-        this.operation = details.operation;
-        this.details = details.details;
-    }
+// Re-export error types and utilities
+export { BaseError, ConfigError, TaskError, StorageError, ToolError, ErrorFactory };
 
-    getUserMessage(): string {
-        return this.message;
-    }
+// Export error codes enum
+export const ErrorCodes = TypedErrorCodes;
 
-    toJSON(): Record<string, unknown> {
-        return {
-            code: this.code,
-            message: this.message,
-            operation: this.operation,
-            details: this.details
-        };
-    }
-}
-
-/**
- * Create a standardized error with proper code and context
- */
-export class ConfigError extends BaseError {
-    constructor(code: ErrorCode, message: string, details?: Record<string, unknown>) {
-        super({
-            code,
-            message,
-            details
-        });
-        this.name = 'ConfigError';
-    }
-}
-
-export function createError(
-    code: ErrorCode,
-    message: string,
-    operation?: string,
-    cause?: string,
-    details?: Record<string, unknown>
-): BaseError {
-    const fullMessage = cause ? `${message}: ${cause}` : message;
-    return new BaseError({
-        code,
-        message: fullMessage,
-        operation,
-        details
-    });
-}
-
-/**
- * Check if an error is a specific type
- */
-export function isErrorType(error: unknown, code: ErrorCode): boolean {
-    return error instanceof BaseError && error.code === code;
-}
-
-/**
- * Retryable error codes
- */
-export const RetryableErrorCodes = {
-    CONNECTION_BUSY: ErrorCodes.CONNECTION_BUSY,
-    TRANSACTION_DEADLOCK: ErrorCodes.TRANSACTION_DEADLOCK,
-    CONNECTION_TIMEOUT: ErrorCodes.CONNECTION_TIMEOUT,
-    STORAGE_ERROR: ErrorCodes.STORAGE_ERROR
-} as const;
+// Export error code type
+export type { ErrorCode };
+
+// Export error factory function
+export const createError = ErrorFactory.createError.bind(ErrorFactory);
+
+// Export error utilities
+export const isBaseError = (error: unknown): error is BaseError => {
+    return error instanceof BaseError;
+};
 
-export type RetryableErrorCode = typeof RetryableErrorCodes[keyof typeof RetryableErrorCodes];
+export const isConfigError = (error: unknown): error is ConfigError => {
+    return error instanceof ConfigError;
+};
 
-/**
- * Check if an error is retryable
- */
-export function isRetryableError(error: unknown): boolean {
-    if (!(error instanceof BaseError)) return false;
+export const isTaskError = (error: unknown): error is TaskError => {
+    return error instanceof TaskError;
+};
 
-    return Object.values(RetryableErrorCodes).includes(error.code as RetryableErrorCode);
-}
+export const isStorageError = (error: unknown): error is StorageError => {
+    return error instanceof StorageError;
+};
 
-/**
- * Format error for logging
- */
-export function formatError(error: unknown): Record<string, unknown> {
+export const isToolError = (error: unknown): error is ToolError => {
+    return error instanceof ToolError;
+};
+
+export const formatError = (error: unknown): Record<string, unknown> => {
     if (error instanceof BaseError) {
-        return error.toJSON();
+        return {
+            code: error.code,
+            message: error.message,
+            operation: error.getOperation(),
+            userMessage: error.getUserMessage(),
+            metadata: error.getMetadata(),
+            stack: error.stack
+        };
     }
 
     if (error instanceof Error) {
@@ -164,7 +59,161 @@ export function formatError(error: unknown): Record<string, unknown> {
         };
     }
 
-    return {
-        message: String(error)
-    };
-}
+    return { error };
+};
+
+export const getErrorCode = (error: unknown): ErrorCode => {
+    if (error instanceof BaseError) {
+        return error.code;
+    }
+    return ErrorCodes.INTERNAL_ERROR;
+};
+
+export const getErrorMessage = (error: unknown): string => {
+    if (error instanceof BaseError) {
+        return error.getUserMessage() || error.message;
+    }
+    if (error instanceof Error) {
+        return error.message;
+    }
+    return String(error);
+};
+
+// Export error creation helpers
+export const createTaskError = TaskError;
+export const createConfigError = ConfigError;
+export const createStorageError = StorageError;
+export const createToolError = ToolError;
+
+// Define error code arrays with proper typing
+const taskErrorCodes = [
+    ErrorCodes.TASK_NOT_FOUND,
+    ErrorCodes.TASK_VALIDATION,
+    ErrorCodes.TASK_DEPENDENCY,
+    ErrorCodes.TASK_STATUS,
+    ErrorCodes.TASK_DUPLICATE,
+    ErrorCodes.TASK_INVALID_TYPE,
+    ErrorCodes.TASK_INVALID_STATUS,
+    ErrorCodes.TASK_INVALID_PARENT,
+    ErrorCodes.TASK_OPERATION_FAILED,
+    ErrorCodes.TASK_INVALID_PATH,
+    ErrorCodes.TASK_PARENT_NOT_FOUND,
+    ErrorCodes.TASK_PARENT_TYPE,
+    ErrorCodes.TASK_CYCLE
+] as const;
+
+const configErrorCodes = [
+    ErrorCodes.CONFIG_MISSING,
+    ErrorCodes.CONFIG_INVALID,
+    ErrorCodes.CONFIG_TYPE,
+    ErrorCodes.CONFIG_VALIDATION,
+    ErrorCodes.CONFIG_REQUIRED
+] as const;
+
+const storageErrorCodes = [
+    ErrorCodes.STORAGE_READ,
+    ErrorCodes.STORAGE_WRITE,
+    ErrorCodes.STORAGE_INIT,
+    ErrorCodes.STORAGE_DELETE,
+    ErrorCodes.STORAGE_PERMISSION,
+    ErrorCodes.STORAGE_NOT_FOUND,
+    ErrorCodes.STORAGE_TRANSACTION,
+    ErrorCodes.STORAGE_ROLLBACK,
+    ErrorCodes.STORAGE_COMMIT,
+    ErrorCodes.STORAGE_ERROR,
+    ErrorCodes.DATABASE_ERROR
+] as const;
+
+const toolErrorCodes = [
+    ErrorCodes.TOOL_NOT_FOUND,
+    ErrorCodes.TOOL_EXECUTION,
+    ErrorCodes.TOOL_VALIDATION,
+    ErrorCodes.TOOL_TIMEOUT,
+    ErrorCodes.TOOL_PERMISSION
+] as const;
+
+const systemErrorCodes = [
+    ErrorCodes.INTERNAL_ERROR,
+    ErrorCodes.INVALID_INPUT,
+    ErrorCodes.OPERATION_FAILED,
+    ErrorCodes.VALIDATION_ERROR,
+    ErrorCodes.PERMISSION_DENIED,
+    ErrorCodes.NOT_IMPLEMENTED,
+    ErrorCodes.TIMEOUT,
+    ErrorCodes.TIMEOUT_ERROR,
+    ErrorCodes.CONCURRENCY_ERROR
+] as const;
+
+// Export error categories
+export const ErrorCategories = {
+    TASK: taskErrorCodes,
+    CONFIG: configErrorCodes,
+    STORAGE: storageErrorCodes,
+    TOOL: toolErrorCodes,
+    SYSTEM: systemErrorCodes
+} as const;
+
+export type ErrorCategory = keyof typeof ErrorCategories;
+
+// Export error category helpers
+export const getErrorCategory = (code: ErrorCode): ErrorCategory | undefined => {
+    for (const [category, codes] of Object.entries(ErrorCategories)) {
+        if ((codes as readonly ErrorCode[]).includes(code)) {
+            return category as ErrorCategory;
+        }
+    }
+    return undefined;
+};
+
+export const isTaskErrorCode = (code: ErrorCode): boolean => {
+    return taskErrorCodes.includes(code as typeof taskErrorCodes[number]);
+};
+
+export const isConfigErrorCode = (code: ErrorCode): boolean => {
+    return configErrorCodes.includes(code as typeof configErrorCodes[number]);
+};
+
+export const isStorageErrorCode = (code: ErrorCode): boolean => {
+    return storageErrorCodes.includes(code as typeof storageErrorCodes[number]);
+};
+
+export const isToolErrorCode = (code: ErrorCode): boolean => {
+    return toolErrorCodes.includes(code as typeof toolErrorCodes[number]);
+};
+
+export const isSystemErrorCode = (code: ErrorCode): boolean => {
+    return systemErrorCodes.includes(code as typeof systemErrorCodes[number]);
+};
+
+// Export error type guards
+export const isTaskNotFoundError = (error: unknown): error is TaskError => {
+    return isTaskError(error) && error.code === ErrorCodes.TASK_NOT_FOUND;
+};
+
+export const isTaskValidationError = (error: unknown): error is TaskError => {
+    return isTaskError(error) && error.code === ErrorCodes.TASK_VALIDATION;
+};
+
+export const isStorageInitError = (error: unknown): error is StorageError => {
+    return isStorageError(error) && error.code === ErrorCodes.STORAGE_INIT;
+};
+
+export const isDatabaseError = (error: unknown): error is StorageError => {
+    return isStorageError(error) && error.code === ErrorCodes.DATABASE_ERROR;
+};
+
+export const isConfigValidationError = (error: unknown): error is ConfigError => {
+    return isConfigError(error) && error.code === ErrorCodes.CONFIG_VALIDATION;
+};
+
+export const isToolExecutionError = (error: unknown): error is ToolError => {
+    return isToolError(error) && error.code === ErrorCodes.TOOL_EXECUTION;
+};
+
+export const isToolTimeoutError = (error: unknown): error is ToolError => {
+    return isToolError(error) && error.code === ErrorCodes.TOOL_TIMEOUT;
+};
+
+export const isPermissionError = (error: unknown): error is BaseError => {
+    return isBaseError(error) && error.code === ErrorCodes.PERMISSION_DENIED;
+};
diff --git a/src/events/event-manager.ts b/src/events/event-manager.ts
index d6a43f4..59809c9 100644
--- a/src/events/event-manager.ts
+++ b/src/events/event-manager.ts
@@ -1,5 +1,7 @@
 import { EventEmitter } from 'events';
 import { Logger } from '../logging/index.js';
+import { EventHealthMonitor } from './health-monitor.js';
+import { EventBatchProcessor } from './batch-processor.js';
 import {
   AtlasEvent,
   EventHandler,
@@ -10,7 +12,8 @@ import {
   ErrorEvent,
   BatchEvent,
   TransactionEvent,
-  SystemEvent
+  SystemEvent,
+  EventHandlerOptions
 } from '../types/events.js';
 
 export class EventManager {
@@ -21,19 +24,75 @@ export class EventManager {
   private readonly maxListeners: number = 100;
   private readonly debugMode: boolean;
   private initialized = false;
-
-  private static initLogger(): void {
-    if (!EventManager.logger) {
-      EventManager.logger = Logger.getInstance().child({ component: 'EventManager' });
-    }
+  private readonly activeSubscriptions = new Set<EventSubscription>();
+  private readonly eventStats = new Map<EventTypes | '*', {
+    emitted: number;
+    handled: number;
+    errors: number;
+    lastEmitted?: number;
+  }>();
+  private readonly healthMonitor: EventHealthMonitor;
+  private readonly batchProcessor: EventBatchProcessor;
+  private cleanupTimeout?: NodeJS.Timeout;
+  private readonly CLEANUP_INTERVAL = 60000; // 1 minute
+
+  setLogger(logger: Logger): void {
+    EventManager.logger = logger.child({ component: 'EventManager' });
   }
 
   private constructor() {
-    EventManager.initLogger();
+    // Don't initialize logger in constructor to avoid circular dependency
     this.emitter = new EventEmitter();
     this.emitter.setMaxListeners(this.maxListeners);
     this.debugMode = process.env.NODE_ENV === 'development';
+    this.healthMonitor = new EventHealthMonitor();
+    this.batchProcessor = new EventBatchProcessor({
+      maxBatchSize: 100,
+      maxWaitTime: 1000,
+      flushInterval: 5000
+    });
     this.setupErrorHandling();
+    this.startCleanupInterval();
+  }
+
+  private startCleanupInterval(): void {
+    // Clear any existing interval
+    if (this.cleanupTimeout) {
+      clearInterval(this.cleanupTimeout);
+    }
+
+    // Set up cleanup interval with weak reference
+    const weakThis = new WeakRef(this);
+    this.cleanupTimeout = setInterval(() => {
+      const instance = weakThis.deref();
+      if (!instance) {
+        // If instance is garbage collected, stop interval
+        if (this.cleanupTimeout) {
+          clearInterval(this.cleanupTimeout);
+        }
+        return;
+      }
+
+      instance.cleanupStaleStats();
+    }, this.CLEANUP_INTERVAL);
+
+    // Ensure interval is cleaned up if process exits
+    process.on('beforeExit', () => {
+      if (this.cleanupTimeout) {
+        clearInterval(this.cleanupTimeout);
+      }
+    });
+  }
+
+  private cleanupStaleStats(): void {
+    const now = Date.now();
+    const STALE_THRESHOLD = 24 * 60 * 60 * 1000; // 24 hours
+
+    for (const [type, stats] of this.eventStats.entries()) {
+      if (stats.lastEmitted && (now - stats.lastEmitted > STALE_THRESHOLD)) {
+        this.eventStats.delete(type);
+      }
+    }
   }
 
   static async initialize(): Promise<EventManager> {
@@ -55,8 +114,9 @@ export class EventManager {
           return EventManager.instance;
         }
 
-        EventManager.instance = new EventManager();
-        EventManager.instance.initialized = true;
+        const instance = new EventManager();
+        instance.initialized = true;
+        EventManager.instance = instance;
         return EventManager.instance;
       } catch (error) {
         throw new Error(`Failed to initialize EventManager: ${error instanceof Error ? error.message : String(error)}`);
@@ -75,12 +135,13 @@ export class EventManager {
     return EventManager.instance;
   }
 
-  emit<T extends AtlasEvent>(event: T): void {
+  emit<T extends AtlasEvent>(event: T, options?: { batch?: boolean }): boolean {
     try {
       if (this.debugMode) {
         const debugInfo: Record<string, unknown> = {
           type: event.type,
-          timestamp: event.timestamp
+          timestamp: event.timestamp,
+          batch: options?.batch
         };
 
         // Handle different event types' metadata/context
@@ -90,7 +151,11 @@ export class EventManager {
           debugInfo.context = event.context;
         }
 
-        EventManager.logger.debug('Emitting event', debugInfo);
+        if (EventManager.logger) {
+          EventManager.logger.debug('Emitting event', debugInfo);
+        } else {
+          console.debug('Emitting event', debugInfo);
+        }
       }
 
       // Add timestamp if not present
@@ -98,111 +163,314 @@ export class EventManager {
         event.timestamp = Date.now();
       }
 
-      this.emitter.emit(event.type, event);
+      // Update event stats
+      const stats = this.eventStats.get(event.type) || { emitted: 0, handled: 0, errors: 0 };
+      stats.emitted++;
+      stats.lastEmitted = event.timestamp;
+      this.eventStats.set(event.type, stats);
+
+      // Check if event should be batched
+      if (options?.batch) {
+        this.batchProcessor.addEvent(event, async (events) => {
+          const results = await Promise.all(events.map(e => {
+            const typeResult = this.emitter.emit(e.type, e);
+            const wildcardResult = this.emitter.emit('*', e);
+            return typeResult || wildcardResult;
+          }));
+          
+          // Update stats for batched events
+          const successCount = results.filter(Boolean).length;
+          if (successCount > 0) {
+            stats.handled += successCount;
+          }
+        });
+        return true; // Batch queued successfully
+      }
+
+      // Emit event directly if not batched
+      const typeResult = this.emitter.emit(event.type, event);
+      const wildcardResult = this.emitter.emit('*', event);
+
+      // Update handled count if any listeners processed the event
+      if (typeResult || wildcardResult) {
+        stats.handled++;
+      }
 
-      // Emit to wildcard listeners
-      this.emitter.emit('*', event);
+      return typeResult || wildcardResult;
     } catch (error) {
-      EventManager.logger.error('Event emission failed', {
+      const logError = EventManager.logger
+        ? EventManager.logger.error.bind(EventManager.logger)
+        : console.error;
+      logError('Event emission failed', {
         error,
         event: {
           type: event.type,
-          timestamp: event.timestamp
+          timestamp: event.timestamp,
+          batch: options?.batch
         }
       });
 
       // Emit error event
       this.emitError('event_emission_failed', error as Error, {
-        eventType: event.type
+        eventType: event.type,
+        batch: options?.batch
       });
+      return false;
     }
   }
 
   on<T extends AtlasEvent>(
     type: EventTypes | '*',
-    handler: EventHandler<T>
+    handler: EventHandler<T>,
+    options: EventHandlerOptions = {}
   ): EventSubscription {
     if (this.debugMode) {
-      EventManager.logger.debug('Adding event listener', { type });
+      const logger = EventManager.logger || console;
+      logger.debug('Adding event listener', { type });
     }
 
-    // Wrap handler to catch errors
+    // Create unique handler ID for health monitoring
+    const handlerId = `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+
+    // Wrap handler with health monitoring
+    const monitoredHandler = this.healthMonitor.wrapHandler(type, handler, handlerId);
+
+    const { timeout = 5000, maxRetries = 3 } = options;
+
+    // Wrap handler with timeout and retry logic
     const wrappedHandler = async (event: T) => {
-      try {
-        await handler(event);
-      } catch (error) {
-        EventManager.logger.error('Event handler error', {
-          error,
-          eventType: type
-        });
-        this.emitError('event_handler_error', error as Error, {
-          eventType: type
-        });
+      let attempts = 0;
+      while (attempts < maxRetries) {
+        try {
+          const handlerPromise = monitoredHandler(event);
+          await Promise.race([
+            handlerPromise,
+            new Promise((_, reject) => 
+              setTimeout(() => reject(new Error('Handler timeout')), timeout)
+            )
+          ]);
+          break;
+        } catch (error) {
+          attempts++;
+          const stats = this.eventStats.get(type) || { emitted: 0, handled: 0, errors: 0 };
+          stats.errors++;
+          this.eventStats.set(type, stats);
+
+          const logError = EventManager.logger
+            ? EventManager.logger.error.bind(EventManager.logger)
+            : console.error;
+          logError('Event handler error', {
+            error,
+            eventType: type,
+            attempt: attempts,
+            handlerId
+          });
+
+          if (attempts === maxRetries) {
+            this.emitError('event_handler_error', error as Error, {
+              eventType: type,
+              attempts,
+              handlerId
+            });
+          }
+        }
       }
     };
 
     this.emitter.on(type, wrappedHandler);
 
-    // Return subscription object
-    return {
+    // Create subscription with enhanced cleanup
+    const subscription: EventSubscription = {
       unsubscribe: () => {
         this.emitter.off(type, wrappedHandler);
+        this.activeSubscriptions.delete(subscription);
         if (this.debugMode) {
-          EventManager.logger.debug('Removed event listener', { type });
+          const logger = EventManager.logger || console;
+          logger.debug('Removed event listener', { 
+            type,
+            handlerId,
+            remainingListeners: this.listenerCount(type),
+            totalSubscriptions: this.activeSubscriptions.size
+          });
         }
-      }
+      },
+      type,
+      createdAt: Date.now()
     };
+
+    this.activeSubscriptions.add(subscription);
+    return subscription;
   }
 
   once<T extends AtlasEvent>(
     type: EventTypes | '*',
-    handler: EventHandler<T>
+    handler: EventHandler<T>,
+    options: EventHandlerOptions = {}
   ): EventSubscription {
     if (this.debugMode) {
-      EventManager.logger.debug('Adding one-time event listener', { type });
+      const logger = EventManager.logger || console;
+      logger.debug('Adding one-time event listener', { type });
     }
 
-    // Wrap handler to catch errors
+    // Create unique handler ID for health monitoring
+    const handlerId = `${type}_once_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+
+    // Wrap handler with health monitoring
+    const monitoredHandler = this.healthMonitor.wrapHandler(type, handler, handlerId);
+
+    const { timeout = 5000, maxRetries = 1 } = options;
+
+    // Wrap handler with timeout and retry logic
     const wrappedHandler = async (event: T) => {
-      try {
-        await handler(event);
-      } catch (error) {
-        EventManager.logger.error('One-time event handler error', {
-          error,
-          eventType: type
-        });
-        this.emitError('event_handler_error', error as Error, {
-          eventType: type,
-          oneTime: true
-        });
+      let attempts = 0;
+      while (attempts < maxRetries) {
+        try {
+          const handlerPromise = monitoredHandler(event);
+          await Promise.race([
+            handlerPromise,
+            new Promise((_, reject) => 
+              setTimeout(() => reject(new Error('Handler timeout')), timeout)
+            )
+          ]);
+          break;
+        } catch (error) {
+          attempts++;
+          const stats = this.eventStats.get(type) || { emitted: 0, handled: 0, errors: 0 };
+          stats.errors++;
+          this.eventStats.set(type, stats);
+
+          const logError = EventManager.logger
+            ? EventManager.logger.error.bind(EventManager.logger)
+            : console.error;
+          logError('One-time event handler error', {
+            error,
+            eventType: type,
+            attempt: attempts,
+            handlerId
+          });
+
+          if (attempts === maxRetries) {
+            this.emitError('event_handler_error', error as Error, {
+              eventType: type,
+              oneTime: true,
+              attempts,
+              handlerId
+            });
+          }
+        }
       }
     };
 
     this.emitter.once(type, wrappedHandler);
 
-    // Return subscription object
-    return {
+    // Create subscription with enhanced cleanup
+    const subscription: EventSubscription = {
       unsubscribe: () => {
         this.emitter.off(type, wrappedHandler);
+        this.activeSubscriptions.delete(subscription);
         if (this.debugMode) {
-          EventManager.logger.debug('Removed one-time event listener', { type });
+          const logger = EventManager.logger || console;
+          logger.debug('Removed one-time event listener', { 
+            type,
+            handlerId,
+            remainingListeners: this.listenerCount(type),
+            totalSubscriptions: this.activeSubscriptions.size
+          });
         }
-      }
+      },
+      type,
+      createdAt: Date.now()
     };
+
+    this.activeSubscriptions.add(subscription);
+    return subscription;
   }
 
   removeAllListeners(type?: EventTypes | '*'): void {
     if (type) {
       this.emitter.removeAllListeners(type);
-      if (this.debugMode) {
-        EventManager.logger.debug('Removed all listeners for event type', { type });
+      // Remove matching subscriptions
+      for (const subscription of this.activeSubscriptions) {
+        if (subscription.type === type) {
+          this.activeSubscriptions.delete(subscription);
+        }
       }
     } else {
       this.emitter.removeAllListeners();
-      if (this.debugMode) {
-        EventManager.logger.debug('Removed all event listeners');
-      }
+      this.activeSubscriptions.clear();
     }
+
+    if (this.debugMode) {
+      const logger = EventManager.logger || console;
+      logger.debug('Removed listeners', {
+        type: type || 'all',
+        remainingSubscriptions: this.activeSubscriptions.size
+      });
+    }
+  }
+
+  /**
+   * Gets event statistics for monitoring and debugging
+   */
+  getEventStats(): Map<EventTypes | '*', {
+    emitted: number;
+    handled: number;
+    errors: number;
+    lastEmitted?: number;
+  }> {
+    return new Map(this.eventStats);
+  }
+
+  /**
+   * Gets active subscription information for monitoring
+   */
+  getActiveSubscriptions(): Array<{
+    type: EventTypes | '*';
+    createdAt: number;
+    age: number;
+  }> {
+    const now = Date.now();
+    return Array.from(this.activeSubscriptions).map(sub => ({
+      type: sub.type,
+      createdAt: sub.createdAt,
+      age: now - sub.createdAt
+    }));
+  }
+
+  /**
+   * Gets health statistics for event handlers
+   */
+  getHandlerHealthStats(): Map<string, {
+    successCount: number;
+    errorCount: number;
+    avgResponseTime: number;
+    lastExecuted?: number;
+    consecutiveFailures: number;
+    isCircuitOpen: boolean;
+    nextRetryTime?: number;
+  }> {
+    return this.healthMonitor.getAllHandlerStats();
+  }
+
+  /**
+   * Manually reset circuit breaker for a handler
+   */
+  resetHandlerCircuitBreaker(handlerId: string): void {
+    this.healthMonitor.resetCircuitBreaker(handlerId);
+  }
+
+  /**
+   * Cleanup resources and stop monitoring
+   */
+  cleanup(): void {
+    if (this.cleanupTimeout) {
+      clearInterval(this.cleanupTimeout);
+      this.cleanupTimeout = undefined;
+    }
+    this.removeAllListeners();
+    this.eventStats.clear();
+    this.healthMonitor.cleanup();
+    this.batchProcessor.cleanup();
   }
 
   listenerCount(type: EventTypes | '*'): number {
@@ -212,12 +480,18 @@ export class EventManager {
   private setupErrorHandling(): void {
     // Handle emitter errors
     this.emitter.on('error', (error: Error) => {
-      EventManager.logger.error('EventEmitter error', { error });
+      const logError = EventManager.logger
+        ? EventManager.logger.error.bind(EventManager.logger)
+        : console.error;
+      logError('EventEmitter error', { error });
     });
 
     // Handle uncaught promise rejections in handlers
     process.on('unhandledRejection', (reason, promise) => {
-      EventManager.logger.error('Unhandled promise rejection in event handler', {
+      const logError = EventManager.logger
+        ? EventManager.logger.error.bind(EventManager.logger)
+        : console.error;
+      logError('Unhandled promise rejection in event handler', {
         reason,
         promise
       });
@@ -244,7 +518,10 @@ export class EventManager {
       this.emitter.emit(EventTypes.SYSTEM_ERROR, errorEvent);
     } catch (emitError) {
       // Last resort error logging
-      EventManager.logger.error('Failed to emit error event', {
+      const logError = EventManager.logger
+        ? EventManager.logger.error.bind(EventManager.logger)
+        : console.error;
+      logError('Failed to emit error event', {
         originalError: error,
         emitError,
         context
@@ -266,7 +543,7 @@ export class EventManager {
   }
 
   emitBatchEvent(event: BatchEvent): void {
-    this.emit(event);
+    this.emit(event, { batch: true });
   }
 
   emitTransactionEvent(event: TransactionEvent): void {
diff --git a/src/index.ts b/src/index.ts
index 2b44539..0505246 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -15,583 +15,710 @@ import { CreateTaskInput, UpdateTaskInput, TaskStatus } from './types/task.js';
 let server: AtlasServer;
 let storage: TaskStorage;
 let taskManager: TaskManager;
+let eventManager: EventManager;
+let logger: Logger;
 
-async function main() {
-    // Load environment variables from .env file if present
+async function main(): Promise<void> {
     try {
-        const { config } = await import('dotenv');
-        config();
-    } catch (error) {
-        // Ignore error if .env file doesn't exist
-    }
+        // Load environment variables from .env file if present
+        try {
+            const { config } = await import('dotenv');
+            config();
+        } catch (error) {
+            // Ignore error if .env file doesn't exist
+        }
+
+        // Get home directory in a cross-platform way
+        const homeDir = process.env.HOME || process.env.USERPROFILE || '';
 
-    // Get home directory in a cross-platform way
-    const homeDir = process.env.HOME || process.env.USERPROFILE || '';
-
-    const logDir = process.env.ATLAS_STORAGE_DIR ? 
-        join(process.env.ATLAS_STORAGE_DIR, 'logs') : 
-        join(homeDir, 'Documents', 'Cline', 'mcp-workspace', 'ATLAS', 'logs');
-
-    // Create log directory with proper permissions (mode is ignored on Windows)
-    await fs.mkdir(logDir, { recursive: true, ...(process.platform !== 'win32' && { mode: 0o755 }) });
-
-    // Initialize logger with explicit file permissions and await initialization
-    const logger = await Logger.initialize({
-        console: true,
-        file: true,
-        minLevel: 'debug',
-        logDir: logDir,  // Ensure logDir is explicitly set
-        maxFileSize: 5 * 1024 * 1024, // 5MB
-        maxFiles: 5,
-        noColors: false  // Enable colors for better readability
-    });
-    logger.info('Logger initialized', { logDir, permissions: '0755' });
-
-    // Ensure logger is fully initialized before proceeding
-    await new Promise(resolve => setTimeout(resolve, 100));
-
-    // Increase event listener limits to prevent warnings
-    process.setMaxListeners(20);
-
-    // Initialize components in correct order
-    const eventManager = await EventManager.initialize();
-    const configManager = await ConfigManager.initialize({
-        logging: {
+        const logDir = process.env.ATLAS_STORAGE_DIR ? 
+            join(process.env.ATLAS_STORAGE_DIR, 'logs') : 
+            join(homeDir, 'Documents', 'Cline', 'mcp-workspace', 'ATLAS', 'logs');
+
+        // Create log directory with proper permissions (mode is ignored on Windows)
+        await fs.mkdir(logDir, { recursive: true, ...(process.platform !== 'win32' && { mode: 0o755 }) });
+
+        // Initialize logger first
+        logger = await Logger.initialize({
             console: true,
             file: true,
-            level: 'debug',
+            minLevel: 'debug',
+            logDir: logDir,
+            maxFileSize: 5 * 1024 * 1024,
             maxFiles: 5,
-            maxSize: 5242880, // 5MB
-            dir: logDir
-        },
-        storage: {
-            baseDir: process.env.ATLAS_STORAGE_DIR || 'atlas-tasks',
-            name: process.env.ATLAS_STORAGE_NAME || 'atlas-tasks',
-            connection: {
-                maxRetries: 1,
-                retryDelay: 500,
-                busyTimeout: 2000
-            },
-            performance: {
-                checkpointInterval: 60000,
-                cacheSize: 1000,
-                mmapSize: 1024 * 1024 * 1024, // 1GB
-                pageSize: 4096
-            }
-        }
-    });
+            noColors: false
+        });
 
-    const config = configManager.getConfig();
+        // Initialize event manager
+        eventManager = await EventManager.initialize();
 
-    try {
+        // Update logger with event manager
+        logger.setEventManager(eventManager);
+
+        // Increase event listener limits to prevent warnings
+        process.setMaxListeners(20);
 
-        // Emit system startup event
-        eventManager.emitSystemEvent({
-            type: EventTypes.SYSTEM_STARTUP,
-            timestamp: Date.now(),
-            metadata: {
-                version: '0.1.0',
-                environment: process.env.NODE_ENV || 'development'
+        const configManager = await ConfigManager.initialize({
+            logging: {
+                console: true,
+                file: true,
+                level: 'debug',
+                maxFiles: 5,
+                maxSize: 5242880, // 5MB
+                dir: logDir
+            },
+            storage: {
+                baseDir: process.env.ATLAS_STORAGE_DIR || join(homeDir, 'Documents', 'Cline', 'mcp-workspace', 'ATLAS'),
+                name: process.env.ATLAS_STORAGE_NAME || 'atlas-tasks',
+                connection: {
+                    maxRetries: 1,
+                    retryDelay: 500,
+                    busyTimeout: 2000
+                },
+                performance: {
+                    checkpointInterval: 60000,
+                    cacheSize: 1000,
+                    mmapSize: 1024 * 1024 * 1024, // 1GB
+                    pageSize: 4096
+                }
             }
         });
 
-        // Initialize storage with mutex
-        storage = await createStorage(config.storage!);
-        
-        // Initialize task manager with existing storage instance
-        taskManager = await TaskManager.getInstance(storage);
-
-        // Run maintenance after initialization
-        await storage.vacuum();
-        await storage.analyze();
-        await storage.checkpoint();
-
-        // Initialize server only if it doesn't exist
-        if (!server) {
-            server = await AtlasServer.getInstance(
-            {
-                name: 'atlas-mcp-server',
-                version: '0.1.0',
-                maxRequestsPerMinute: 600,
-                requestTimeout: 30000,
-                shutdownTimeout: 5000
-            },
-            {
-                listTools: async () => ({
-                    tools: [
-                        // Task CRUD operations
-                        {
-                            name: 'create_task',
-                            description: 'Create a new task in the hierarchical task structure. Tasks can be organized in a tree-like structure with parent-child relationships and dependencies. Each task has a unique path identifier, metadata, and status tracking.\n\nBest Practices:\n- Use descriptive path names that reflect the task hierarchy (e.g., "project/feature/subtask")\n- Set appropriate task types (TASK for work items, GROUP for organization, MILESTONE for major checkpoints)\n- Include detailed descriptions for better context\n- Use metadata for custom fields like priority, tags, or deadlines\n- Consider dependencies carefully to avoid circular references\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "name": "Implement login form",\n  "description": "Create React component for user authentication",\n  "type": "TASK",\n  "parentPath": "website/auth",\n  "dependencies": ["website/auth/api-endpoints"],\n  "metadata": {\n    "priority": "high",\n    "estimatedHours": 4,\n    "tags": ["frontend", "security"]\n  }\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    path: { 
-                                        type: 'string',
-                                        description: 'Optional: Unique path identifier for the task (e.g., "project/feature/subtask"). If not provided, will be generated from name'
-                                    },
-                                    name: { 
-                                        type: 'string',
-                                        description: 'Required: Display name of the task. This is the only required field'
+        const config = configManager.getConfig();
+
+        try {
+            // Emit system startup event
+            eventManager.emitSystemEvent({
+                type: EventTypes.SYSTEM_STARTUP,
+                timestamp: Date.now(),
+                metadata: {
+                    version: '0.1.0',
+                    environment: process.env.NODE_ENV || 'development'
+                }
+            });
+
+            // Initialize storage with mutex
+            storage = await createStorage(config.storage!);
+            
+            // Initialize task manager with existing storage instance
+            taskManager = await TaskManager.getInstance(storage);
+
+            // Run maintenance after initialization
+            await storage.vacuum();
+            await storage.analyze();
+            await storage.checkpoint();
+
+            // Initialize server only if it doesn't exist
+            if (!server) {
+                server = await AtlasServer.getInstance(
+                {
+                    name: 'atlas-mcp-server',
+                    version: '0.1.0',
+                    maxRequestsPerMinute: 600,
+                    requestTimeout: 30000,
+                    shutdownTimeout: 5000,
+                    health: {
+                        checkInterval: 300000,     // 5 minutes
+                        failureThreshold: 5,       // 5 strikes
+                        shutdownGracePeriod: 10000, // 10 seconds
+                        clientPingTimeout: 300000   // 5 minutes
+                    }
+                },
+                {
+                    listTools: async () => ({
+                        tools: [
+                            // Task CRUD operations
+                            {
+                                name: 'create_task',
+                                description: 'Create a new task in the hierarchical task structure. Tasks can be organized in a tree-like structure with parent-child relationships and dependencies. Each task has a unique path identifier, metadata, and status tracking.\n\nBest Practices:\n- Use descriptive path names that reflect the task hierarchy (e.g., "project/feature/subtask")\n- Set appropriate task types (TASK for work items, GROUP for organization, MILESTONE for major checkpoints)\n- Include detailed descriptions for better context\n- Use metadata for custom fields like priority, tags, or deadlines\n- Consider dependencies carefully to avoid circular references\n\nExample:\n{\n  "path": "project/backend/api",\n  "name": "Implement REST API",\n  "description": "Create RESTful API endpoints with proper validation",\n  "type": "GROUP",\n  "metadata": {\n    "priority": "high",\n    "estimatedDays": 14,\n    "tags": ["backend", "api", "rest"]\n  }\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        path: { 
+                                            type: 'string',
+                                            description: 'Optional: Unique path identifier for the task (e.g., "project/feature/subtask"). If not provided, will be generated from name'
+                                        },
+                                        name: { 
+                                            type: 'string',
+                                            description: 'Required: Display name of the task. This is the only required field'
+                                        },
+                                        description: { 
+                                            type: 'string',
+                                            description: 'Optional: Detailed description of the task'
+                                        },
+                                        type: { 
+                                            type: 'string', 
+                                            enum: ['TASK', 'GROUP', 'MILESTONE'],
+                                            description: 'Optional: Type of task: TASK (individual task), GROUP (container), or MILESTONE (major checkpoint). Defaults to TASK'
+                                        },
+                                        parentPath: { 
+                                            type: 'string',
+                                            description: 'Optional: Path of the parent task if this is a subtask. Used for hierarchical organization'
+                                        },
+                                        dependencies: { 
+                                            type: 'array', 
+                                            items: { type: 'string' },
+                                            description: 'Optional: Array of task paths that must be completed before this task can start. Used for dependency tracking'
+                                        },
+                                        metadata: { 
+                                            type: 'object',
+                                            description: 'Optional: Additional task metadata like priority, tags, or custom fields. Can store any JSON-serializable data'
+                                        }
                                     },
-                                    description: { 
-                                        type: 'string',
-                                        description: 'Optional: Detailed description of the task'
+                                    required: ['name']
+                                }
+                            },
+                            {
+                                name: 'update_task',
+                                description: 'Update an existing task\'s properties including status, dependencies, and metadata. All changes are validated for consistency and dependency cycles.\n\nBest Practices:\n- Update only the fields that need to change\n- Use appropriate status values to track progress\n- Validate dependencies before updating\n- Keep metadata consistent across updates\n- Consider impact on dependent tasks\n\nExample:\n{\n  "path": "project/backend/api",\n  "updates": {\n    "status": "IN_PROGRESS",\n    "description": "Implementing core API endpoints with JWT auth",\n    "metadata": {\n      "assignee": "backend-team",\n      "progress": 35,\n      "currentPhase": "authentication"\n    }\n  }\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        path: { 
+                                            type: 'string',
+                                            description: 'Required: Path of the task to update. Must be an existing task path'
+                                        },
+                                        updates: {
+                                            type: 'object',
+                                            description: 'Required: Fields to update on the task. At least one update field must be provided',
+                                            properties: {
+                                                    name: { 
+                                                        type: 'string',
+                                                        description: 'Optional: New display name for the task'
+                                                    },
+                                                    description: { 
+                                                        type: 'string',
+                                                        description: 'Optional: New detailed description for the task'
+                                                    },
+                                                    status: { 
+                                                        type: 'string', 
+                                                        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
+                                                        description: 'Optional: New status for the task. Must be one of the defined status values'
+                                                    },
+                                                    dependencies: { 
+                                                        type: 'array', 
+                                                        items: { type: 'string' },
+                                                        description: 'Optional: New list of dependency task paths. Replaces existing dependencies'
+                                                    },
+                                                    metadata: { 
+                                                        type: 'object',
+                                                        description: 'Optional: Updated task metadata. Merges with existing metadata'
+                                                    }
+                                            }
+                                        }
                                     },
-                                    type: { 
-                                        type: 'string', 
-                                        enum: ['TASK', 'GROUP', 'MILESTONE'],
-                                        description: 'Optional: Type of task: TASK (individual task), GROUP (container), or MILESTONE (major checkpoint). Defaults to TASK'
+                                    required: ['path', 'updates']
+                                }
+                            },
+                            {
+                                name: 'delete_task',
+                                description: 'Delete a task and all its subtasks recursively. This operation cascades through the task hierarchy and cannot be undone.\n\nBest Practices:\n- Verify task path carefully before deletion\n- Check for dependent tasks that may be affected\n- Consider archiving important tasks instead of deletion\n- Back up task data if needed before deletion\n- Update dependent task references after deletion\n\nExample:\n{\n  "path": "project/backend"\n  // Will delete backend task and all subtasks like api, database, etc.\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        path: { 
+                                            type: 'string',
+                                            description: 'Required: Path of the task to delete. Will recursively delete this task and all its subtasks'
+                                        }
                                     },
-                                    parentPath: { 
-                                        type: 'string',
-                                        description: 'Optional: Path of the parent task if this is a subtask. Used for hierarchical organization'
+                                    required: ['path']
+                                }
+                            },
+                            {
+                                name: 'get_tasks_by_status',
+                                description: 'Retrieve all tasks with a specific status. Useful for monitoring progress, finding blocked tasks, or generating status reports.\n\nStatus Values:\n- PENDING: Not started\n- IN_PROGRESS: Currently being worked on\n- COMPLETED: Finished successfully\n- FAILED: Encountered errors/issues\n- BLOCKED: Waiting on dependencies\n\nExample:\n{\n  "status": "BLOCKED"\n  // Returns all blocked tasks for investigation\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        status: { 
+                                            type: 'string', 
+                                            enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
+                                            description: 'Required: Status value to filter tasks by. Must be one of the defined status values'
+                                        }
                                     },
-                                    dependencies: { 
-                                        type: 'array', 
-                                        items: { type: 'string' },
-                                        description: 'Optional: Array of task paths that must be completed before this task can start. Used for dependency tracking'
+                                    required: ['status']
+                                }
+                            },
+                            {
+                                name: 'get_tasks_by_path',
+                                description: 'Retrieve tasks matching a glob pattern. Supports flexible path matching for finding related tasks.\n\nPattern Examples:\n- "project/*": Direct children of project\n- "project/**": All tasks under project (recursive)\n- "*/api": API tasks in any project\n- "backend/db*": All database-related tasks in backend\n\nBest Practices:\n- Use specific patterns to limit results\n- Consider hierarchy depth when using **\n- Combine with status/metadata filtering\n\nExample:\n{\n  "pattern": "project/backend/**"\n  // Returns all tasks under backend hierarchy\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        pattern: { 
+                                            type: 'string',
+                                            description: 'Required: Glob pattern to match task paths. Supports * for single level and ** for recursive matching'
+                                        }
                                     },
-                                    metadata: { 
-                                        type: 'object',
-                                        description: 'Optional: Additional task metadata like priority, tags, or custom fields. Can store any JSON-serializable data'
-                                    }
-                                },
-                                required: ['name']
-                            }
-                        },
-                        {
-                            name: 'update_task',
-                            description: 'Update an existing task\'s properties including status, dependencies, and metadata. All changes are validated for consistency and dependency cycles.\n\nBest Practices:\n- Update only the fields that need to change\n- Use appropriate status values to track progress\n- Validate dependencies before updating\n- Keep metadata consistent across updates\n- Consider impact on dependent tasks\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "updates": {\n    "status": "IN_PROGRESS",\n    "description": "Updated implementation details...",\n    "metadata": {\n      "assignee": "john.doe",\n      "progress": 50\n    }\n  }\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    path: { 
-                                        type: 'string',
-                                        description: 'Required: Path of the task to update. Must be an existing task path'
+                                    required: ['pattern']
+                                }
+                            },
+                            {
+                                name: 'get_subtasks',
+                                description: 'Retrieve all direct subtasks of a given task. Returns only immediate children, not the entire subtree.\n\nBest Practices:\n- Use for targeted task management\n- Combine with get_tasks_by_path for deep hierarchies\n- Check subtask status for progress tracking\n- Monitor subtask dependencies\n\nExample:\n{\n  "parentPath": "project/backend"\n  // Returns direct subtasks like api, database, auth, etc.\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        parentPath: { 
+                                            type: 'string',
+                                            description: 'Required: Path of the parent task to get subtasks for. Must be an existing task path'
+                                        }
                                     },
-                                    updates: {
-                                        type: 'object',
-                                        description: 'Required: Fields to update on the task. At least one update field must be provided',
-                                        properties: {
-                                                name: { 
-                                                    type: 'string',
-                                                    description: 'Optional: New display name for the task'
-                                                },
-                                                description: { 
-                                                    type: 'string',
-                                                    description: 'Optional: New detailed description for the task'
-                                                },
-                                                status: { 
-                                                    type: 'string', 
-                                                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
-                                                    description: 'Optional: New status for the task. Must be one of the defined status values'
-                                                },
-                                                dependencies: { 
-                                                    type: 'array', 
-                                                    items: { type: 'string' },
-                                                    description: 'Optional: New list of dependency task paths. Replaces existing dependencies'
+                                    required: ['parentPath']
+                                }
+                            },
+                            {
+                                name: 'bulk_task_operations',
+                                description: 'Execute multiple task operations atomically in a single transaction. Ensures data consistency by rolling back all changes if any operation fails.\n\nSupported Operations:\n- create: Add new tasks\n- update: Modify existing tasks\n- delete: Remove tasks and subtasks\n\nBest Practices:\n- Group related changes together\n- Order operations to handle dependencies\n- Keep transactions focused and minimal\n- Include proper error handling\n- Validate data before submission\n\nExample:\n{\n  "operations": [\n    {\n      "type": "create",\n      "path": "project/backend/auth",\n      "data": {\n        "name": "Authentication Service",\n        "type": "GROUP"\n      }\n    },\n    {\n      "type": "update",\n      "path": "project/backend/api",\n      "data": {\n        "status": "COMPLETED"\n      }\n    }\n  ]\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        operations: {
+                                            type: 'array',
+                                            description: 'Required: Array of task operations to execute atomically. Must contain at least one operation. All operations are executed in a single transaction - if any operation fails, all changes are rolled back',
+                                            items: {
+                                                type: 'object',
+                                                properties: {
+                                                    type: { 
+                                                        type: 'string', 
+                                                        enum: ['create', 'update', 'delete'],
+                                                        description: 'Type of operation to perform'
+                                                    },
+                                                    path: { 
+                                                        type: 'string',
+                                                        description: 'Task path the operation applies to'
+                                                    },
+                                                    data: { 
+                                                        type: 'object',
+                                                        description: 'Operation data (CreateTaskInput for create, UpdateTaskInput for update)'
+                                                    }
                                                 },
-                                                metadata: { 
-                                                    type: 'object',
-                                                    description: 'Optional: Updated task metadata. Merges with existing metadata'
-                                                }
+                                                required: ['type', 'path']
+                                            }
+                                        }
+                                    },
+                                    required: ['operations']
+                                }
+                            },
+                            // Database maintenance operations
+                            {
+                                name: 'clear_all_tasks',
+                                description: 'Clear all tasks from the database and reset all caches. This is a destructive operation that requires explicit confirmation.\n\nBest Practices:\n- Use only for complete system reset\n- Backup data before clearing\n- Verify confirmation requirement\n- Plan for cache rebuild time\n- Consider selective deletion instead\n\nExample:\n{\n  "confirm": true\n  // Must be explicitly set to true\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        confirm: { 
+                                            type: 'boolean',
+                                            description: 'Required: Must be explicitly set to true to confirm deletion. This is a safety measure for this destructive operation'
+                                        }
+                                    },
+                                    required: ['confirm']
+                                }
+                            },
+                            {
+                                name: 'vacuum_database',
+                                description: 'Optimize database storage and performance by cleaning up unused space and updating statistics.\n\nBest Practices:\n- Run during low-usage periods\n- Schedule regular maintenance\n- Monitor space reclamation\n- Update statistics for query optimization\n- Back up before major operations\n\nExample:\n{\n  "analyze": true\n  // Also updates query statistics\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        analyze: { 
+                                            type: 'boolean',
+                                            description: 'Optional: Whether to run ANALYZE after VACUUM to update database statistics. Defaults to false'
                                         }
                                     }
-                                },
-                                required: ['path', 'updates']
-                            }
-                        },
-                        {
-                            name: 'delete_task',
-                            description: 'Delete a task and all its subtasks recursively. This operation cascades through the task hierarchy and cannot be undone.\n\nBest Practices:\n- Verify task path carefully before deletion\n- Check for dependent tasks that may be affected\n- Consider archiving important tasks instead of deletion\n- Back up task data if needed before deletion\n- Update dependent task references after deletion\n\nExample:\n{\n  "path": "website/auth"\n  // Will delete auth task and all subtasks like login-form, etc.\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    path: { 
-                                        type: 'string',
-                                        description: 'Required: Path of the task to delete. Will recursively delete this task and all its subtasks'
-                                    }
-                                },
-                                required: ['path']
-                            }
-                        },
-                        {
-                            name: 'get_tasks_by_status',
-                            description: 'Retrieve all tasks with a specific status. Useful for monitoring progress, finding blocked tasks, or generating status reports.\n\nStatus Values:\n- PENDING: Not started\n- IN_PROGRESS: Currently being worked on\n- COMPLETED: Finished successfully\n- FAILED: Encountered errors/issues\n- BLOCKED: Waiting on dependencies\n\nExample:\n{\n  "status": "BLOCKED"\n  // Returns all blocked tasks for investigation\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    status: { 
-                                        type: 'string', 
-                                        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
-                                        description: 'Required: Status value to filter tasks by. Must be one of the defined status values'
-                                    }
-                                },
-                                required: ['status']
-                            }
-                        },
-                        {
-                            name: 'get_tasks_by_path',
-                            description: 'Retrieve tasks matching a glob pattern. Supports flexible path matching for finding related tasks.\n\nPattern Examples:\n- "project/*": Direct children of project\n- "project/**": All tasks under project (recursive)\n- "*/feature": Feature tasks in any project\n- "auth/login*": All login-related tasks in auth\n\nBest Practices:\n- Use specific patterns to limit results\n- Consider hierarchy depth when using **\n- Combine with status/metadata filtering\n\nExample:\n{\n  "pattern": "website/auth/**"\n  // Returns all tasks under auth hierarchy\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    pattern: { 
-                                        type: 'string',
-                                        description: 'Required: Glob pattern to match task paths. Supports * for single level and ** for recursive matching'
-                                    }
-                                },
-                                required: ['pattern']
-                            }
-                        },
-                        {
-                            name: 'get_subtasks',
-                            description: 'Retrieve all direct subtasks of a given task. Returns only immediate children, not the entire subtree.\n\nBest Practices:\n- Use for targeted task management\n- Combine with get_tasks_by_path for deep hierarchies\n- Check subtask status for progress tracking\n- Monitor subtask dependencies\n\nExample:\n{\n  "parentPath": "website/auth"\n  // Returns direct subtasks like login-form, signup-form, etc.\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    parentPath: { 
-                                        type: 'string',
-                                        description: 'Required: Path of the parent task to get subtasks for. Must be an existing task path'
+                                }
+                            },
+                            {
+                                name: 'repair_relationships',
+                                description: 'Repair parent-child relationships and fix inconsistencies in the task hierarchy. Validates and corrects task relationships, orphaned tasks, and broken dependencies.\n\nBest Practices:\n- Run in dry-run mode first\n- Fix critical paths immediately\n- Schedule regular validation\n- Monitor repair results\n- Back up before repairs\n\nExample:\n{\n  "dryRun": true,\n  "pathPattern": "project/**"\n  // Check project hierarchy without making changes\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        dryRun: { 
+                                            type: 'boolean',
+                                            description: 'Optional: If true, only report issues without fixing them. Useful for safely checking what would be repaired. Defaults to false'
+                                        },
+                                        pathPattern: { 
+                                            type: 'string',
+                                            description: 'Optional: Pattern to limit which tasks to check relationships for. If not provided, checks all tasks'
+                                        }
                                     }
-                                },
-                                required: ['parentPath']
-                            }
-                        },
-                        {
-                            name: 'bulk_task_operations',
-                            description: 'Execute multiple task operations atomically in a single transaction. Ensures data consistency by rolling back all changes if any operation fails.\n\nSupported Operations:\n- create: Add new tasks\n- update: Modify existing tasks\n- delete: Remove tasks and subtasks\n\nBest Practices:\n- Group related changes together\n- Order operations to handle dependencies\n- Keep transactions focused and minimal\n- Include proper error handling\n- Validate data before submission\n\nExample:\n{\n  "operations": [\n    {\n      "type": "create",\n      "path": "website/auth/oauth",\n      "data": {\n        "name": "OAuth Integration",\n        "type": "TASK"\n      }\n    },\n    {\n      "type": "update",\n      "path": "website/auth/login-form",\n      "data": {\n        "status": "COMPLETED"\n      }\n    }\n  ]\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    operations: {
-                                        type: 'array',
-                                        description: 'Required: Array of task operations to execute atomically. Must contain at least one operation. All operations are executed in a single transaction - if any operation fails, all changes are rolled back',
-                                        items: {
-                                            type: 'object',
-                                            properties: {
-                                                type: { 
-                                                    type: 'string', 
-                                                    enum: ['create', 'update', 'delete'],
-                                                    description: 'Type of operation to perform'
+                                }
+                            },
+                            {
+                                name: 'update_task_statuses',
+                                description: 'Update statuses of multiple tasks in a single batch operation. Validates status changes against dependencies and task hierarchy.\n\nBest Practices:\n- Group related status updates together\n- Consider dependency order\n- Update parent tasks last\n- Monitor status transitions\n- Handle failed updates\n\nExample:\n{\n  "updates": [\n    {\n      "path": "project/backend/api",\n      "status": "COMPLETED"\n    },\n    {\n      "path": "project/backend/database",\n      "status": "IN_PROGRESS"\n    }\n  ]\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        updates: {
+                                            type: 'array',
+                                            description: 'Array of status updates to process in batch',
+                                            items: {
+                                                type: 'object',
+                                                properties: {
+                                                    path: {
+                                                        type: 'string',
+                                                        description: 'Path of the task to update'
+                                                    },
+                                                    status: {
+                                                        type: 'string',
+                                                        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
+                                                        description: 'New status for the task'
+                                                    }
                                                 },
-                                                path: { 
-                                                    type: 'string',
-                                                    description: 'Task path the operation applies to'
+                                                required: ['path', 'status']
+                                            }
+                                        }
+                                    },
+                                    required: ['updates']
+                                }
+                            },
+                            {
+                                name: 'update_task_dependencies',
+                                description: 'Update dependencies of multiple tasks in a single batch operation. Validates dependency relationships and detects cycles.\n\nBest Practices:\n- Verify dependency paths exist\n- Avoid circular dependencies\n- Update related tasks together\n- Consider task hierarchy\n- Monitor dependency chains\n\nExample:\n{\n  "updates": [\n    {\n      "path": "project/backend/api",\n      "dependencies": ["project/backend/auth", "project/backend/database"]\n    },\n    {\n      "path": "project/backend/auth",\n      "dependencies": ["project/backend/database"]\n    }\n  ]\n}',
+                                inputSchema: {
+                                    type: 'object',
+                                    properties: {
+                                        updates: {
+                                            type: 'array',
+                                            description: 'Array of dependency updates to process in batch',
+                                            items: {
+                                                type: 'object',
+                                                properties: {
+                                                    path: {
+                                                        type: 'string',
+                                                        description: 'Path of the task to update'
+                                                    },
+                                                    dependencies: {
+                                                        type: 'array',
+                                                        items: { type: 'string' },
+                                                        description: 'New list of dependency task paths'
+                                                    }
                                                 },
-                                                data: { 
-                                                    type: 'object',
-                                                    description: 'Operation data (CreateTaskInput for create, UpdateTaskInput for update)'
-                                                }
-                                            },
-                                            required: ['type', 'path']
+                                                required: ['path', 'dependencies']
+                                            }
                                         }
-                                    }
-                                },
-                                required: ['operations']
-                            }
-                        },
-                        // Database maintenance operations
-                        {
-                            name: 'clear_all_tasks',
-                            description: 'Clear all tasks from the database and reset all caches. This is a destructive operation that requires explicit confirmation.\n\nBest Practices:\n- Use only for complete system reset\n- Backup data before clearing\n- Verify confirmation requirement\n- Plan for cache rebuild time\n- Consider selective deletion instead\n\nExample:\n{\n  "confirm": true\n  // Must be explicitly set to true\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    confirm: { 
-                                        type: 'boolean',
-                                        description: 'Required: Must be explicitly set to true to confirm deletion. This is a safety measure for this destructive operation'
-                                    }
-                                },
-                                required: ['confirm']
-                            }
-                        },
-                        {
-                            name: 'vacuum_database',
-                            description: 'Optimize database storage and performance by cleaning up unused space and updating statistics.\n\nBest Practices:\n- Run during low-usage periods\n- Schedule regular maintenance\n- Monitor space reclamation\n- Update statistics for query optimization\n- Back up before major operations\n\nExample:\n{\n  "analyze": true\n  // Also updates query statistics\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    analyze: { 
-                                        type: 'boolean',
-                                        description: 'Optional: Whether to run ANALYZE after VACUUM to update database statistics. Defaults to false'
-                                    }
+                                    },
+                                    required: ['updates']
                                 }
                             }
-                        },
-                        {
-                            name: 'repair_relationships',
-                            description: 'Repair parent-child relationships and fix inconsistencies in the task hierarchy. Validates and corrects task relationships, orphaned tasks, and broken dependencies.\n\nBest Practices:\n- Run in dry-run mode first\n- Fix critical paths immediately\n- Schedule regular validation\n- Monitor repair results\n- Back up before repairs\n\nExample:\n{\n  "dryRun": true,\n  "pathPattern": "website/**"\n  // Check website hierarchy without making changes\n}',
-                            inputSchema: {
-                                type: 'object',
-                                properties: {
-                                    dryRun: { 
-                                        type: 'boolean',
-                                        description: 'Optional: If true, only report issues without fixing them. Useful for safely checking what would be repaired. Defaults to false'
-                                    },
-                                    pathPattern: { 
-                                        type: 'string',
-                                        description: 'Optional: Pattern to limit which tasks to check relationships for. If not provided, checks all tasks'
-                                    }
+                        ]
+                    }),
+                    handleToolCall: async (request) => {
+                        const name = request.params?.name as string;
+                        const args = request.params?.arguments as Record<string, any>;
+                        let result;
+
+                        try {
+                            // Emit tool start event
+                            eventManager.emitSystemEvent({
+                                type: EventTypes.TOOL_STARTED,
+                                timestamp: Date.now(),
+                                metadata: {
+                                    tool: name,
+                                    args
                                 }
+                            });
+
+                            switch (name) {
+                            case 'create_task':
+                                result = await taskManager.createTask(args as CreateTaskInput);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'update_task':
+                                result = await taskManager.updateTask(args.path as string, args.updates as UpdateTaskInput);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'delete_task':
+                                await taskManager.deleteTask(args.path as string);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: 'Task deleted successfully'
+                                    }]
+                                };
+                            case 'get_tasks_by_status':
+                                result = await taskManager.getTasksByStatus(args.status as TaskStatus);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'get_tasks_by_path':
+                                result = await taskManager.listTasks(args.pattern as string);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'get_subtasks':
+                                result = await taskManager.getSubtasks(args.parentPath as string);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'bulk_task_operations':
+                                result = await taskManager.bulkTaskOperations(args.operations as Array<{ type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }>);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'clear_all_tasks':
+                                await taskManager.clearAllTasks(args.confirm as boolean);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: 'All tasks cleared successfully'
+                                    }]
+                                };
+                            case 'vacuum_database':
+                                await taskManager.vacuumDatabase(args.analyze as boolean);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: 'Database vacuumed successfully'
+                                    }]
+                                };
+                            case 'repair_relationships':
+                                result = await taskManager.repairRelationships(args.dryRun as boolean, args.pathPattern as string | undefined);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'update_task_statuses':
+                                result = await taskManager.updateTaskStatuses(args.updates);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            case 'update_task_dependencies':
+                                result = await taskManager.updateTaskDependencies(args.updates);
+                                return {
+                                    content: [{
+                                        type: 'text',
+                                        text: JSON.stringify(result, null, 2)
+                                    }]
+                                };
+                            default:
+                                throw createError(
+                                    ErrorCodes.INVALID_INPUT,
+                                    `Unknown tool: ${name}`,
+                                    'handleToolCall'
+                                );
                             }
-                        }
-                    ]
-                }),
-                handleToolCall: async (request) => {
-                    const name = request.params?.name as string;
-                    const args = request.params?.arguments as Record<string, any>;
-                    const eventManager = EventManager.getInstance();
-                    let result;
+                        } catch (error) {
+                            // Emit tool error event
+                            eventManager.emitErrorEvent({
+                                type: EventTypes.SYSTEM_ERROR,
+                                timestamp: Date.now(),
+                                error: error instanceof Error ? error : new Error(String(error)),
+                                context: {
+                                    component: 'ToolHandler',
+                                    operation: name,
+                                    args
+                                }
+                            });
 
-                    try {
-                        // Emit tool start event
-                        eventManager.emitSystemEvent({
-                            type: EventTypes.TOOL_STARTED,
-                            timestamp: Date.now(),
-                            metadata: {
-                                tool: name,
-                                args
-                            }
-                        });
+                            // Format error response
+                            const errorMessage = error instanceof BaseError 
+                                ? error.getUserMessage()
+                                : String(error);
 
-                        switch (name) {
-                        case 'create_task':
-                            result = await taskManager.createTask(args as CreateTaskInput);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        case 'update_task':
-                            result = await taskManager.updateTask(args.path as string, args.updates as UpdateTaskInput);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        case 'delete_task':
-                            await taskManager.deleteTask(args.path as string);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: 'Task deleted successfully'
-                                }]
-                            };
-                        case 'get_tasks_by_status':
-                            result = await taskManager.getTasksByStatus(args.status as TaskStatus);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        case 'get_tasks_by_path':
-                            result = await taskManager.listTasks(args.pattern as string);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        case 'get_subtasks':
-                            result = await taskManager.getSubtasks(args.parentPath as string);
                             return {
                                 content: [{
                                     type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
+                                    text: JSON.stringify({
+                                        error: errorMessage,
+                                        code: error instanceof BaseError ? error.code : ErrorCodes.INTERNAL_ERROR
+                                    }, null, 2)
+                                }],
+                                isError: true
                             };
-                        case 'bulk_task_operations':
-                            result = await taskManager.bulkTaskOperations(args.operations as Array<{ type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }>);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        case 'clear_all_tasks':
-                            await taskManager.clearAllTasks(args.confirm as boolean);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: 'All tasks cleared successfully'
-                                }]
-                            };
-                        case 'vacuum_database':
-                            await taskManager.vacuumDatabase(args.analyze as boolean);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: 'Database vacuumed successfully'
-                                }]
-                            };
-                        case 'repair_relationships':
-                            result = await taskManager.repairRelationships(args.dryRun as boolean, args.pathPattern as string | undefined);
-                            return {
-                                content: [{
-                                    type: 'text',
-                                    text: JSON.stringify(result, null, 2)
-                                }]
-                            };
-                        default:
-                            throw createError(
-                                ErrorCodes.INVALID_INPUT,
-                                `Unknown tool: ${name}`,
-                                'handleToolCall'
-                            );
-                    }
-                } catch (error) {
-                    // Emit tool error event
-                    eventManager.emitErrorEvent({
-                        type: EventTypes.SYSTEM_ERROR,
-                        timestamp: Date.now(),
-                        error: error instanceof Error ? error : new Error(String(error)),
-                        context: {
-                            component: 'ToolHandler',
-                            operation: name,
-                            args
                         }
-                    });
-
-                    // Format error response
-                    const errorMessage = error instanceof BaseError 
-                        ? error.getUserMessage()
-                        : String(error);
-
-                    return {
-                        content: [{
-                            type: 'text',
-                            text: JSON.stringify({
-                                error: errorMessage,
-                                code: error instanceof BaseError ? error.code : ErrorCodes.INTERNAL_ERROR
-                            }, null, 2)
-                        }],
-                        isError: true
-                    };
-                }
-                },
-                getStorageMetrics: async () => await storage.getMetrics(),
-                clearCaches: async () => {
-                    await taskManager.clearCaches();
-                },
-                cleanup: async () => {
-                    await taskManager.close();
+                    },
+                    getStorageMetrics: async () => await storage.getMetrics(),
+                    clearCaches: async () => {
+                        await taskManager.clearCaches();
+                    },
+                    cleanup: async () => {
+                        await taskManager.close();
+                    }
                 }
+            );
             }
-        );
-        }
-    } catch (error) {
-        // Emit system error event
-        eventManager.emitSystemEvent({
-            type: EventTypes.SYSTEM_ERROR,
-            timestamp: Date.now(),
-            metadata: {
-                error: error instanceof Error ? error : new Error(String(error))
-            }
-        });
-
-        logger.error('Failed to start server', error);
-        process.exit(1);
-    }
-
-    // Handle graceful shutdown
-    const shutdown = async (reason: string = 'graceful_shutdown') => {
-        try {
-            // Emit system shutdown event
+        } catch (error) {
+            // Emit system error event
             eventManager.emitSystemEvent({
-                type: EventTypes.SYSTEM_SHUTDOWN,
+                type: EventTypes.SYSTEM_ERROR,
                 timestamp: Date.now(),
-                metadata: { reason }
+                metadata: {
+                    error: error instanceof Error ? error : new Error(String(error))
+                }
             });
 
-            // Cleanup in specific order to ensure proper shutdown
+            logger.error('Failed to start server', error);
+            process.exit(1);
+        }
+
+        // Log successful startup
+        logger.info('Server initialization completed successfully');
+
+        // Store cleanup handlers for proper removal
+        const cleanupHandlers = new Map<string, () => Promise<void>>();
+
+        // Handle graceful shutdown with proper cleanup order and timeouts
+        const shutdown = async (reason: string = 'graceful_shutdown', timeout: number = 30000) => {
+            logger.info('Initiating shutdown', { reason });
             try {
-                // First stop accepting new requests
-                if (server) {
-                    await server.shutdown();
-                }
+                // Emit system shutdown event
+                eventManager.emitSystemEvent({
+                    type: EventTypes.SYSTEM_SHUTDOWN,
+                    timestamp: Date.now(),
+                    metadata: { reason }
+                });
+
+                // Create shutdown promise with timeout
+                const shutdownPromise = (async () => {
+                    try {
+                        // First stop accepting new requests
+                        if (server) {
+                            await Promise.race([
+                                server.shutdown(),
+                                new Promise((_, reject) => setTimeout(() => reject(new Error('Server shutdown timeout')), 5000))
+                            ]);
+                        }
 
-                // Then cleanup task manager and its resources
-                if (taskManager) {
-                    await taskManager.cleanup();
-                }
+                        // Then cleanup task manager and its resources
+                        if (taskManager) {
+                            await Promise.race([
+                                taskManager.cleanup(),
+                                new Promise((_, reject) => setTimeout(() => reject(new Error('Task manager cleanup timeout')), 10000))
+                            ]);
+                        }
 
-                // Finally close storage
-                if (storage) {
-                    await storage.close();
-                }
+                        // Finally close storage
+                        if (storage) {
+                            await Promise.race([
+                                storage.close(),
+                                new Promise((_, reject) => setTimeout(() => reject(new Error('Storage close timeout')), 5000))
+                            ]);
+                        }
 
-                // Clear event manager
-                eventManager.removeAllListeners();
+                        // Clear event manager and remove all handlers
+                        eventManager.removeAllListeners();
+                        cleanupHandlers.forEach((handler, signal) => {
+                            process.removeListener(signal, handler);
+                        });
+                        cleanupHandlers.clear();
 
-                // Force final cleanup
-                if (global.gc) {
-                    global.gc();
-                }
+                        // Force final cleanup
+                        if (global.gc) {
+                            global.gc();
+                        }
 
-                // Remove process event listeners
-                process.removeAllListeners();
-            } catch (cleanupError) {
-                logger.error('Error during component cleanup', cleanupError);
-                // Continue with shutdown despite cleanup errors
+                        // Final logging before exit
+                        logger.info('Server shutdown completed', { reason });
+                    } catch (cleanupError) {
+                        logger.error('Error during component cleanup', cleanupError);
+                        throw cleanupError; // Re-throw to trigger force exit
+                    }
+                })();
+
+                // Wait for shutdown with timeout
+                await Promise.race([
+                    shutdownPromise,
+                    new Promise((_, reject) => setTimeout(() => reject(new Error('Shutdown timeout')), timeout))
+                ]);
+
+                // Clean exit
+                process.nextTick(() => process.exit(0));
+            } catch (error) {
+                logger.error('Error during shutdown', error);
+                // Force exit after error
+                process.nextTick(() => process.exit(1));
             }
-
-            // Final logging before exit
-            logger.info('Server shutdown completed', { reason });
+        };
+
+        // Register shutdown handlers with proper cleanup
+        const registerShutdownHandler = (signal: string, handler: () => Promise<void>) => {
+            cleanupHandlers.set(signal, handler);
+            process.on(signal, handler);
+        };
+
+        // Only register shutdown handlers after successful initialization
+        if (server && storage && taskManager) {
+            // Handle various shutdown signals with Windows compatibility
+            registerShutdownHandler('SIGINT', () => shutdown('SIGINT'));
+            registerShutdownHandler('SIGTERM', () => shutdown('SIGTERM'));
+            registerShutdownHandler('beforeExit', () => shutdown('beforeExit'));
             
-            // Exit after cleanup
-            process.nextTick(() => process.exit(0));
-        } catch (error) {
-            logger.error('Error during shutdown', error);
-            process.nextTick(() => process.exit(1));
-        }
-    };
-
-    // Handle various shutdown signals with Windows compatibility
-    process.on('SIGINT', () => shutdown('SIGINT'));
-    process.on('SIGTERM', () => shutdown('SIGTERM'));
-    process.on('beforeExit', () => shutdown('beforeExit'));
-    
-    // Windows-specific handling for CTRL+C and other termination signals
-    if (process.platform === 'win32') {
-        const readline = require('readline').createInterface({
-            input: process.stdin,
-            output: process.stdout
-        });
-        
-        readline.on('SIGINT', () => {
-            process.emit('SIGINT');
-        });
+            // Windows-specific handling for CTRL+C and other termination signals
+            if (process.platform === 'win32') {
+                const readline = require('readline').createInterface({
+                    input: process.stdin,
+                    output: process.stdout
+                });
+                
+                readline.on('SIGINT', () => {
+                    process.emit('SIGINT');
+                });
+
+                // Handle Windows-specific process termination
+                registerShutdownHandler('SIGHUP', () => shutdown('SIGHUP'));
+                registerShutdownHandler('SIGBREAK', () => shutdown('SIGBREAK'));
+
+                // Ensure readline interface is cleaned up
+                cleanupHandlers.set('cleanup-readline', async () => {
+                    readline.close();
+                });
+            }
 
-        // Handle Windows-specific process termination
-        process.on('SIGHUP', () => shutdown('SIGHUP'));
-        process.on('SIGBREAK', () => shutdown('SIGBREAK'));
-    }
+            // Handle uncaught errors and rejections
+            const errorHandler = (error: Error) => {
+                logger.error('Uncaught error', error);
+                shutdown('uncaught_error', 5000).catch(() => process.exit(1));
+            };
 
-    process.on('exit', () => {
-        try {
-            // Synchronous cleanup for exit event
-            if (global.gc) {
-                global.gc();
-            }
-        } catch (error) {
-            console.error('Error during final cleanup:', error);
+            process.on('uncaughtException', errorHandler);
+            process.on('unhandledRejection', errorHandler);
         }
-    });
+    } catch (error) {
+        console.error('Failed to initialize server:', error);
+        process.exit(1);
+    }
 }
 
-main().catch((error) => {
-    // Get logger instance if available, otherwise fallback to console
+main().catch((error: Error) => {
+    // Get logger instance if available
+    let logger;
     try {
-        const logger = Logger.getInstance();
-        logger.fatal('Fatal error during startup', error);
+        logger = Logger.getInstance();
     } catch {
-        // If logger isn't initialized, fallback to console
-        console.error('Fatal error:', error);
+        // If logger isn't initialized, log to console
+        console.error('Failed to start server:', error);
+        process.exit(1);
     }
+
+    // Log error and exit
+    logger.error('Failed to start server', { error });
     process.exit(1);
 });
diff --git a/src/logging/index.ts b/src/logging/index.ts
index 8260e65..c433146 100644
--- a/src/logging/index.ts
+++ b/src/logging/index.ts
@@ -1,358 +1,29 @@
 /**
- * Logging module
- * Provides centralized logging functionality with structured output
+ * Logging system exports
+ * Provides a comprehensive logging infrastructure with:
+ * - Multiple transport support (console, file)
+ * - Advanced error handling and formatting
+ * - Health monitoring and auto-recovery
+ * - Failover capabilities
+ * - Structured logging
  */
 
-import { createLogger, format, transports, Logger as WinstonLogger, config as winstonConfig } from 'winston';
-import { join } from 'path';
-import { mkdirSync } from 'fs';
-import { BaseError, ErrorCodes } from '../errors/index.js';
-import { LogLevel, LogLevels, LoggerConfig } from '../types/logging.js';
-
-/**
- * Logger class
- * Provides structured logging with context and error handling
- */
-export class Logger {
-    private static instance: Logger;
-    private logger: WinstonLogger;
-
-    private config: LoggerConfig;
-    private isShuttingDown = false;
-
-    private constructor(config: LoggerConfig) {
-        this.config = config;
-        this.logger = this.createLogger(config);
-        
-        // Handle process events
-        process.on('SIGINT', () => this.handleShutdown());
-        process.on('SIGTERM', () => this.handleShutdown());
-        process.on('exit', () => this.handleShutdown());
-    }
-
-    /**
-     * Handle graceful shutdown
-     */
-    private handleShutdown(): void {
-        if (this.isShuttingDown) return;
-        this.isShuttingDown = true;
-
-        // Close transports
-        this.logger.close();
-    }
-
-    /**
-     * Recreate logger if needed
-     */
-    private lastHealthCheck = 0;
-    private readonly HEALTH_CHECK_INTERVAL = 5000; // 5 seconds
-
-    private ensureLogger(): void {
-        if (this.isShuttingDown) return;
-
-        const now = Date.now();
-        // Only check every 5 seconds to reduce memory pressure
-        if (now - this.lastHealthCheck < this.HEALTH_CHECK_INTERVAL) {
-            return;
-        }
-        
-        try {
-            // Test if logger is working
-            this.logger.log({
-                level: 'debug',
-                message: 'Logger health check'
-            });
-            this.lastHealthCheck = now;
-        } catch (error) {
-            const err = error as Error;
-            if (err?.message?.includes('EPIPE')) {
-                // Recreate logger with same config
-                this.logger = this.createLogger(this.config);
-                this.lastHealthCheck = now;
-            }
-        }
-    }
-
-    /**
-     * Gets the logger instance
-     */
-    private static initializationPromise: Promise<Logger> | null = null;
-
-    static getInstance(): Logger {
-        if (!Logger.instance) {
-            throw new BaseError({
-                code: ErrorCodes.INVALID_STATE,
-                message: 'Logger not initialized. Call Logger.initialize() first.'
-            });
-        }
-        return Logger.instance;
-    }
-
-    /**
-     * Initializes the logger with configuration
-     */
-    static async initialize(config: LoggerConfig): Promise<Logger> {
-        // Return existing instance if available
-        if (Logger.instance) {
-            return Logger.instance;
-        }
-
-        // If initialization is in progress, wait for it
-        if (Logger.initializationPromise) {
-            return Logger.initializationPromise;
-        }
-
-        // Start new initialization with mutex
-        Logger.initializationPromise = (async () => {
-            try {
-                // Double-check instance hasn't been created while waiting
-                if (Logger.instance) {
-                    return Logger.instance;
-                }
-
-                Logger.instance = new Logger(config);
-                return Logger.instance;
-            } catch (error) {
-                throw new BaseError({
-                    code: ErrorCodes.STORAGE_INIT,
-                    message: 'Failed to initialize logger',
-                    details: { error: error instanceof Error ? error.message : String(error) }
-                });
-            } finally {
-                Logger.initializationPromise = null;
-            }
-        })();
-
-        return Logger.initializationPromise;
-    }
-
-    /**
-     * Creates a child logger with additional context
-     */
-    child(context: Record<string, unknown>): Logger {
-        const childLogger = new Logger({
-            minLevel: LogLevels.INFO,
-            console: true
-        });
-        childLogger.logger = this.logger.child(context);
-        return childLogger;
-    }
-
-    /**
-     * Logs a debug message
-     */
-    debug(message: string, context?: Record<string, unknown>): void {
-        this.log(LogLevels.DEBUG, message, context);
-    }
-
-    /**
-     * Logs an info message
-     */
-    info(message: string, context?: Record<string, unknown>): void {
-        this.log(LogLevels.INFO, message, context);
-    }
-
-    /**
-     * Logs a warning message
-     */
-    warn(message: string, context?: Record<string, unknown>): void {
-        this.log(LogLevels.WARN, message, context);
-    }
-
-    /**
-     * Logs an error message
-     */
-    error(message: string, error?: unknown, context?: Record<string, unknown>): void {
-        const errorInfo = this.formatError(error);
-        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
-    }
-
-    /**
-     * Logs a fatal error message (maps to error level for Winston compatibility)
-     */
-    fatal(message: string, error?: unknown, context?: Record<string, unknown>): void {
-        const errorInfo = this.formatError(error);
-        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
-    }
-
-    /**
-     * Creates the Winston logger instance
-     */
-    private createLogger(config: LoggerConfig): WinstonLogger {
-        const loggerTransports = [];
-
-        // Console transport
-        if (config.console) {
-            const formats = [format.simple()];
-            if (!config.noColors) {
-                formats.unshift(format.colorize());
-            }
-            loggerTransports.push(
-                new transports.Console({
-                    format: format.combine(...formats)
-                })
-            );
-        }
-
-        // File transport
-        if (config.file && config.logDir) {
-            // Ensure log directory exists with platform-appropriate permissions
-            mkdirSync(config.logDir, { 
-                recursive: true, 
-                // Skip mode on Windows as it's ignored
-                ...(process.platform !== 'win32' && { mode: 0o755 })
-            });
-
-            const errorLogPath = join(config.logDir, 'error.log');
-            const combinedLogPath = join(config.logDir, 'combined.log');
-
-            loggerTransports.push(
-                new transports.File({
-                    filename: errorLogPath,
-                    level: LogLevels.ERROR,
-                    maxsize: config.maxFileSize,
-                    maxFiles: config.maxFiles,
-                    tailable: true // Ensure logs can be read while being written
-                }),
-                new transports.File({
-                    filename: combinedLogPath,
-                    maxsize: config.maxFileSize,
-                    maxFiles: config.maxFiles,
-                    tailable: true
-                })
-            );
-        }
-
-        return createLogger({
-            level: config.minLevel,
-            format: format.combine(
-                format.timestamp(),
-                format.json()
-            ),
-            transports: loggerTransports,
-            levels: winstonConfig.npm.levels // Use standard npm levels
-        });
-    }
-
-    /**
-     * Formats an error for logging
-     */
-    private formatError(error: unknown): Record<string, unknown> | undefined {
-        if (!error) return undefined;
-
-        if (error instanceof BaseError) {
-            return {
-                name: error.name,
-                message: error.message,
-                code: error.code,
-                details: error.details,
-                stack: error.stack,
-                operation: error.operation,
-                timestamp: Date.now()
-            };
-        }
-
-        if (error instanceof Error) {
-            return {
-                name: error.name,
-                message: error.message,
-                stack: error.stack,
-                timestamp: Date.now()
-            };
-        }
-
-        if (error && typeof error === 'object') {
-            try {
-                return {
-                    name: 'ObjectError',
-                    message: JSON.stringify(error, null, 2),
-                    raw: error,
-                    timestamp: Date.now()
-                };
-            } catch (e) {
-                return {
-                    name: 'UnserializableError',
-                    message: 'Error object could not be stringified',
-                    type: typeof error,
-                    timestamp: Date.now()
-                };
-            }
-        }
-
-        return {
-            name: 'UnknownError',
-            message: String(error),
-            type: typeof error,
-            timestamp: Date.now()
-        };
-    }
-
-    /**
-     * Internal log method
-     */
-    private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {
-        if (this.isShuttingDown) return;
-
-        try {
-            // Ensure logger is working
-            this.ensureLogger();
-
-            // Ensure context is properly stringified
-            const safeContext = context ? this.sanitizeContext(context) : undefined;
-            
-            this.logger.log({
-                level,
-                message,
-                timestamp: Date.now(),
-                ...safeContext
-            });
-        } catch (error) {
-            // If logging fails, write to stderr as fallback
-            const fallbackMessage = JSON.stringify({
-                level,
-                message,
-                timestamp: Date.now(),
-                error: this.formatError(error)
-            });
-            process.stderr.write(fallbackMessage + '\n');
-        }
-    }
-
-    /**
-     * Sanitizes context objects for logging
-     */
-    private sanitizeContext(context: Record<string, unknown>): Record<string, unknown> {
-        const sanitized: Record<string, unknown> = {};
-        
-        for (const [key, value] of Object.entries(context)) {
-            if (value instanceof Error || (value && typeof value === 'object')) {
-                sanitized[key] = this.formatError(value);
-            } else {
-                sanitized[key] = value;
-            }
-        }
-        
-        return sanitized;
-    }
-}
-
-/**
- * Creates a logger instance with default configuration
- */
-export function createDefaultLogger(): Logger {
-    try {
-        return Logger.getInstance();
-    } catch (error) {
-        throw new BaseError({
-            code: ErrorCodes.STORAGE_INIT,
-            message: 'Failed to create default logger',
-            details: { error: error instanceof Error ? error.message : String(error) }
-        });
-    }
-}
-
-/**
- * Re-export types
- */
-export type { LogLevel, LoggerConfig } from '../types/logging.js';
+export { Logger } from './logger.js';
+export { FileTransport } from './file-transport.js';
+export { TransportManager } from './transport-manager.js';
+export { ErrorFormatter } from './error-formatter.js';
+export { LoggerHealthMonitor } from './health-monitor.js';
+
+// Re-export types
+export type {
+    LogLevel,
+    LoggerConfig,
+    LogEntry,
+    LogMetadata,
+    LoggerTransportConfig,
+    LoggerHealthStatus,
+    LoggerRecoveryOptions
+} from '../types/logging.js';
+
+// Export log levels
 export { LogLevels } from '../types/logging.js';
diff --git a/src/server/health-monitor.ts b/src/server/health-monitor.ts
index d3eda40..c872743 100644
--- a/src/server/health-monitor.ts
+++ b/src/server/health-monitor.ts
@@ -48,10 +48,10 @@ export class HealthMonitor {
     constructor(config: HealthConfig = {}) {
         this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
         this.config = {
-            checkInterval: config.checkInterval || 30000,      // 30 seconds
-            failureThreshold: config.failureThreshold || 3,    // 3 strikes
-            shutdownGracePeriod: config.shutdownGracePeriod || 5000, // 5 seconds
-            clientPingTimeout: config.clientPingTimeout || 60000 // 1 minute
+            checkInterval: config.checkInterval || 300000,     // 5 minutes
+            failureThreshold: config.failureThreshold || 5,    // 5 strikes
+            shutdownGracePeriod: config.shutdownGracePeriod || 10000, // 10 seconds
+            clientPingTimeout: config.clientPingTimeout || 300000 // 5 minutes
         };
     }
 
diff --git a/src/server/index.ts b/src/server/index.ts
index 4b9d1c6..ccc97e9 100644
--- a/src/server/index.ts
+++ b/src/server/index.ts
@@ -20,9 +20,15 @@ import { RequestTracer, TraceEvent } from './request-tracer.js';
 export interface ServerConfig {
     name: string;
     version: string;
-    maxRequestsPerMinute?: number;
-    requestTimeout?: number;
-    shutdownTimeout?: number;
+    maxRequestsPerMinute: number;
+    requestTimeout: number;
+    shutdownTimeout: number;
+    health?: {
+        checkInterval?: number;      // How often to run health checks (ms)
+        failureThreshold?: number;   // How many consecutive failures before shutdown
+        shutdownGracePeriod?: number; // How long to wait before force shutdown (ms)
+        clientPingTimeout?: number;  // How long to wait for client ping (ms)
+    };
 }
 
 export interface ToolHandler {
@@ -112,10 +118,10 @@ export class AtlasServer {
         // Initialize components
         this.rateLimiter = new RateLimiter(config.maxRequestsPerMinute || 600);
         this.healthMonitor = new HealthMonitor({
-            checkInterval: 30000,
-            failureThreshold: 3,
-            shutdownGracePeriod: config.shutdownTimeout || 30000,
-            clientPingTimeout: 60000
+            checkInterval: config.health?.checkInterval || 300000,
+            failureThreshold: config.health?.failureThreshold || 5,
+            shutdownGracePeriod: config.health?.shutdownGracePeriod || 10000,
+            clientPingTimeout: config.health?.clientPingTimeout || 300000
         });
         this.metricsCollector = new MetricsCollector();
         this.requestTracer = new RequestTracer();
@@ -324,7 +330,7 @@ export class AtlasServer {
             } catch (error) {
                 AtlasServer.logger.error('Health check error:', { error });
             }
-        }, 30000);
+        }, this.config.health?.checkInterval || 300000);
     }
 
     /**
diff --git a/src/storage/core/transactions/manager.ts b/src/storage/core/transactions/manager.ts
index 83b01e4..7c7eadb 100644
--- a/src/storage/core/transactions/manager.ts
+++ b/src/storage/core/transactions/manager.ts
@@ -1,6 +1,6 @@
 import { Database } from 'sqlite';
 import { Logger } from '../../../logging/index.js';
-import { ErrorCodes, createError } from '../../../errors/index.js';
+import { ErrorCodes, createError, type ErrorCode } from '../../../errors/index.js';
 import { EventManager } from '../../../events/event-manager.js';
 import { EventTypes } from '../../../types/events.js';
 import crypto from 'crypto';
@@ -13,6 +13,25 @@ export interface TransactionState {
     id: string;
 }
 
+/**
+ * Helper function to create errors with consistent operation naming
+ */
+function createTransactionError(
+    code: ErrorCode,
+    message: string,
+    operation: string = 'TransactionManager',
+    userMessage?: string,
+    metadata?: Record<string, unknown>
+): Error {
+    return createError(
+        code,
+        message,
+        `TransactionManager.${operation}`,
+        userMessage,
+        metadata
+    );
+}
+
 export class TransactionManager {
     private static instance: TransactionManager;
     private readonly logger: Logger;
@@ -85,11 +104,11 @@ export class TransactionManager {
             return txId;
         } catch (error) {
             this.logger.error('Failed to begin transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to begin transaction',
                 'beginTransaction',
-                undefined,
+                'Could not start database transaction',
                 { originalError: error }
             );
         }
@@ -101,9 +120,11 @@ export class TransactionManager {
     async commitTransaction(db: Database, txId: string): Promise<void> {
         const transaction = this.activeTransactions.get(txId);
         if (!transaction) {
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
-                'No active transaction to commit'
+                'No active transaction to commit',
+                'commitTransaction',
+                'Transaction not found or already completed'
             );
         }
 
@@ -142,11 +163,11 @@ export class TransactionManager {
             });
         } catch (error) {
             this.logger.error('Failed to commit transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to commit transaction',
                 'commitTransaction',
-                undefined,
+                'Could not commit database changes',
                 { originalError: error }
             );
         }
@@ -158,9 +179,11 @@ export class TransactionManager {
     async rollbackTransaction(db: Database, txId: string): Promise<void> {
         const transaction = this.activeTransactions.get(txId);
         if (!transaction) {
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
-                'No active transaction to rollback'
+                'No active transaction to rollback',
+                'rollbackTransaction',
+                'Transaction not found or already completed'
             );
         }
 
@@ -199,11 +222,11 @@ export class TransactionManager {
             });
         } catch (error) {
             this.logger.error('Failed to rollback transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to rollback transaction',
                 'rollbackTransaction',
-                undefined,
+                'Could not rollback database changes',
                 { originalError: error }
             );
         }
diff --git a/src/storage/core/transactions/scope.ts b/src/storage/core/transactions/scope.ts
index 8f51c3b..62c3142 100644
--- a/src/storage/core/transactions/scope.ts
+++ b/src/storage/core/transactions/scope.ts
@@ -1,6 +1,6 @@
 import { Database } from 'sqlite';
 import { Logger } from '../../../logging/index.js';
-import { ErrorCodes, createError } from '../../../errors/index.js';
+import { ErrorCodes, createError, type ErrorCode } from '../../../errors/index.js';
 
 export enum IsolationLevel {
     READ_UNCOMMITTED = 'READ UNCOMMITTED',
@@ -9,6 +9,25 @@ export enum IsolationLevel {
     SERIALIZABLE = 'SERIALIZABLE'
 }
 
+/**
+ * Helper function to create errors with consistent operation naming
+ */
+function createTransactionError(
+    code: ErrorCode,
+    message: string,
+    operation: string = 'TransactionScope',
+    userMessage?: string,
+    metadata?: Record<string, unknown>
+): Error {
+    return createError(
+        code,
+        message,
+        `TransactionScope.${operation}`,
+        userMessage,
+        metadata
+    );
+}
+
 /**
  * Manages database transaction lifecycle and isolation levels
  * Supports nested transactions through savepoints
@@ -52,12 +71,12 @@ export class TransactionScope {
             });
         } catch (error) {
             TransactionScope.getLogger().error('Failed to begin transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
-                
                 'Failed to begin transaction',
                 'begin',
-                error instanceof Error ? error.message : String(error)
+                'Could not start database transaction',
+                { isolationLevel, error }
             );
         }
     }
@@ -67,9 +86,11 @@ export class TransactionScope {
      */
     async commit(): Promise<void> {
         if (!this.active) {
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
-                'No active transaction'
+                'No active transaction',
+                'commit',
+                'Cannot commit: no active transaction found'
             );
         }
 
@@ -92,11 +113,12 @@ export class TransactionScope {
             });
         } catch (error) {
             TransactionScope.getLogger().error('Failed to commit transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to commit transaction',
                 'commit',
-                error instanceof Error ? error.message : String(error)
+                'Could not commit database changes',
+                { depth: this.depth, error }
             );
         }
     }
@@ -127,11 +149,12 @@ export class TransactionScope {
             });
         } catch (error) {
             TransactionScope.getLogger().error('Failed to rollback transaction', { error });
-            throw createError(
+            throw createTransactionError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to rollback transaction',
                 'rollback',
-                error instanceof Error ? error.message : String(error)
+                'Could not rollback database changes',
+                { depth: this.depth, error }
             );
         }
     }
@@ -151,7 +174,13 @@ export class TransactionScope {
             return result;
         } catch (error) {
             await this.rollback();
-            throw error;
+            throw createTransactionError(
+                ErrorCodes.TRANSACTION_ERROR,
+                'Transaction execution failed',
+                'executeInTransaction',
+                'Operation failed and was rolled back',
+                { isolationLevel, error }
+            );
         }
     }
 
@@ -177,7 +206,13 @@ export class TransactionScope {
                 error,
                 level
             });
-            throw error;
+            throw createTransactionError(
+                ErrorCodes.TRANSACTION_ERROR,
+                'Failed to set isolation level',
+                'setIsolationLevel',
+                'Could not configure transaction isolation',
+                { level, error }
+            );
         }
     }
 
diff --git a/src/storage/factory.ts b/src/storage/factory.ts
index dc1f9a9..e5ae693 100644
--- a/src/storage/factory.ts
+++ b/src/storage/factory.ts
@@ -2,17 +2,11 @@
  * Storage factory for creating task storage instances
  */
 import { TaskStorage } from '../types/storage.js';
-import { ErrorCodes, createError } from '../errors/index.js';
-import { 
-    SqliteStorage,
-    SqliteConfig,
-    DEFAULT_PAGE_SIZE,
-    DEFAULT_CACHE_SIZE,
-    DEFAULT_BUSY_TIMEOUT
-} from './sqlite/index.js';
+import { SqliteStorage, SqliteConfig, DEFAULT_CONFIG } from './sqlite/index.js';
 import { ConfigManager } from '../config/index.js';
 import { promises as fs } from 'fs';
 import { Logger } from '../logging/index.js';
+import { StorageFactoryErrorHandler } from './factory/error-handler.js';
 
 /**
  * Storage factory class for managing singleton storage instance
@@ -22,6 +16,7 @@ class StorageFactory {
     private static initializationPromise: Promise<StorageFactory> | null = null;
     private storageInstance: TaskStorage | null = null;
     private static logger: Logger;
+    private readonly errorHandler: StorageFactoryErrorHandler;
 
     private static initLogger(): void {
         if (!StorageFactory.logger) {
@@ -31,6 +26,7 @@ class StorageFactory {
 
     private constructor() {
         StorageFactory.initLogger();
+        this.errorHandler = new StorageFactoryErrorHandler();
     }
 
     /**
@@ -58,16 +54,23 @@ class StorageFactory {
                 StorageFactory.instance = new StorageFactory();
                 return StorageFactory.instance;
             } catch (error) {
-                throw createError(
-                    ErrorCodes.STORAGE_INIT,
-                    `Failed to initialize StorageFactory: ${error instanceof Error ? error.message : String(error)}`
-                );
+                const handler = new StorageFactoryErrorHandler();
+                return handler.handleInitError(error, 'getInstance');
             } finally {
                 StorageFactory.initializationPromise = null;
             }
         })();
 
-        return StorageFactory.initializationPromise;
+        const instance = await StorageFactory.initializationPromise;
+        if (!instance) {
+            const handler = new StorageFactoryErrorHandler();
+            return handler.handleInitError(
+                new Error('Failed to initialize StorageFactory'),
+                'getInstance'
+            );
+        }
+
+        return instance;
     }
 
     /**
@@ -94,22 +97,18 @@ class StorageFactory {
 
             // Apply SQLite-specific defaults
             const sqliteConfig: SqliteConfig = {
+                ...DEFAULT_CONFIG,
                 ...config,
                 sqlite: {
-                    journalMode: 'WAL',
-                    synchronous: 'NORMAL',
-                    tempStore: 'MEMORY',
-                    lockingMode: 'NORMAL',
-                    autoVacuum: 'NONE',
+                    ...DEFAULT_CONFIG.sqlite,
                     ...config.sqlite
                 },
                 performance: {
-                    pageSize: DEFAULT_PAGE_SIZE,
-                    cacheSize: DEFAULT_CACHE_SIZE,
+                    ...DEFAULT_CONFIG.performance,
                     ...config.performance
                 },
                 connection: {
-                    busyTimeout: DEFAULT_BUSY_TIMEOUT,
+                    ...DEFAULT_CONFIG.connection,
                     ...config.connection
                 }
             };
@@ -125,14 +124,7 @@ class StorageFactory {
         } catch (error) {
             // Clear storage instance on error
             this.storageInstance = null;
-            StorageFactory.logger.error('Failed to create storage instance', {
-                error: error instanceof Error ? error.message : String(error)
-            });
-            throw createError(
-                ErrorCodes.STORAGE_INIT,
-                'Failed to create storage',
-                error instanceof Error ? error.message : String(error)
-            );
+            return this.errorHandler.handleCreateError(error, 'createStorage', { config });
         }
     }
 
@@ -151,20 +143,16 @@ class StorageFactory {
             const config = configManager.getConfig();
             
             if (!config.storage) {
-                throw new Error('Storage configuration not found in ConfigManager');
+                return this.errorHandler.handleCreateError(
+                    new Error('Storage configuration not found in ConfigManager'),
+                    'createDefaultStorage'
+                );
             }
 
             StorageFactory.logger.info('Creating default storage instance');
             return this.createStorage(config.storage as SqliteConfig);
         } catch (error) {
-            StorageFactory.logger.error('Failed to create default storage', {
-                error: error instanceof Error ? error.message : String(error)
-            });
-            throw createError(
-                ErrorCodes.STORAGE_INIT,
-                'Failed to create default storage',
-                error instanceof Error ? error.message : String(error)
-            );
+            return this.errorHandler.handleCreateError(error, 'createDefaultStorage');
         }
     }
 }
diff --git a/src/storage/sqlite-storage.ts b/src/storage/sqlite-storage.ts
index 941e8aa..9416d21 100644
--- a/src/storage/sqlite-storage.ts
+++ b/src/storage/sqlite-storage.ts
@@ -396,7 +396,8 @@ const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
         if (!this.db) {
             throw createError(
                 ErrorCodes.STORAGE_ERROR,
-                'Database not initialized'
+                'Database not initialized',
+                'withDb'
             );
         }
         return operation(this.db);
diff --git a/src/storage/sqlite/index.ts b/src/storage/sqlite/index.ts
index b209646..a1bacfd 100644
--- a/src/storage/sqlite/index.ts
+++ b/src/storage/sqlite/index.ts
@@ -1,33 +1,22 @@
-/**
- * SQLite Storage Implementation
- * 
- * This module provides a SQLite-based implementation of the TaskStorage interface,
- * with support for:
- * - Task CRUD operations
- * - Transaction management
- * - Database maintenance
- * - Performance monitoring
- * - Data integrity verification
- */
-
-// Core initialization and cleanup
-export { 
-    initializeSqliteStorage  // Initialize SQLite storage cleanup handlers
-} from './init.js';
-
-// Storage implementation and configuration
+export { SqliteStorage } from './storage.js';
 export { 
-    SqliteStorage,           // Main storage class implementing TaskStorage interface
-    SqliteConfig,            // Configuration interface for SQLite storage
-    DEFAULT_PAGE_SIZE,       // Default SQLite page size (4KB)
-    DEFAULT_CACHE_SIZE,      // Default cache size (2000 pages)
-    DEFAULT_BUSY_TIMEOUT     // Default busy timeout (5000ms)
-} from './storage.js';
+    SqliteErrorHandler,
+    createStorageError,
+    formatErrorDetails
+} from './error-handler.js';
+export {
+    DEFAULT_PAGE_SIZE,
+    DEFAULT_CACHE_SIZE,
+    DEFAULT_BUSY_TIMEOUT,
+    DEFAULT_CONFIG,
+    type SqliteConfig,
+    type SqliteOptions
+} from './config.js';
 
-// Re-export task types for convenience
-export type {
-    Task,
-    TaskStatus,
-    CreateTaskInput,
-    UpdateTaskInput
-} from '../../types/task.js';
+// Re-export types
+export type { 
+    StorageConfig,
+    TaskStorage,
+    StorageMetrics,
+    CacheStats
+} from '../../types/storage.js';
diff --git a/src/task-manager.ts b/src/task-manager.ts
index 2fb7cde..4f0cb05 100644
--- a/src/task-manager.ts
+++ b/src/task-manager.ts
@@ -32,13 +32,14 @@ export class TaskManager {
     private readonly indexManager: TaskIndexManager;
     private memoryMonitor?: NodeJS.Timeout;
     private readonly MAX_CACHE_MEMORY = 1024 * 1024 * 1024; // 1GB cache limit
-    private readonly MEMORY_CHECK_INTERVAL = 60000; // 60 seconds
-    private readonly MEMORY_PRESSURE_THRESHOLD = 0.9; // 90% of max before cleanup
+    private readonly MEMORY_CHECK_INTERVAL = 300000; // 5 minutes
+    private readonly MEMORY_PRESSURE_THRESHOLD = 0.95; // 95% of max before cleanup
+    private readonly MEMORY_CHECK_COOLDOWN = 60000; // 1 minute cooldown between cleanups
+    private lastCleanupTime: number = 0;
 
     private readonly eventManager: EventManager;
 
     private static instance: TaskManager | null = null;
-    private static initializationPromise: Promise<TaskManager> | null = null;
     private initialized = false;
 
     private constructor(readonly storage: TaskStorage) {
@@ -81,39 +82,54 @@ export class TaskManager {
     /**
      * Gets the TaskManager instance
      */
+    private static initializationMutex = new Set<string>();
+    private static instanceId = Math.random().toString(36).substr(2, 9);
+
     static async getInstance(storage: TaskStorage): Promise<TaskManager> {
-        // Return existing instance if available
-        if (TaskManager.instance && TaskManager.instance.initialized) {
+        const mutexKey = `taskmanager-${TaskManager.instanceId}`;
+        
+        // Return existing instance if fully initialized
+        if (TaskManager.instance?.initialized) {
             return TaskManager.instance;
         }
 
-        // If initialization is in progress, wait for it
-        if (TaskManager.initializationPromise) {
-            return TaskManager.initializationPromise;
+        // Wait if initialization is in progress
+        while (TaskManager.initializationMutex.has(mutexKey)) {
+            await new Promise(resolve => setTimeout(resolve, 50));
         }
 
-        // Start new initialization with mutex
-        TaskManager.initializationPromise = (async () => {
-            try {
-                // Double-check instance hasn't been created while waiting
-                if (TaskManager.instance && TaskManager.instance.initialized) {
-                    return TaskManager.instance;
-                }
+        // Double-check after waiting
+        if (TaskManager.instance?.initialized) {
+            return TaskManager.instance;
+        }
+
+        // Acquire initialization mutex
+        TaskManager.initializationMutex.add(mutexKey);
 
+        try {
+            // Create new instance if needed
+            if (!TaskManager.instance) {
                 TaskManager.instance = new TaskManager(storage);
+            }
+
+            // Initialize if not already done
+            if (!TaskManager.instance.initialized) {
                 await TaskManager.instance.initialize();
-                return TaskManager.instance;
-            } catch (error) {
-                throw createError(
-                    ErrorCodes.STORAGE_INIT,
-                    `Failed to initialize TaskManager: ${error instanceof Error ? error.message : String(error)}`
-                );
-            } finally {
-                TaskManager.initializationPromise = null;
             }
-        })();
 
-        return TaskManager.initializationPromise;
+            return TaskManager.instance;
+        } catch (error) {
+            // Clear instance on initialization failure
+            TaskManager.instance = null;
+            throw createError(
+                ErrorCodes.STORAGE_INIT,
+                `Failed to initialize TaskManager: ${error instanceof Error ? error.message : String(error)}`,
+                'getInstance'
+            );
+        } finally {
+            // Release mutex
+            TaskManager.initializationMutex.delete(mutexKey);
+        }
     }
 
     /**
@@ -152,6 +168,73 @@ export class TaskManager {
         }
     }
 
+    /**
+     * Sets up memory monitoring for cache management
+     */
+    private setupMemoryMonitoring(): void {
+        // Clear any existing monitor
+        if (this.memoryMonitor) {
+            clearInterval(this.memoryMonitor);
+        }
+
+        // Set up new monitor with weak reference to this
+        const weakThis = new WeakRef(this);
+        
+        this.memoryMonitor = setInterval(async () => {
+            const instance = weakThis.deref();
+            if (!instance) {
+                // If instance is garbage collected, stop monitoring
+                clearInterval(this.memoryMonitor);
+                return;
+            }
+
+            const memUsage = process.memoryUsage();
+            
+            // Log memory stats with Windows-specific handling
+            const stats = {
+                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
+                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
+                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
+                // Windows can have different memory reporting
+                platform: process.platform
+            };
+            
+            TaskManager.logger.debug('Task manager memory usage:', stats);
+
+            // Check if memory usage is approaching threshold
+            const memoryUsageRatio = memUsage.heapUsed / instance.MAX_CACHE_MEMORY;
+            
+            const now = Date.now();
+            if (memoryUsageRatio > instance.MEMORY_PRESSURE_THRESHOLD && 
+                (now - instance.lastCleanupTime) >= instance.MEMORY_CHECK_COOLDOWN) {
+                instance.lastCleanupTime = now;
+                // Emit memory pressure event
+                instance.eventManager.emitCacheEvent({
+                    type: EventTypes.MEMORY_PRESSURE,
+                    timestamp: Date.now(),
+                    metadata: {
+                        memoryUsage: memUsage,
+                        threshold: instance.MAX_CACHE_MEMORY
+                    }
+                });
+
+                TaskManager.logger.warn('Cache memory threshold exceeded, clearing caches', {
+                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
+                    threshold: `${Math.round(instance.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
+                });
+                
+                await instance.clearCaches(true);
+            }
+        }, this.MEMORY_CHECK_INTERVAL);
+
+        // Ensure interval is cleaned up if process exits
+        process.on('beforeExit', () => {
+            if (this.memoryMonitor) {
+                clearInterval(this.memoryMonitor);
+            }
+        });
+    }
+
     /**
      * Creates a new task with path-based hierarchy
      */
@@ -161,7 +244,8 @@ export class TaskManager {
             if (!input.name) {
                 throw createError(
                     ErrorCodes.VALIDATION_ERROR,
-                    'Task name is required'
+                    'Task name is required',
+                    'createTask'
                 );
             }
 
@@ -215,7 +299,8 @@ export class TaskManager {
             if (!oldTask) {
                 throw createError(
                     ErrorCodes.TASK_NOT_FOUND,
-                    `Task not found: ${path}`
+                    `Task not found: ${path}`,
+                    'updateTask'
                 );
             }
 
@@ -479,6 +564,7 @@ export class TaskManager {
             await this.operations.deleteTask(path);
             return {
                 success: true,
+                data: undefined,
                 metadata: {
                     timestamp: Date.now(),
                     requestId: Math.random().toString(36).substring(7),
@@ -612,70 +698,6 @@ export class TaskManager {
         }
     }
 
-    /**
-     * Sets up memory monitoring for cache management
-     */
-    private setupMemoryMonitoring(): void {
-        // Clear any existing monitor
-        if (this.memoryMonitor) {
-            clearInterval(this.memoryMonitor);
-        }
-
-        // Set up new monitor with weak reference to this
-        const weakThis = new WeakRef(this);
-        
-        this.memoryMonitor = setInterval(async () => {
-            const instance = weakThis.deref();
-            if (!instance) {
-                // If instance is garbage collected, stop monitoring
-                clearInterval(this.memoryMonitor);
-                return;
-            }
-
-            const memUsage = process.memoryUsage();
-            
-            // Log memory stats with Windows-specific handling
-            const stats = {
-                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
-                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
-                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
-                // Windows can have different memory reporting
-                platform: process.platform
-            };
-            
-            TaskManager.logger.debug('Task manager memory usage:', stats);
-
-            // Check if memory usage is approaching threshold
-            const memoryUsageRatio = memUsage.heapUsed / instance.MAX_CACHE_MEMORY;
-            
-            if (memoryUsageRatio > instance.MEMORY_PRESSURE_THRESHOLD) {
-                // Emit memory pressure event
-                instance.eventManager.emitCacheEvent({
-                    type: EventTypes.MEMORY_PRESSURE,
-                    timestamp: Date.now(),
-                    metadata: {
-                        memoryUsage: memUsage,
-                        threshold: instance.MAX_CACHE_MEMORY
-                    }
-                });
-
-                TaskManager.logger.warn('Cache memory threshold exceeded, clearing caches', {
-                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
-                    threshold: `${Math.round(instance.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
-                });
-                
-                await instance.clearCaches(true);
-            }
-        }, this.MEMORY_CHECK_INTERVAL);
-
-        // Ensure interval is cleaned up if process exits
-        process.on('beforeExit', () => {
-            if (this.memoryMonitor) {
-                clearInterval(this.memoryMonitor);
-            }
-        });
-    }
-
     /**
      * Clears all caches to free memory
      */
@@ -819,7 +841,8 @@ export class TaskManager {
                                 if (!op.data || !('type' in op.data)) {
                                     throw createError(
                                         ErrorCodes.INVALID_INPUT,
-                                        'Create operation requires valid task input'
+                                        'Create operation requires valid task input',
+                                        'bulkTaskOperations'
                                     );
                                 }
                                 const created = await this.operations.createTask(op.data as CreateTaskInput);
@@ -845,14 +868,16 @@ export class TaskManager {
                                 if (!op.data) {
                                     throw createError(
                                         ErrorCodes.INVALID_INPUT,
-                                        'Update operation requires task updates'
+                                        'Update operation requires task updates',
+                                        'bulkTaskOperations'
                                     );
                                 }
                                 const oldTask = await this.getTaskByPath(op.path);
                                 if (!oldTask) {
                                     throw createError(
                                         ErrorCodes.TASK_NOT_FOUND,
-                                        `Task not found: ${op.path}`
+                                        `Task not found: ${op.path}`,
+                                        'bulkTaskOperations'
                                     );
                                 }
 
diff --git a/src/task/core/batch/status-update-batch.ts b/src/task/core/batch/status-update-batch.ts
index a906013..e404b07 100644
--- a/src/task/core/batch/status-update-batch.ts
+++ b/src/task/core/batch/status-update-batch.ts
@@ -74,6 +74,7 @@ export class StatusUpdateBatch {
             throw createError(
                 ErrorCodes.OPERATION_FAILED,
                 'Failed to execute status update batch',
+                'execute',
                 String(error)
             );
         } finally {
@@ -95,7 +96,8 @@ export class StatusUpdateBatch {
             if (visiting.has(path)) {
                 throw createError(
                     ErrorCodes.INVALID_STATE,
-                    `Circular dependency detected: ${path}`
+                    `Circular dependency detected: ${path}`,
+                    'orderUpdatesByDependencies'
                 );
             }
 
diff --git a/src/task/core/index.ts b/src/task/core/index.ts
index 79e3720..f66b378 100644
--- a/src/task/core/index.ts
+++ b/src/task/core/index.ts
@@ -1,10 +1,58 @@
-/**
- * Task Core Module
- * 
- * Provides core task management functionality:
- * - Task storage and persistence
- * - Dependency validation
- * - Status management
- */
-
-export * from './task-store.js';
+export { TaskStore } from './task-store.js';
+export { 
+    TaskErrorHandler,
+    createTaskError
+} from './error-handler.js';
+
+// Re-export batch processors
+export {
+    TaskStatusBatchProcessor,
+    DependencyAwareBatchProcessor,
+    BaseBatchProcessor,
+    type BatchDependencies,
+    type BatchOptions
+} from './batch/index.js';
+
+// Re-export batch utils
+export {
+    type BatchData,
+    type BatchResult,
+    type ValidationResult,
+    type TaskBatchData,
+    BatchUtils
+} from './batch/common/batch-utils.js';
+
+// Re-export cache management
+export {
+    CacheManager
+} from './cache/index.js';
+
+// Re-export cache types
+export type {
+    CacheOptions,
+    CacheStats,
+    CacheEntry,
+    CacheMetricsData,
+    CacheCoordinatorOptions,
+    TaskCacheEntry
+} from '../../types/cache.js';
+
+// Re-export indexing
+export {
+    TaskIndexManager
+} from './indexing/index.js';
+
+// Re-export transactions
+export {
+    TransactionManager
+} from './transactions/index.js';
+
+// Re-export types
+export type { 
+    Task,
+    TaskStatus,
+    TaskType,
+    CreateTaskInput,
+    UpdateTaskInput,
+    TaskResponse
+} from '../../types/task.js';
diff --git a/src/task/core/task-store.ts b/src/task/core/task-store.ts
index 5796578..ee99ac9 100644
--- a/src/task/core/task-store.ts
+++ b/src/task/core/task-store.ts
@@ -1,18 +1,36 @@
 /**
  * Path-based task storage with caching, indexing, and transaction support
  */
-import { Task, TaskStatus, getParentPath } from '../../types/task.js';
-import { isValidTaskHierarchy } from '../validation/index.js';
+import { Task, TaskStatus } from '../../types/task.js';
 import { PathValidator } from '../../validation/index.js';
 import { TaskStorage } from '../../types/storage.js';
 import { Logger } from '../../logging/index.js';
 import { TaskIndexManager } from './indexing/index-manager.js';
 import { CacheManager } from './cache/cache-manager.js';
-import { ErrorCodes, createError } from '../../errors/index.js';
+import { ErrorCodes, createError, type ErrorCode } from '../../errors/index.js';
 import { TransactionManager } from './transactions/transaction-manager.js';
 
 const BATCH_SIZE = 50; // Maximum number of tasks to process in parallel
 
+/**
+ * Helper function to create errors with consistent operation naming
+ */
+function createTaskStoreError(
+    code: ErrorCode,
+    message: string,
+    operation: string = 'TaskStore',
+    userMessage?: string,
+    metadata?: Record<string, unknown>
+): Error {
+    return createError(
+        code,
+        message,
+        `TaskStore.${operation}`,
+        userMessage,
+        metadata
+    );
+}
+
 export class TaskStore {
     private readonly logger: Logger;
     private readonly indexManager: TaskIndexManager;
@@ -129,41 +147,18 @@ export class TaskStore {
         };
     }
 
-    /**
-     * Processes tasks in batches with memory-efficient processing
-     */
-    private async processBatch<T>(
-        items: T[],
-        processor: (item: T) => Promise<void>
-    ): Promise<void> {
-        // Process in smaller chunks to avoid memory spikes
-        const chunkSize = Math.min(BATCH_SIZE, 10);
-        for (let i = 0; i < items.length; i += chunkSize) {
-            const chunk = items.slice(i, i + chunkSize);
-            
-            // Process items sequentially in chunk to reduce memory pressure
-            for (const item of chunk) {
-                await processor(item);
-            }
-
-            // Allow GC between chunks
-            if (i > 0 && i % (chunkSize * 5) === 0) {
-                if (global.gc) {
-                    global.gc();
-                }
-            }
-        }
-    }
-
     /**
      * Gets a task by path, checking cache first
+     * @internal Used by getTasksByPattern, getTasksByStatus, and getSubtasks
      */
-    private async getTaskByPath(path: string): Promise<Task | null> {
+    /* istanbul ignore next */
+    protected async getTaskByPath(path: string): Promise<Task | null> {
         const pathResult = this.pathValidator.validatePath(path);
         if (!pathResult.isValid) {
-            throw createError(
+            throw createTaskStoreError(
                 ErrorCodes.TASK_INVALID_PATH,
-                pathResult.error || `Invalid task path: ${path}`
+                pathResult.error || `Invalid task path: ${path}`,
+                'getTaskByPath'
             );
         }
 
@@ -190,188 +185,6 @@ export class TaskStore {
         return task;
     }
 
-    /**
-     * Updates dependent task statuses
-     */
-    private async updateDependentStatuses(task: Task): Promise<void> {
-        const dependentTasks = await this.indexManager.getDependentTasks(task.path);
-        
-        for (const depTask of dependentTasks) {
-            const taskPath = depTask.path;
-            const updatedTask = await this.getTaskByPath(taskPath);
-            if (!updatedTask) continue;
-
-            // If a dependency fails or is blocked, block the dependent task
-            if (task.status === TaskStatus.FAILED || task.status === TaskStatus.BLOCKED) {
-                updatedTask.status = TaskStatus.BLOCKED;
-                await this.saveTasks([updatedTask]);
-            }
-            // If all dependencies are complete, unblock the dependent task
-            else if (task.status === TaskStatus.COMPLETED) {
-                const allDepsCompleted = await this.checkAllDependenciesCompleted(updatedTask);
-                if (allDepsCompleted) {
-                    updatedTask.status = TaskStatus.PENDING;
-                    await this.saveTasks([updatedTask]);
-                }
-            }
-        }
-    }
-
-    /**
-     * Checks if all dependencies are completed
-     */
-    private async checkAllDependenciesCompleted(task: Task): Promise<boolean> {
-        for (const depPath of task.dependencies) {
-            const depTask = await this.getTaskByPath(depPath);
-            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Saves tasks with validation, indexing, and transaction support
-     */
-    async saveTasks(tasks: Task[]): Promise<void> {
-        // Validate paths and collect parent updates
-        for (const task of tasks) {
-            const pathResult = this.pathValidator.validatePath(task.path);
-            if (!pathResult.isValid) {
-                throw createError(
-                    ErrorCodes.TASK_INVALID_PATH,
-                    pathResult.error || `Invalid task path: ${task.path}`
-                );
-            }
-        }
-
-        const transaction = await this.transactionManager.begin();
-
-        try {
-            // First pass: validate all tasks and collect parent paths
-            const parentPaths = new Set<string>();
-            const tasksToSave = new Map<string, Task>();
-
-            for (const task of tasks) {
-                // Ensure task has required arrays
-                if (!task.subtasks) task.subtasks = [];
-                if (!task.dependencies) task.dependencies = [];
-
-                // Get and validate parent path
-                const parentPath = task.parentPath || getParentPath(task.path);
-                if (parentPath) {
-                    task.parentPath = parentPath;
-                    parentPaths.add(parentPath);
-                }
-
-                tasksToSave.set(task.path, task);
-            }
-
-            // Second pass: load and validate all parents
-            const parentUpdates = new Map<string, Task>();
-            for (const parentPath of parentPaths) {
-                const parent = await this.getTaskByPath(parentPath);
-                if (!parent) {
-                    throw createError(
-                        ErrorCodes.TASK_PARENT_NOT_FOUND,
-                        `Parent task not found: ${parentPath}. Parent tasks must be created before their children.`
-                    );
-                }
-                parentUpdates.set(parentPath, parent);
-            }
-
-            // Third pass: validate relationships and update parent subtasks
-            for (const task of tasksToSave.values()) {
-                // Get the original task to check if parentPath has changed
-                const originalTask = await this.getTaskByPath(task.path);
-                
-                // If task exists and parentPath has changed, remove from old parent
-                if (originalTask && originalTask.parentPath && originalTask.parentPath !== task.parentPath) {
-                    const oldParent = await this.getTaskByPath(originalTask.parentPath);
-                    if (oldParent) {
-                        oldParent.subtasks = oldParent.subtasks.filter(p => p !== task.path);
-                        parentUpdates.set(oldParent.path, oldParent);
-                        
-                        // Update old parent's index
-                        await this.indexManager.unindexTask(oldParent);
-                        await this.indexManager.indexTask(oldParent);
-                    }
-                }
-
-                // Handle new parent relationship
-                if (task.parentPath) {
-                    const parent = parentUpdates.get(task.parentPath) || await this.getTaskByPath(task.parentPath);
-                    if (!parent) {
-                        throw createError(
-                            ErrorCodes.TASK_PARENT_NOT_FOUND,
-                            `Parent task not found: ${task.parentPath}. Parent tasks must be created before their children.`
-                        );
-                    }
-
-                    // Validate task type hierarchy
-                    if (!isValidTaskHierarchy(parent.type, task.type)) {
-                        throw createError(
-                            ErrorCodes.TASK_PARENT_TYPE,
-                            `Invalid parent-child relationship: ${parent.type} cannot contain ${task.type}`
-                        );
-                    }
-
-                    // Update and index parent's subtasks if needed
-                    if (!parent.subtasks.includes(task.path)) {
-                        parent.subtasks = [...parent.subtasks, task.path];
-                        parentUpdates.set(parent.path, parent);
-                        
-                        // Ensure parent-child relationship is indexed
-                        await this.indexManager.unindexTask(parent);
-                        await this.indexManager.indexTask(parent);
-                    }
-                }
-            }
-
-            // Prepare final task list with updated relationships
-            const allTasks = [...parentUpdates.values(), ...tasksToSave.values()];
-            await this.storage.saveTasks(allTasks);
-
-            // Clear cache for all affected tasks
-            await Promise.all(allTasks.map(task => this.cacheManager.delete(task.path)));
-
-            // Reindex all tasks to ensure relationships are properly established
-            for (const task of allTasks) {
-                await this.indexManager.indexTask(task);
-                await this.cacheManager.set(task.path, task);
-            }
-
-            // Validate dependencies for original tasks
-            for (const task of tasks) {
-                await this.validateDependencies(task.path, task.dependencies);
-            }
-
-            // Propagate status changes
-            await this.processBatch(tasks, async task => {
-                await this.updateDependentStatuses(task);
-            });
-
-            await this.transactionManager.commit(transaction);
-
-            this.logger.debug('Tasks saved successfully', {
-                count: tasks.length,
-                paths: tasks.map(t => t.path)
-            });
-        } catch (error) {
-            // Rollback transaction
-            await this.transactionManager.rollback(transaction);
-
-            // Rollback cache and indexes
-            await this.processBatch(tasks, async task => {
-                await this.indexManager.unindexTask(task);
-                await this.cacheManager.delete(task.path);
-            });
-
-            this.logger.error('Failed to save tasks', { error, tasks });
-            throw error;
-        }
-    }
-
     /**
      * Gets tasks by path pattern with efficient caching
      */
@@ -411,7 +224,13 @@ export class TaskStore {
             return tasks;
         } catch (error) {
             this.logger.error('Failed to get tasks by pattern', { error, pattern });
-            throw error;
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to get tasks by pattern',
+                'getTasksByPattern',
+                undefined,
+                { pattern, error }
+            );
         }
     }
 
@@ -454,7 +273,13 @@ export class TaskStore {
             return tasks;
         } catch (error) {
             this.logger.error('Failed to get tasks by status', { error, status });
-            throw error;
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to get tasks by status',
+                'getTasksByStatus',
+                undefined,
+                { status, error }
+            );
         }
     }
 
@@ -464,9 +289,10 @@ export class TaskStore {
     async getSubtasks(parentPath: string): Promise<Task[]> {
         const pathResult = this.pathValidator.validatePath(parentPath);
         if (!pathResult.isValid) {
-            throw createError(
+            throw createTaskStoreError(
                 ErrorCodes.TASK_INVALID_PATH,
-                pathResult.error || `Invalid parent path: ${parentPath}`
+                pathResult.error || `Invalid parent path: ${parentPath}`,
+                'getSubtasks'
             );
         }
 
@@ -505,73 +331,39 @@ export class TaskStore {
             return tasks;
         } catch (error) {
             this.logger.error('Failed to get subtasks', { error, parentPath });
-            throw error;
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to get subtasks',
+                'getSubtasks',
+                undefined,
+                { parentPath, error }
+            );
         }
     }
 
     /**
-     * Deletes a task and its subtasks with transaction support
+     * Processes tasks in batches with memory-efficient processing
      */
-    async deleteTask(path: string): Promise<void> {
-        const pathResult = this.pathValidator.validatePath(path);
-        if (!pathResult.isValid) {
-            throw createError(
-                ErrorCodes.TASK_INVALID_PATH,
-                pathResult.error || `Invalid task path: ${path}`
-            );
-        }
-
-        const transaction = await this.transactionManager.begin();
-
-        try {
-            // Get task and subtasks
-            const task = await this.storage.getTask(path);
-            if (!task) {
-                throw createError(
-                    ErrorCodes.TASK_NOT_FOUND,
-                    `Task not found: ${path}`
-                );
+    private async processBatch<T>(
+        items: T[],
+        processor: (item: T) => Promise<void>
+    ): Promise<void> {
+        // Process in smaller chunks to avoid memory spikes
+        const chunkSize = Math.min(BATCH_SIZE, 10);
+        for (let i = 0; i < items.length; i += chunkSize) {
+            const chunk = items.slice(i, i + chunkSize);
+            
+            // Process items sequentially in chunk to reduce memory pressure
+            for (const item of chunk) {
+                await processor(item);
             }
 
-            const subtasks = await this.storage.getSubtasks(path);
-            const allTasks = [task, ...subtasks];
-            const allPaths = allTasks.map(t => t.path);
-
-            // Add delete operation to transaction
-            for (const taskPath of allPaths) {
-                transaction.operations.push({
-                    id: `delete-${Date.now()}-${Math.random()}`,
-                    type: 'delete',
-                    timestamp: Date.now(),
-                    path: taskPath,
-                    tasks: allTasks
-                });
+            // Allow GC between chunks
+            if (i > 0 && i % (chunkSize * 5) === 0) {
+                if (global.gc) {
+                    global.gc();
+                }
             }
-
-            // Delete from storage
-            await this.storage.deleteTasks(allPaths);
-
-            // Update cache and indexes
-            await this.processBatch(allTasks, async task => {
-                await this.indexManager.unindexTask(task);
-                await this.cacheManager.delete(task.path);
-            });
-
-            // Update dependent tasks
-            await this.processBatch(allTasks, async task => {
-                await this.updateDependentStatuses(task);
-            });
-
-            await this.transactionManager.commit(transaction);
-
-            this.logger.debug('Task and subtasks deleted', {
-                path,
-                subtaskCount: subtasks.length
-            });
-        } catch (error) {
-            await this.transactionManager.rollback(transaction);
-            this.logger.error('Failed to delete task', { error, path });
-            throw error;
         }
     }
 
@@ -580,9 +372,11 @@ export class TaskStore {
      */
     async clearAllTasks(confirm: boolean): Promise<void> {
         if (!confirm) {
-            throw createError(
+            throw createTaskStoreError(
                 ErrorCodes.OPERATION_FAILED,
-                'Must explicitly confirm task deletion'
+                'Must explicitly confirm task deletion',
+                'clearAllTasks',
+                'Set confirm parameter to true to proceed with clearing all tasks'
             );
         }
 
@@ -603,7 +397,13 @@ export class TaskStore {
         } catch (error) {
             await this.transactionManager.rollback(transaction);
             this.logger.error('Failed to clear tasks', { error });
-            throw error;
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to clear all tasks',
+                'clearAllTasks',
+                undefined,
+                { error }
+            );
         }
     }
 
@@ -620,7 +420,13 @@ export class TaskStore {
             this.logger.info('Database optimized', { analyzed: analyze });
         } catch (error) {
             this.logger.error('Failed to optimize database', { error });
-            throw error;
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to optimize database',
+                'vacuumDatabase',
+                undefined,
+                { analyze, error }
+            );
         }
     }
 
@@ -652,297 +458,13 @@ export class TaskStore {
         } catch (error) {
             await this.transactionManager.rollback(transaction);
             this.logger.error('Failed to repair relationships', { error });
-            throw error;
-        }
-    }
-
-    /**
-     * Clears cache and indexes
-     */
-    async clearCache(): Promise<void> {
-        const transaction = await this.transactionManager.begin();
-
-        try {
-            await Promise.all([
-                this.indexManager.clear(),
-                this.cacheManager.clear()
-            ]);
-
-            await this.transactionManager.commit(transaction);
-            this.logger.debug('Cache cleared');
-        } catch (error) {
-            await this.transactionManager.rollback(transaction);
-            this.logger.error('Failed to clear cache', { error });
-            throw error;
-        }
-    }
-
-    /**
-     * Validates task dependencies
-     */
-    private async validateDependencies(taskPath: string, dependencies: string[]): Promise<void> {
-        try {
-            // Pre-validate dependencies exist
-            await this.preValidateDependencies(dependencies);
-
-            // Reset validation state
-            this.nodes.clear();
-
-            // Build dependency graph
-            await this.buildDependencyGraph(taskPath, dependencies);
-
-            // Check for cycles
-            this.detectCycles(taskPath);
-
-            // Validate dependency statuses
-            await this.validateDependencyStatuses();
-
-            this.logger.debug('Dependencies validated successfully', {
-                taskPath,
-                dependencies,
-                validationSteps: [
-                    'pre-validation',
-                    'graph-building',
-                    'cycle-detection',
-                    'status-validation'
-                ]
-            });
-        } catch (error) {
-            this.logger.error('Dependency validation failed', {
-                taskPath,
-                dependencies,
-                error
-            });
-            throw error;
-        }
-    }
-
-    /**
-     * Pre-validates all dependencies exist before building the graph
-     */
-    private async preValidateDependencies(dependencies: string[]): Promise<void> {
-        const missingDeps: string[] = [];
-        
-        for (const depPath of dependencies) {
-            const depTask = await this.getTaskByPath(depPath);
-            if (!depTask) {
-                missingDeps.push(depPath);
-            }
-        }
-
-        if (missingDeps.length > 0) {
-            throw createError(
-                ErrorCodes.TASK_NOT_FOUND,
-                'One or more dependency tasks not found',
-                'preValidateDependencies',
-                'Ensure all dependency tasks exist before creating relationships',
-                {
-                    missingDependencies: missingDeps,
-                    totalDependencies: dependencies.length
-                }
-            );
-        }
-    }
-
-    /**
-     * Builds the dependency graph
-     */
-    private async buildDependencyGraph(taskPath: string, dependencies: string[]): Promise<void> {
-        try {
-            // Create node for current task
-            const node = this.getOrCreateNode(taskPath);
-
-            // Process each dependency
-            for (const depPath of dependencies) {
-                const depTask = await this.getTaskByPath(depPath);
-                if (!depTask) {
-                    // This shouldn't happen due to pre-validation, but handle just in case
-                    throw createError(
-                        ErrorCodes.TASK_NOT_FOUND,
-                        'Dependency task not found during graph building',
-                        'buildDependencyGraph',
-                        undefined,
-                        {
-                            taskPath,
-                            dependencyPath: depPath,
-                            graphState: this.getGraphState()
-                        }
-                    );
-                }
-
-                // Add dependency relationship
-                node.dependencies.add(depPath);
-                const depNode = this.getOrCreateNode(depPath);
-                depNode.dependents.add(taskPath);
-
-                // Process transitive dependencies
-                await this.buildDependencyGraph(depPath, depTask.dependencies);
-            }
-        } catch (error) {
-            this.logger.error('Error building dependency graph', {
-                taskPath,
-                dependencies,
-                error,
-                graphState: this.getGraphState()
-            });
-            throw error;
-        }
-    }
-
-    /**
-     * Detects cycles in the dependency graph
-     */
-    private detectCycles(startPath: string): void {
-        const node = this.nodes.get(startPath);
-        if (!node) {
-            return;
-        }
-
-        node.visited = true;
-        node.inPath = true;
-
-        for (const depPath of node.dependencies) {
-            const depNode = this.nodes.get(depPath);
-            if (!depNode) {
-                continue;
-            }
-
-            if (!depNode.visited) {
-                this.detectCycles(depPath);
-            } else if (depNode.inPath) {
-                const cyclePath = this.getCyclePath(depPath);
-                throw createError(
-                    ErrorCodes.TASK_CYCLE,
-                    'Circular dependency detected in task graph',
-                    'detectCycles',
-                    'Remove one of the dependencies to break the cycle',
-                    {
-                        cyclePath,
-                        startPath,
-                        affectedTasks: Array.from(this.nodes.keys()),
-                        graphState: this.getGraphState()
-                    }
-                );
-            }
-        }
-
-        node.inPath = false;
-    }
-
-    /**
-     * Gets the path of a dependency cycle
-     */
-    private getCyclePath(startPath: string): string {
-        const cycle: string[] = [startPath];
-        let current = startPath;
-
-        while (true) {
-            const node = this.nodes.get(current);
-            if (!node) {
-                break;
-            }
-
-            for (const depPath of node.dependencies) {
-                const depNode = this.nodes.get(depPath);
-                if (depNode?.inPath) {
-                    cycle.push(depPath);
-                    if (depPath === startPath) {
-                        return cycle.join(' -> ');
-                    }
-                    current = depPath;
-                    break;
-                }
-            }
-        }
-
-        return cycle.join(' -> ');
-    }
-
-    /**
-     * Validates dependency task statuses
-     */
-    private async validateDependencyStatuses(): Promise<void> {
-        const statusIssues: Array<{ path: string; status: TaskStatus; issue: string }> = [];
-
-        for (const [path] of this.nodes) {
-            const task = await this.getTaskByPath(path);
-            if (!task) {
-                continue;
-            }
-
-            if (task.status === TaskStatus.FAILED) {
-                statusIssues.push({
-                    path,
-                    status: task.status,
-                    issue: 'Task has failed'
-                });
-            }
-
-            if (task.status === TaskStatus.BLOCKED) {
-                statusIssues.push({
-                    path,
-                    status: task.status,
-                    issue: 'Task is blocked'
-                });
-            }
-        }
-
-        if (statusIssues.length > 0) {
-            throw createError(
-                ErrorCodes.TASK_DEPENDENCY,
-                'Dependency status validation failed',
-                'validateDependencyStatuses',
-                'Ensure all dependencies are in a valid state before proceeding',
-                {
-                    statusIssues,
-                    graphState: this.getGraphState()
-                }
+            throw createTaskStoreError(
+                ErrorCodes.OPERATION_FAILED,
+                'Failed to repair relationships',
+                'repairRelationships',
+                undefined,
+                { dryRun, pathPattern, error }
             );
         }
     }
-
-    /**
-     * Gets or creates a dependency node
-     */
-    private getOrCreateNode(path: string): {
-        path: string;
-        dependencies: Set<string>;
-        dependents: Set<string>;
-        visited: boolean;
-        inPath: boolean;
-        ref: WeakRef<object>;
-    } {
-        let node = this.nodes.get(path);
-        if (!node) {
-            const obj = { path }; // Create object to track via WeakRef
-            node = {
-                path,
-                dependencies: new Set(),
-                dependents: new Set(),
-                visited: false,
-                inPath: false,
-                ref: new WeakRef(obj)
-            };
-            this.nodes.set(path, node);
-        }
-        return node;
-    }
-
-    /**
-     * Gets the current state of the dependency graph for debugging
-     */
-    private getGraphState(): Record<string, unknown> {
-        return Object.fromEntries(
-            Array.from(this.nodes.entries()).map(([path, node]) => [
-                path,
-                {
-                    dependencies: Array.from(node.dependencies),
-                    dependents: Array.from(node.dependents),
-                    visited: node.visited,
-                    inPath: node.inPath,
-                    hasRef: node.ref.deref() !== undefined
-                }
-            ])
-        );
-    }
 }
diff --git a/src/task/core/transactions/transaction-manager.ts b/src/task/core/transactions/transaction-manager.ts
index a00a604..8d8e2be 100644
--- a/src/task/core/transactions/transaction-manager.ts
+++ b/src/task/core/transactions/transaction-manager.ts
@@ -12,13 +12,10 @@ import {
     TransactionOptions,
     DEFAULT_TRANSACTION_OPTIONS
 } from '../../../types/transaction.js';
-import { TransactionManager as StorageTransactionManager } from '../../../storage/core/transactions/manager.js';
-
 export class TransactionManager {
     private readonly logger: Logger;
     private activeTransactions: Map<string, Transaction>;
     private transactionCounter: number;
-    private readonly storageTransactionManager: StorageTransactionManager;
     private transactionTimeouts: Map<string, NodeJS.Timeout>;
     private static instance: TransactionManager | null = null;
 
@@ -27,7 +24,6 @@ export class TransactionManager {
         this.activeTransactions = new Map();
         this.transactionTimeouts = new Map();
         this.transactionCounter = 0;
-        this.storageTransactionManager = StorageTransactionManager.getInstance();
     }
 
     static getInstance(storage?: TaskStorage): TransactionManager {
@@ -74,9 +70,9 @@ export class TransactionManager {
                 await this.acquireLock(id);
             }
 
-            // Start storage-level transaction
-            if (this.storage && 'db' in this.storage) {
-                await this.storageTransactionManager.beginTransaction((this.storage as any).db);
+            // Start storage-level transaction if storage supports it
+            if (this.storage && 'beginTransaction' in this.storage) {
+                await this.storage.beginTransaction();
             }
 
             this.activeTransactions.set(id, transaction);
@@ -96,7 +92,9 @@ export class TransactionManager {
             throw createError(
                 ErrorCodes.TRANSACTION_ERROR,
                 'Failed to begin transaction',
-                String(error)
+                'TransactionManager.begin',
+                undefined,
+                { error: String(error) }
             );
         }
     }
@@ -116,12 +114,9 @@ export class TransactionManager {
 
             try {
                 // Persist and commit transaction
-                if (this.storage && 'db' in this.storage) {
+                if (this.storage && 'commitTransaction' in this.storage) {
                     await this.persistTransaction(transaction);
-                    await this.storageTransactionManager.commitTransaction(
-                        (this.storage as any).db,
-                        transaction.id
-                    );
+                    await this.storage.commitTransaction();
                 }
 
                 transaction.status = 'committed';
@@ -181,16 +176,14 @@ export class TransactionManager {
             if (!this.activeTransactions.has(transaction.id)) {
                 throw createError(
                     ErrorCodes.INVALID_STATE,
-                    `Transaction ${transaction.id} not found`
+                    `Transaction ${transaction.id} not found`,
+                    'TransactionManager.rollback'
                 );
             }
 
             // Rollback storage-level transaction first
-            if (this.storage && 'db' in this.storage) {
-                await this.storageTransactionManager.rollbackTransaction(
-                    (this.storage as any).db,
-                    transaction.id
-                );
+            if (this.storage && 'rollbackTransaction' in this.storage) {
+                await this.storage.rollbackTransaction();
             }
 
             // Then reverse operations in reverse order
@@ -217,12 +210,9 @@ export class TransactionManager {
             });
 
             // Even if application-level rollback fails, ensure storage transaction is rolled back
-            if (this.storage && 'db' in this.storage) {
+            if (this.storage && 'rollbackTransaction' in this.storage) {
                 try {
-                    await this.storageTransactionManager.rollbackTransaction(
-                        (this.storage as any).db,
-                        transaction.id
-                    );
+                    await this.storage.rollbackTransaction();
                 } catch (rollbackError) {
                     this.logger.error('Failed to rollback storage transaction', {
                         error: rollbackError,
@@ -280,17 +270,19 @@ export class TransactionManager {
 
     private validateTransactionState(transaction: Transaction): void {
         if (!this.activeTransactions.has(transaction.id)) {
-            throw createError(
-                ErrorCodes.INVALID_STATE,
-                `Transaction ${transaction.id} not found`
-            );
+                throw createError(
+                    ErrorCodes.INVALID_STATE,
+                    `Transaction ${transaction.id} not found`,
+                    'TransactionManager.validateTransactionState'
+                );
         }
 
         if (transaction.status !== 'pending') {
-            throw createError(
-                ErrorCodes.INVALID_STATE,
-                `Transaction ${transaction.id} is already ${transaction.status}`
-            );
+                throw createError(
+                    ErrorCodes.INVALID_STATE,
+                    `Transaction ${transaction.id} is already ${transaction.status}`,
+                    'TransactionManager.validateTransactionState'
+                );
         }
     }
 
diff --git a/src/task/core/transactions/transaction-types.ts b/src/task/core/transactions/transaction-types.ts
deleted file mode 100644
index a018031..0000000
--- a/src/task/core/transactions/transaction-types.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Transaction types for atomic task operations
- */
-
-import { Task } from '../../../types/task.js';
-
-export interface Transaction {
-    id: string;
-    operations: Operation[];
-    timestamp: number;
-    status: TransactionStatus;
-}
-
-export type TransactionStatus = 'pending' | 'committed' | 'rolled_back';
-
-export type Operation = 
-    | DeleteOperation
-    | UpdateOperation
-    | CreateOperation;
-
-export interface DeleteOperation {
-    type: 'delete';
-    paths: string[];
-    tasks: Task[];
-}
-
-export interface UpdateOperation {
-    type: 'update';
-    path: string;
-    task: Task;
-}
-
-export interface CreateOperation {
-    type: 'create';
-    task: Task;
-}
-
-export interface TransactionResult {
-    success: boolean;
-    transactionId: string;
-    error?: Error;
-}
diff --git a/src/task/operations/task-operations.ts b/src/task/operations/task-operations.ts
index 69f516b..f954914 100644
--- a/src/task/operations/task-operations.ts
+++ b/src/task/operations/task-operations.ts
@@ -9,30 +9,30 @@ import { TransactionManager } from '../core/transactions/transaction-manager.js'
 import { StatusUpdateBatch } from '../core/batch/status-update-batch.js';
 
 interface TaskEvent {
-  type: EventTypes;
-  timestamp: number;
-  taskId: string;
-  task: Task;
-  metadata?: Record<string, any>;
-  changes?: {
-    before: Partial<Task>;
-    after: Partial<Task>;
-  };
+    type: EventTypes;
+    timestamp: number;
+    taskId: string;
+    task: Task;
+    metadata?: Record<string, any>;
+    changes?: {
+        before: Partial<Task>;
+        after: Partial<Task>;
+    };
 }
 
 export class TaskOperations {
-  private readonly logger: Logger;
-  private readonly eventManager: EventManager;
-  private readonly transactionManager: TransactionManager;
-  private readonly eventSubscriptions: Map<string, { unsubscribe: () => void }> = new Map();
-  private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
-  private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
-  private memoryCheckInterval?: NodeJS.Timeout;
-  private isShuttingDown = false;
-  private static instance: TaskOperations | null = null;
-  private static initializationPromise: Promise<TaskOperations> | null = null;
-  private initialized = false;
-  private readonly statusUpdateBatch: StatusUpdateBatch;
+    private readonly logger: Logger;
+    private readonly eventManager: EventManager;
+    private readonly transactionManager: TransactionManager;
+    private readonly eventSubscriptions: Map<string, { unsubscribe: () => void }> = new Map();
+    private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
+    private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
+    private memoryCheckInterval?: NodeJS.Timeout;
+    private isShuttingDown = false;
+    private static instance: TaskOperations | null = null;
+    private static initializationPromise: Promise<TaskOperations> | null = null;
+    private initialized = false;
+    private readonly statusUpdateBatch: StatusUpdateBatch;
 
     private constructor(
         private readonly storage: TaskStorage,
@@ -53,539 +53,523 @@ export class TaskOperations {
         this.logMemoryUsage('Initialization');
     }
 
-  /**
-   * Gets the TaskOperations instance
-   */
-  static async getInstance(storage: TaskStorage, validator: TaskValidator): Promise<TaskOperations> {
-    // Return existing instance if available
-    if (TaskOperations.instance && TaskOperations.instance.initialized) {
-      return TaskOperations.instance;
-    }
-
-    // If initialization is in progress, wait for it
-    if (TaskOperations.initializationPromise) {
-      return TaskOperations.initializationPromise;
-    }
-
-    // Start new initialization with mutex
-    TaskOperations.initializationPromise = (async () => {
-      try {
-        // Double-check instance hasn't been created while waiting
+    static async getInstance(storage: TaskStorage, validator: TaskValidator): Promise<TaskOperations> {
+        // Return existing instance if available
         if (TaskOperations.instance && TaskOperations.instance.initialized) {
-          return TaskOperations.instance;
+            return TaskOperations.instance;
         }
 
-        TaskOperations.instance = new TaskOperations(storage, validator);
-        await TaskOperations.instance.initialize();
-        return TaskOperations.instance;
-      } catch (error) {
-        throw createError(
-          ErrorCodes.STORAGE_INIT,
-          `Failed to initialize TaskOperations: ${error instanceof Error ? error.message : String(error)}`
-        );
-      } finally {
-        TaskOperations.initializationPromise = null;
-      }
-    })();
-
-    return TaskOperations.initializationPromise;
-  }
-
-  private async initialize(): Promise<void> {
-    if (this.initialized) {
-      this.logger.debug('Task operations already initialized');
-      return;
-    }
+        // If initialization is in progress, wait for it
+        if (TaskOperations.initializationPromise) {
+            return TaskOperations.initializationPromise;
+        }
 
-    try {
-      this.initialized = true;
-      this.logger.debug('Task operations initialized');
-    } catch (error) {
-      this.logger.error('Failed to initialize task operations', { error });
-      throw error;
+        // Start new initialization with mutex
+        TaskOperations.initializationPromise = (async () => {
+            try {
+                // Double-check instance hasn't been created while waiting
+                if (TaskOperations.instance && TaskOperations.instance.initialized) {
+                    return TaskOperations.instance;
+                }
+
+                TaskOperations.instance = new TaskOperations(storage, validator);
+                await TaskOperations.instance.initialize();
+                return TaskOperations.instance;
+            } catch (error) {
+                throw createError(
+                    ErrorCodes.STORAGE_INIT,
+                    `Failed to initialize TaskOperations: ${error instanceof Error ? error.message : String(error)}`,
+                    'TaskOperations.getInstance'
+                );
+            } finally {
+                TaskOperations.initializationPromise = null;
+            }
+        })();
+
+        return TaskOperations.initializationPromise;
     }
-  }
-
-  private setupEventListeners(): void {
-    // Setup event listeners with strong references and explicit cleanup
-    const setupListener = (type: EventTypes) => {
-      const handler = (event: TaskEvent) => {
-        this.logger.debug(`${type} event received`, { taskId: event.taskId });
-      };
-      const subscription = this.eventManager.on(type, handler);
-      this.eventSubscriptions.set(type, subscription);
-    };
 
-    setupListener(EventTypes.TASK_CREATED);
-    setupListener(EventTypes.TASK_UPDATED);
-    setupListener(EventTypes.TASK_DELETED);
-    setupListener(EventTypes.TASK_STATUS_CHANGED);
-  }
-
-  private startMemoryMonitoring(): void {
-    // Monitor memory usage periodically
-    this.memoryCheckInterval = setInterval(() => {
-      const memoryUsage = process.memoryUsage();
-      const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;
-
-      this.logger.debug('Memory usage', {
-        heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
-        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
-        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
-        external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
-        arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
-      });
-
-      if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
-        this.logger.warn('High memory usage detected', {
-          heapUsed: `${(heapUsed * 100).toFixed(1)}%`
-        });
-        
-        // Force cleanup when memory pressure is high
-        this.cleanupResources(true);
-        
-        // Force GC if available
-        if (global.gc) {
-          this.logger.info('Forcing garbage collection');
-          global.gc();
+    private async initialize(): Promise<void> {
+        if (this.initialized) {
+            this.logger.debug('Task operations already initialized');
+            return;
         }
-      }
-
-      // Check for stale transactions
-      this.cleanupStaleTransactions();
-    }, this.MEMORY_CHECK_INTERVAL);
-
-    // Ensure cleanup on process exit
-    process.once('beforeExit', () => {
-      if (this.memoryCheckInterval) {
-        clearInterval(this.memoryCheckInterval);
-        this.memoryCheckInterval = undefined;
-      }
-    });
-  }
-
-  private async cleanupResources(force: boolean = false): Promise<void> {
-    try {
-      const startTime = Date.now();
-      let cleanedCount = 0;
-
-      // Clean up event subscriptions
-      if (force) {
-        for (const [type, subscription] of this.eventSubscriptions.entries()) {
-          subscription.unsubscribe();
-          this.eventSubscriptions.delete(type);
-          cleanedCount++;
-        }
-      }
-
-      // Force garbage collection if available
-      if (global.gc && (force || cleanedCount > 0)) {
-        global.gc();
-      }
-
-      const endTime = Date.now();
-      this.logger.info('Resource cleanup completed', {
-        duration: endTime - startTime,
-        cleanedCount,
-        forced: force,
-        remainingSubscriptions: this.eventSubscriptions.size,
-        memoryUsage: this.getMemoryMetrics()
-      });
-    } catch (error) {
-      this.logger.error('Error during resource cleanup', { error });
-    }
-  }
-
-  private cleanupStaleTransactions(): void {
-    // Transaction cleanup is now handled by TransactionManager
-  }
-
-  private getMemoryMetrics(): Record<string, string> {
-    const memoryUsage = process.memoryUsage();
-    return {
-      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
-      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
-      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
-      external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
-      arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
-      heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
-    };
-  }
-
-  private logMemoryUsage(context: string): void {
-    this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
-  }
-
-  async cleanup(): Promise<void> {
-    try {
-      this.isShuttingDown = true;
-      this.logMemoryUsage('Cleanup start');
-
-      // Stop memory monitoring
-      if (this.memoryCheckInterval) {
-        clearInterval(this.memoryCheckInterval);
-        this.memoryCheckInterval = undefined;
-      }
-
-      // Cleanup event subscriptions
-      for (const [type, subscription] of this.eventSubscriptions.entries()) {
-        subscription.unsubscribe();
-        this.eventSubscriptions.delete(type);
-      }
-
-      // Force final cleanup
-      await this.cleanupResources(true);
-
-      // Final garbage collection
-      if (global.gc) {
-        this.logger.info('Forcing final garbage collection');
-        global.gc();
-      }
-
-      this.logMemoryUsage('Cleanup end');
-      this.logger.info('Task operations cleanup completed', {
-        finalMetrics: {
-          eventSubscriptions: this.eventSubscriptions.size,
-          ...this.getMemoryMetrics()
+
+        try {
+            this.initialized = true;
+            this.logger.debug('Task operations initialized');
+        } catch (error) {
+            this.logger.error('Failed to initialize task operations', { error });
+            throw error;
         }
-      });
-    } catch (error) {
-      this.logger.error('Error during task operations cleanup', { error });
-      throw error;
     }
-  }
 
-  async createTask(input: CreateTaskInput): Promise<Task> {
-    if (!this.initialized) {
-      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
+    private setupEventListeners(): void {
+        // Setup event listeners with strong references and explicit cleanup
+        const setupListener = (type: EventTypes) => {
+            const handler = (event: TaskEvent) => {
+                this.logger.debug(`${type} event received`, { taskId: event.taskId });
+            };
+            const subscription = this.eventManager.on(type, handler);
+            this.eventSubscriptions.set(type, subscription);
+        };
+
+        setupListener(EventTypes.TASK_CREATED);
+        setupListener(EventTypes.TASK_UPDATED);
+        setupListener(EventTypes.TASK_DELETED);
+        setupListener(EventTypes.TASK_STATUS_CHANGED);
     }
-    if (this.isShuttingDown) {
-      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
+
+    private startMemoryMonitoring(): void {
+        // Monitor memory usage periodically
+        this.memoryCheckInterval = setInterval(() => {
+            const memoryUsage = process.memoryUsage();
+            const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;
+
+            this.logger.debug('Memory usage', {
+                heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
+                heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
+                rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
+                external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
+                arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
+            });
+
+            if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
+                this.logger.warn('High memory usage detected', {
+                    heapUsed: `${(heapUsed * 100).toFixed(1)}%`
+                });
+                
+                // Force cleanup when memory pressure is high
+                this.cleanupResources(true);
+                
+                // Force GC if available
+                if (global.gc) {
+                    this.logger.info('Forcing garbage collection');
+                    global.gc();
+                }
+            }
+
+            // Check for stale transactions
+            this.cleanupStaleTransactions();
+        }, this.MEMORY_CHECK_INTERVAL);
+
+        // Ensure cleanup on process exit
+        process.once('beforeExit', () => {
+            if (this.memoryCheckInterval) {
+                clearInterval(this.memoryCheckInterval);
+                this.memoryCheckInterval = undefined;
+            }
+        });
     }
 
-    // Set defaults
-    const taskInput: CreateTaskInput = {
-      ...input,
-      type: input.type || TaskType.TASK // Default to TASK type if not provided
-    };
+    private async cleanupResources(force: boolean = false): Promise<void> {
+        try {
+            const startTime = Date.now();
+            let cleanedCount = 0;
+
+            // Clean up event subscriptions
+            if (force) {
+                for (const [type, subscription] of this.eventSubscriptions.entries()) {
+                    subscription.unsubscribe();
+                    this.eventSubscriptions.delete(type);
+                    cleanedCount++;
+                }
+            }
+
+            // Force garbage collection if available
+            if (global.gc && (force || cleanedCount > 0)) {
+                global.gc();
+            }
 
-    // Validate input
-    await this.validator.validateCreate(taskInput);
-
-    const transaction = await this.transactionManager.begin({
-      timeout: 10000,
-      requireLock: true
-    });
-
-    try {
-      // Create task with processed input containing defaults
-      const task = await this.storage.createTask(taskInput);
-
-      // Add operation to transaction
-      transaction.operations.push({
-        id: `create-${Date.now()}`,
-        type: 'create',
-        timestamp: Date.now(),
-        path: task.path,
-        task
-      });
-
-      // Emit event
-      this.eventManager.emit({
-        type: EventTypes.TASK_CREATED,
-        timestamp: Date.now(),
-        taskId: task.path,
-        task,
-        metadata: { input }
-      });
-
-      await this.transactionManager.commit(transaction);
-      return task;
-    } catch (error) {
-      await this.transactionManager.rollback(transaction);
-      this.logger.error('Failed to create task', { error, input });
-      throw error;
+            const endTime = Date.now();
+            this.logger.info('Resource cleanup completed', {
+                duration: endTime - startTime,
+                cleanedCount,
+                forced: force,
+                remainingSubscriptions: this.eventSubscriptions.size,
+                memoryUsage: this.getMemoryMetrics()
+            });
+        } catch (error) {
+            this.logger.error('Error during resource cleanup', { error });
+        }
     }
-  }
-
-  async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
-    if (!this.initialized) {
-      throw createError(
-        ErrorCodes.OPERATION_FAILED,
-        'Task operations not initialized'
-      );
+
+    private cleanupStaleTransactions(): void {
+        // Transaction cleanup is now handled by TransactionManager
     }
-    if (this.isShuttingDown) {
-      throw createError(
-        ErrorCodes.OPERATION_FAILED,
-        'System is shutting down'
-      );
+
+    private getMemoryMetrics(): Record<string, string> {
+        const memoryUsage = process.memoryUsage();
+        return {
+            heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
+            heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
+            rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
+            external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
+            arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
+            heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
+        };
     }
 
-    // Get existing task
-    const existingTask = await this.storage.getTask(path);
-    if (!existingTask) {
-      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
+    private logMemoryUsage(context: string): void {
+        this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
     }
 
-    // Validate updates
-    await this.validator.validateUpdate(path, updates);
-
-    const transaction = await this.transactionManager.begin({
-      timeout: 10000,
-      requireLock: true
-    });
-
-    try {
-      // Update task with system fields
-      const updatedTask = await this.storage.updateTask(path, {
-        ...updates,
-        version: existingTask.version + 1,
-        updated: Date.now(),
-        // Preserve other system fields
-        created: existingTask.created,
-        projectPath: existingTask.projectPath
-      });
-
-      // Add operation to transaction
-      transaction.operations.push({
-        id: `update-${Date.now()}`,
-        type: 'update',
-        timestamp: Date.now(),
-        path: updatedTask.path,
-        task: updatedTask,
-        previousState: existingTask
-      });
-
-      // Handle status changes in batch
-      if (updates.status && updates.status !== existingTask.status) {
-        await this.handleStatusChange(existingTask, updatedTask);
-        await this.statusUpdateBatch.execute();
-      }
-
-      // Emit update event
-      this.eventManager.emit({
-        type: EventTypes.TASK_UPDATED,
-        timestamp: Date.now(),
-        taskId: updatedTask.path,
-        task: updatedTask,
-        changes: {
-          before: existingTask,
-          after: updatedTask
+    async createTask(input: CreateTaskInput): Promise<Task> {
+        if (!this.initialized) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'Task operations not initialized',
+                'TaskOperations.createTask'
+            );
+        }
+        if (this.isShuttingDown) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'System is shutting down',
+                'TaskOperations.createTask'
+            );
         }
-      });
-
-      await this.transactionManager.commit(transaction);
-      return updatedTask;
-    } catch (error) {
-      this.logger.error('Failed to update task', {
-        error,
-        path,
-        updates
-      });
-      throw error;
-    }
-  }
 
-  async deleteTask(path: string): Promise<void> {
-    if (!this.initialized) {
-      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
-    }
-    if (this.isShuttingDown) {
-      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
-    }
+        // Set defaults
+        const taskInput: CreateTaskInput = {
+            ...input,
+            type: input.type || TaskType.TASK // Default to TASK type if not provided
+        };
+
+        // Validate input
+        await this.validator.validateCreate(taskInput);
 
-    // Get existing task
-    const existingTask = await this.storage.getTask(path);
-    if (!existingTask) {
-      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
+        const transaction = await this.transactionManager.begin({
+            timeout: 10000,
+            requireLock: true
+        });
+
+        try {
+            // Create task with processed input containing defaults
+            const task = await this.storage.createTask(taskInput);
+
+            // Add operation to transaction
+            transaction.operations.push({
+                id: `create-${Date.now()}`,
+                type: 'create',
+                timestamp: Date.now(),
+                path: task.path,
+                task
+            });
+
+            // Emit event
+            this.eventManager.emit({
+                type: EventTypes.TASK_CREATED,
+                timestamp: Date.now(),
+                taskId: task.path,
+                task,
+                metadata: { input }
+            });
+
+            await this.transactionManager.commit(transaction);
+            return task;
+        } catch (error) {
+            await this.transactionManager.rollback(transaction);
+            this.logger.error('Failed to create task', { error, input });
+            throw error;
+        }
     }
 
-    const transaction = await this.transactionManager.begin({
-      timeout: 10000,
-      requireLock: true
-    });
-
-    try {
-      // Delete task
-      await this.storage.deleteTask(path);
-
-      // Add operation to transaction
-      transaction.operations.push({
-        id: `delete-${Date.now()}`,
-        type: 'delete',
-        timestamp: Date.now(),
-        path: existingTask.path,
-        tasks: [existingTask]
-      });
-
-      // Emit delete event
-      this.eventManager.emit({
-        type: EventTypes.TASK_DELETED,
-        timestamp: Date.now(),
-        taskId: existingTask.path,
-        task: existingTask
-      });
-
-      await this.transactionManager.commit(transaction);
-    } catch (error) {
-      this.logger.error('Failed to delete task', {
-        error,
-        path
-      });
-      throw error;
+    async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
+        if (!this.initialized) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'Task operations not initialized',
+                'TaskOperations.updateTask'
+            );
+        }
+        if (this.isShuttingDown) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'System is shutting down',
+                'TaskOperations.updateTask'
+            );
+        }
+
+        // Get existing task
+        const existingTask = await this.storage.getTask(path);
+        if (!existingTask) {
+            throw createError(
+                ErrorCodes.TASK_NOT_FOUND,
+                `Task not found: ${path}`,
+                'TaskOperations.updateTask'
+            );
+        }
+
+        // Validate updates
+        await this.validator.validateUpdate(path, updates);
+
+        const transaction = await this.transactionManager.begin({
+            timeout: 10000,
+            requireLock: true
+        });
+
+        try {
+            // Update task with system fields
+            const updatedTask = await this.storage.updateTask(path, {
+                ...updates,
+                metadata: {
+                    ...updates.metadata,
+                    version: existingTask.version + 1,
+                    updated: Date.now()
+                }
+            });
+
+            // Add operation to transaction
+            transaction.operations.push({
+                id: `update-${Date.now()}`,
+                type: 'update',
+                timestamp: Date.now(),
+                path: updatedTask.path,
+                task: updatedTask,
+                previousState: existingTask
+            });
+
+            // Handle status changes in batch
+            if (updates.status && updates.status !== existingTask.status) {
+                await this.handleStatusChange(existingTask, updatedTask);
+                await this.statusUpdateBatch.execute();
+            }
+
+            // Emit update event
+            this.eventManager.emit({
+                type: EventTypes.TASK_UPDATED,
+                timestamp: Date.now(),
+                taskId: updatedTask.path,
+                task: updatedTask,
+                changes: {
+                    before: existingTask,
+                    after: updatedTask
+                }
+            });
+
+            await this.transactionManager.commit(transaction);
+            return updatedTask;
+        } catch (error) {
+            await this.transactionManager.rollback(transaction);
+            this.logger.error('Failed to update task', {
+                error,
+                path,
+                updates
+            });
+            throw error;
+        }
     }
-  }
-
-  private async handleStatusChange(
-    oldTask: Task,
-    newTask: Task
-  ): Promise<void> {
-    try {
-      // Clear cache before status updates
-      if ('clearCache' in this.storage) {
-        await (this.storage as any).clearCache();
-      }
-
-      // Emit status change event
-      this.eventManager.emit({
-        type: EventTypes.TASK_STATUS_CHANGED,
-        timestamp: Date.now(),
-        taskId: newTask.path,
-        task: newTask,
-        changes: {
-          before: { status: oldTask.status },
-          after: { status: newTask.status }
+
+    async deleteTask(path: string): Promise<void> {
+        if (!this.initialized) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'Task operations not initialized',
+                'TaskOperations.deleteTask'
+            );
         }
-      });
-
-      // Update parent task status if needed
-      if (newTask.parentPath) {
-        const parent = await this.storage.getTask(newTask.parentPath);
-        if (parent) {
-          const siblings = await this.storage.getSubtasks(parent.path);
-          const allCompleted = siblings.every(t => t.status === TaskStatus.COMPLETED);
-          const anyFailed = siblings.some(t => t.status === TaskStatus.FAILED);
-          const anyBlocked = siblings.some(t => t.status === TaskStatus.BLOCKED);
-          const anyInProgress = siblings.some(t => t.status === TaskStatus.IN_PROGRESS);
-
-          let newParentStatus = parent.status;
-          if (allCompleted) {
-            newParentStatus = TaskStatus.COMPLETED;
-          } else if (anyFailed) {
-            newParentStatus = TaskStatus.FAILED;
-          } else if (anyBlocked) {
-            newParentStatus = TaskStatus.BLOCKED;
-          } else if (anyInProgress) {
-            newParentStatus = TaskStatus.IN_PROGRESS;
-          }
-
-          if (newParentStatus !== parent.status) {
-            await this.updateTask(parent.path, {
-              status: newParentStatus,
-              metadata: {
-                ...parent.metadata,
-                statusUpdatedAt: Date.now(),
-                previousStatus: parent.status
-              }
+        if (this.isShuttingDown) {
+            throw createError(
+                ErrorCodes.OPERATION_FAILED,
+                'System is shutting down',
+                'TaskOperations.deleteTask'
+            );
+        }
+
+        // Get existing task
+        const existingTask = await this.storage.getTask(path);
+        if (!existingTask) {
+            throw createError(
+                ErrorCodes.TASK_NOT_FOUND,
+                `Task not found: ${path}`,
+                'TaskOperations.deleteTask'
+            );
+        }
+
+        const transaction = await this.transactionManager.begin({
+            timeout: 10000,
+            requireLock: true
+        });
+
+        try {
+            // Delete task
+            await this.storage.deleteTask(path);
+
+            // Add operation to transaction
+            transaction.operations.push({
+                id: `delete-${Date.now()}`,
+                type: 'delete',
+                timestamp: Date.now(),
+                path: existingTask.path,
+                tasks: [existingTask]
             });
-          }
+
+            // Emit delete event
+            this.eventManager.emit({
+                type: EventTypes.TASK_DELETED,
+                timestamp: Date.now(),
+                taskId: existingTask.path,
+                task: existingTask
+            });
+
+            await this.transactionManager.commit(transaction);
+        } catch (error) {
+            await this.transactionManager.rollback(transaction);
+            this.logger.error('Failed to delete task', {
+                error,
+                path
+            });
+            throw error;
         }
-      }
-
-      // Handle blocked status
-      if (newTask.status === TaskStatus.BLOCKED) {
-        await this.handleBlockedStatus(newTask);
-      }
-
-      // Handle completed status
-      if (newTask.status === TaskStatus.COMPLETED) {
-        await this.handleCompletedStatus(newTask);
-      }
-
-      // Handle failed status
-      if (newTask.status === TaskStatus.FAILED) {
-        await this.handleFailedStatus(newTask);
-      }
-    } catch (error) {
-      this.logger.error('Failed to handle status change', {
-        error,
-        oldStatus: oldTask.status,
-        newStatus: newTask.status,
-        taskPath: newTask.path
-      });
-      throw error;
     }
-  }
-
-  private async handleFailedStatus(task: Task): Promise<void> {
-    // Block dependent tasks when a task fails
-    const dependentTasks = await this.storage.getDependentTasks(task.path);
-    
-    for (const depTask of dependentTasks) {
-      if (depTask.status !== TaskStatus.FAILED) {
-        await this.updateTask(depTask.path, {
-          status: TaskStatus.BLOCKED,
-            metadata: {
-              ...depTask.metadata,
-              blockedBy: task.path,
-              blockReason: `Dependency task ${task.path} failed`,
-              blockTimestamp: Date.now()
+
+    private async handleStatusChange(oldTask: Task, newTask: Task): Promise<void> {
+        try {
+            // Clear cache before status updates
+            if ('clearCache' in this.storage) {
+                await (this.storage as any).clearCache();
             }
-        });
-      }
+
+            // Emit status change event
+            this.eventManager.emit({
+                type: EventTypes.TASK_STATUS_CHANGED,
+                timestamp: Date.now(),
+                taskId: newTask.path,
+                task: newTask,
+                changes: {
+                    before: { status: oldTask.status },
+                    after: { status: newTask.status }
+                }
+            });
+
+            // Update parent task status if needed
+            if (newTask.parentPath) {
+                const parent = await this.storage.getTask(newTask.parentPath);
+                if (parent) {
+                    const siblings = await this.storage.getSubtasks(parent.path);
+                    const allCompleted = siblings.every(t => t.status === TaskStatus.COMPLETED);
+                    const anyFailed = siblings.some(t => t.status === TaskStatus.FAILED);
+                    const anyBlocked = siblings.some(t => t.status === TaskStatus.BLOCKED);
+                    const anyInProgress = siblings.some(t => t.status === TaskStatus.IN_PROGRESS);
+
+                    let newParentStatus = parent.status;
+                    if (allCompleted) {
+                        newParentStatus = TaskStatus.COMPLETED;
+                    } else if (anyFailed) {
+                        newParentStatus = TaskStatus.FAILED;
+                    } else if (anyBlocked) {
+                        newParentStatus = TaskStatus.BLOCKED;
+                    } else if (anyInProgress) {
+                        newParentStatus = TaskStatus.IN_PROGRESS;
+                    }
+
+                    if (newParentStatus !== parent.status) {
+                        await this.updateTask(parent.path, {
+                            status: newParentStatus,
+                            metadata: {
+                                ...parent.metadata,
+                                statusUpdatedAt: Date.now(),
+                                previousStatus: parent.status
+                            }
+                        });
+                    }
+                }
+            }
+
+            // Handle blocked status
+            if (newTask.status === TaskStatus.BLOCKED) {
+                await this.handleBlockedStatus(newTask);
+            }
+
+            // Handle completed status
+            if (newTask.status === TaskStatus.COMPLETED) {
+                await this.handleCompletedStatus(newTask);
+            }
+
+            // Handle failed status
+            if (newTask.status === TaskStatus.FAILED) {
+                await this.handleFailedStatus(newTask);
+            }
+        } catch (error) {
+            this.logger.error('Failed to handle status change', {
+                error,
+                oldStatus: oldTask.status,
+                newStatus: newTask.status,
+                taskPath: newTask.path
+            });
+            throw error;
+        }
     }
-  }
-
-  private async handleBlockedStatus(task: Task): Promise<void> {
-    // Update dependent tasks to blocked status
-    const dependentTasks = await this.storage.getDependentTasks(task.path);
-    
-    for (const depTask of dependentTasks) {
-      if (depTask.status !== TaskStatus.BLOCKED) {
-        await this.updateTask(depTask.path, {
-          status: TaskStatus.BLOCKED,
-            metadata: {
-              ...depTask.metadata,
-              blockedBy: task.path,
-              blockTimestamp: Date.now()
+
+    private async handleFailedStatus(task: Task): Promise<void> {
+        // Block dependent tasks when a task fails
+        const dependentTasks = await this.storage.getDependentTasks(task.path);
+        
+        for (const depTask of dependentTasks) {
+            if (depTask.status !== TaskStatus.FAILED) {
+                await this.updateTask(depTask.path, {
+                    status: TaskStatus.BLOCKED,
+                    metadata: {
+                        ...depTask.metadata,
+                        blockedBy: task.path,
+                        blockReason: `Dependency task ${task.path} failed`,
+                        blockTimestamp: Date.now()
+                    }
+                });
             }
-        });
-      }
+        }
+    }
+
+    private async handleBlockedStatus(task: Task): Promise<void> {
+        // Update dependent tasks to blocked status
+        const dependentTasks = await this.storage.getDependentTasks(task.path);
+        
+        for (const depTask of dependentTasks) {
+            if (depTask.status !== TaskStatus.BLOCKED) {
+                await this.updateTask(depTask.path, {
+                    status: TaskStatus.BLOCKED,
+                    metadata: {
+                        ...depTask.metadata,
+                        blockedBy: task.path,
+                        blockTimestamp: Date.now()
+                    }
+                });
+            }
+        }
     }
-  }
-
-  private async handleCompletedStatus(task: Task): Promise<void> {
-    // Check if dependent tasks can be unblocked
-    const dependentTasks = await this.storage.getDependentTasks(task.path);
-    
-    for (const depTask of dependentTasks) {
-      if (depTask.status === TaskStatus.BLOCKED) {
-        // Check if all dependencies are completed
-        const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
+
+    private async handleCompletedStatus(task: Task): Promise<void> {
+        // Check if dependent tasks can be unblocked
+        const dependentTasks = await this.storage.getDependentTasks(task.path);
         
-        if (allDepsCompleted) {
-          await this.updateTask(depTask.path, {
-            status: TaskStatus.PENDING,
-            metadata: {
-              ...depTask.metadata,
-              blockedBy: undefined,
-              blockTimestamp: undefined,
-              unblockTimestamp: Date.now()
+        for (const depTask of dependentTasks) {
+            if (depTask.status === TaskStatus.BLOCKED) {
+                // Check if all dependencies are completed
+                const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
+                
+                if (allDepsCompleted) {
+                    await this.updateTask(depTask.path, {
+                        status: TaskStatus.PENDING,
+                        metadata: {
+                            ...depTask.metadata,
+                            blockedBy: undefined,
+                            blockTimestamp: undefined,
+                            unblockTimestamp: Date.now()
+                        }
+                    });
+                }
             }
-          });
         }
-      }
     }
-  }
-
-  private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
-    for (const depPath of task.dependencies) {
-      const depTask = await this.storage.getTask(depPath);
-      if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
-        return false;
-      }
+
+    private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
+        for (const depPath of task.dependencies) {
+            const depTask = await this.storage.getTask(depPath);
+            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
+                return false;
+            }
+        }
+        return true;
     }
-    return true;
-  }
 }
diff --git a/src/task/validation/index.ts b/src/task/validation/index.ts
index ebbf216..679ba40 100644
--- a/src/task/validation/index.ts
+++ b/src/task/validation/index.ts
@@ -1,181 +1,62 @@
-/**
- * Task validation module exports
- * Provides a centralized point for all task validation functionality
- */
+import { TaskStatus, TaskType } from '../../types/task.js';
+import { StatusValidator } from './validators/status-validator.js';
+import { DependencyValidator } from './validators/dependency-validator.js';
+import { HierarchyValidator } from './validators/hierarchy-validator.js';
+import { BaseTask } from './schemas/base-schema.js';
 
-import { z } from 'zod';
-import { ValidationResult } from '../../types/index.js';
+// Export main validator
+export { TaskValidator } from './task-validator.js';
 
-/**
- * Convert Zod validation error to ValidationResult format
- */
-export function formatZodError(error: z.ZodError): ValidationResult {
-    return {
-        success: false,
-        errors: error.errors.map(err => ({
-            path: err.path.map(String),
-            message: err.message,
-            received: err instanceof z.ZodError ? err.code : undefined,
-            expected: getExpectedValue(err)
-        }))
-    };
-}
-
-/**
- * Get expected value from Zod error
- */
-function getExpectedValue(error: z.ZodIssue): string | undefined {
-    switch (error.code) {
-        case z.ZodIssueCode.invalid_type:
-            return error.expected;
-        case z.ZodIssueCode.invalid_enum_value:
-            return error.options.join(' | ');
-        case z.ZodIssueCode.too_small:
-            return `${error.type === 'string' ? 'length' : 'value'} >= ${error.minimum}`;
-        case z.ZodIssueCode.too_big:
-            return `${error.type === 'string' ? 'length' : 'value'} <= ${error.maximum}`;
-        default:
-            return undefined;
-    }
-}
-
-/**
- * Create a safe validator function that returns ValidationResult
- */
-export function createSafeValidator<T>(schema: z.ZodType<T>) {
-    return (value: unknown): ValidationResult & { value?: T } => {
-        const result = schema.safeParse(value);
-        if (result.success) {
-            return {
-                success: true,
-                data: result.data
-            };
-        } else {
-            return formatZodError(result.error);
-        }
-    };
-}
-
-/**
- * Create a validator function that throws on invalid input
- */
-export function createValidator<T>(schema: z.ZodType<T>) {
-    return (value: unknown): T => schema.parse(value);
-}
-
-/**
- * Validation error messages
- */
-export const ValidationErrorMessages = {
-    INVALID_INPUT: 'Invalid input provided',
-    VALIDATION_FAILED: 'Validation failed',
-    TYPE_ERROR: 'Type validation failed',
-    CONSTRAINT_ERROR: 'Constraint validation failed',
-    REQUIRED_FIELD: 'Required field is missing',
-    INVALID_FORMAT: 'Invalid format',
-    INVALID_VALUE: 'Invalid value provided',
-    OUT_OF_RANGE: 'Value is out of allowed range',
-    PATTERN_MISMATCH: 'Value does not match required pattern',
-    UNIQUE_VIOLATION: 'Value must be unique',
-    REFERENCE_ERROR: 'Invalid reference',
-    CUSTOM_ERROR: 'Custom validation failed'
-} as const;
-
-/**
- * Validation utilities
- */
-export const ValidationUtils = {
-    /**
-     * Check if a value is defined (not null or undefined)
-     */
-    isDefined: <T>(value: T | null | undefined): value is T => {
-        return value !== null && value !== undefined;
-    },
-
-    /**
-     * Check if a value is a non-empty string
-     */
-    isNonEmptyString: (value: unknown): value is string => {
-        return typeof value === 'string' && value.trim().length > 0;
-    },
-
-    /**
-     * Check if a value is a valid number
-     */
-    isValidNumber: (value: unknown): value is number => {
-        return typeof value === 'number' && !isNaN(value) && isFinite(value);
-    },
-
-    /**
-     * Check if a value is a valid integer
-     */
-    isValidInteger: (value: unknown): value is number => {
-        return ValidationUtils.isValidNumber(value) && Number.isInteger(value);
-    },
-
-    /**
-     * Check if a value is a valid date string
-     */
-    isValidDateString: (value: unknown): boolean => {
-        if (typeof value !== 'string') return false;
-        const date = new Date(value);
-        return !isNaN(date.getTime());
-    },
-
-    /**
-     * Check if a value is a valid UUID
-     */
-    isValidUUID: (value: unknown): boolean => {
-        if (typeof value !== 'string') return false;
-        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
-        return uuidRegex.test(value);
-    },
-
-    /**
-     * Check if a value is a valid email
-     */
-    isValidEmail: (value: unknown): boolean => {
-        if (typeof value !== 'string') return false;
-        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
-        return emailRegex.test(value);
-    },
-
-    /**
-     * Check if a value is a valid URL
-     */
-    isValidURL: (value: unknown): boolean => {
-        if (typeof value !== 'string') return false;
-        try {
-            new URL(value);
-            return true;
-        } catch {
-            return false;
-        }
-    },
-
-    /**
-     * Check if an array contains only unique values
-     */
-    hasUniqueValues: <T>(array: T[]): boolean => {
-        return new Set(array).size === array.length;
-    },
-
-    /**
-     * Check if an object has all required properties
-     */
-    hasRequiredProperties: (obj: unknown, properties: string[]): boolean => {
-        if (typeof obj !== 'object' || obj === null) return false;
-        return properties.every(prop => prop in obj);
+// Export schemas
+export {
+    taskMetadataSchema,
+    baseTaskSchema,
+    createTaskSchema,
+    updateTaskSchema,
+    taskResponseSchema,
+    type TaskMetadata,
+    type BaseTask,
+    type TaskResponse,
+    type CreateTaskInput,
+    type UpdateTaskInput
+} from './schemas/index.js';
+
+// Export validators and their functions
+export {
+    StatusValidator,
+    DependencyValidator,
+    HierarchyValidator,
+    TaskValidators
+} from './validators/index.js';
+
+// Export validation functions
+export const validateTaskStatusTransition = async (
+    task: BaseTask,
+    newStatus: TaskStatus,
+    getTaskByPath: (path: string) => Promise<BaseTask | null>
+): Promise<void> => {
+    const validator = new StatusValidator();
+    await validator.validateStatusTransition(task, newStatus, getTaskByPath);
+};
+
+export const detectDependencyCycle = async (
+    task: BaseTask,
+    newDeps: string[],
+    getTaskByPath: (path: string) => Promise<BaseTask | null>
+): Promise<boolean> => {
+    const validator = new DependencyValidator();
+    return validator.detectDependencyCycle(task, newDeps, getTaskByPath);
+};
+
+export const isValidTaskHierarchy = (parentType: TaskType, childType: TaskType): boolean => {
+    const validator = new HierarchyValidator();
+    try {
+        validator.validateTaskHierarchy(parentType, childType);
+        return true;
+    } catch {
+        return false;
     }
-} as const;
+};
 
-export {
-    TaskValidator,
-    isValidTaskHierarchy,
-    validateTaskStatusTransition,
-    detectDependencyCycle,
-    validateTask,
-    validateCreateTaskInput,
-    validateUpdateTaskInput,
-    validateTaskResponse
-} from './task-validator.js';
+// Re-export types needed by validation
+export { TaskStatus, TaskType };
diff --git a/src/task/validation/task-validator.ts b/src/task/validation/task-validator.ts
index bbc3e5b..4a5831f 100644
--- a/src/task/validation/task-validator.ts
+++ b/src/task/validation/task-validator.ts
@@ -1,551 +1,139 @@
 import { Logger } from '../../logging/index.js';
 import { TaskStorage } from '../../types/storage.js';
-import { CreateTaskInput, UpdateTaskInput, TaskType, TaskStatus, CONSTRAINTS, Task } from '../../types/task.js';
+import { TaskType, TaskStatus } from '../../types/task.js';
 import { ErrorCodes, createError } from '../../errors/index.js';
-import { PathValidator } from '../../validation/index.js';
-import { z } from 'zod';
-
-// Task metadata schema (user-defined fields only)
-const taskMetadataSchema = z.object({
-    priority: z.enum(['low', 'medium', 'high']).optional(),
-    tags: z.array(z.string().max(100)).max(100).optional(),
-    reasoning: z.string().max(2000).optional(),
-    toolsUsed: z.array(z.string().max(100)).max(100).optional(),
-    resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
-    contextUsed: z.array(z.string().max(1000)).max(100).optional()
-}).passthrough();
-
-// Initialize path validator for schema validation
-const pathValidator = new PathValidator({
-    maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
-    maxLength: 1000,
-    allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
-    projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
-    maxProjectNameLength: 100
-});
-
-// Base task schema with system fields at root level
-const baseTaskSchema = z.object({
-    // System fields
-    path: z.string()
-        .refine(
-            (path) => {
-                const result = pathValidator.validatePath(path);
-                return result.isValid;
-            },
-            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
-        ),
-    name: z.string().min(1).max(200),
-    type: z.nativeEnum(TaskType),
-    status: z.nativeEnum(TaskStatus),
-    created: z.number(),
-    updated: z.number(),
-    version: z.number().positive(),
-    projectPath: z.string().max(1000),
-
-    // Optional fields
-    description: z.string().max(2000).optional(),
-    parentPath: z.string().optional(),
-    notes: z.array(z.string().max(1000)).max(100).optional(),
-    reasoning: z.string().max(2000).optional(),
-    dependencies: z.array(z.string()).max(50),
-    subtasks: z.array(z.string()).max(100),
-
-    // User-defined metadata
-    metadata: taskMetadataSchema
-});
-
+import { 
+    taskMetadataSchema,
+    createTaskSchema,
+    updateTaskSchema,
+    CreateTaskInput,
+    UpdateTaskInput,
+    BaseTask
+} from './schemas/index.js';
+import { TaskValidators } from './validators/index.js';
 
 /**
- * Validates parent-child task type relationships
+ * Main task validator that coordinates all validation rules
  */
-export function isValidTaskHierarchy(parentType: TaskType, childType: TaskType): { valid: boolean; reason?: string } {
-    switch (parentType) {
-        case TaskType.MILESTONE:
-            // Milestones can contain tasks and groups
-            return {
-                valid: childType === TaskType.TASK || childType === TaskType.GROUP,
-                reason: childType !== TaskType.TASK && childType !== TaskType.GROUP ?
-                    `MILESTONE can only contain TASK or GROUP types, not ${childType}` : undefined
-            };
-        case TaskType.GROUP:
-            // Groups can contain tasks
-            return {
-                valid: childType === TaskType.TASK,
-                reason: childType !== TaskType.TASK ?
-                    `GROUP can only contain TASK type, not ${childType}` : undefined
-            };
-        case TaskType.TASK:
-            // Tasks cannot contain other tasks
-            return {
-                valid: false,
-                reason: `TASK type cannot contain any subtasks (attempted to add ${childType})`
-            };
-        default:
-            return {
-                valid: false,
-                reason: `Unknown task type: ${parentType}`
-            };
-    }
-}
-
-// Create task input schema
-export const createTaskSchema = z.object({
-    path: z.string()
-        .refine(
-            (path) => {
-                const result = pathValidator.validatePath(path);
-                return result.isValid;
-            },
-            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
-        ),
-    name: z.string().min(1).max(200),
-    parentPath: z.string()
-        .refine(
-            (path) => {
-                const result = pathValidator.validatePath(path);
-                return result.isValid;
-            },
-            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid parent path format' })
-        )
-        .optional(),
-    description: z.string().max(2000).optional(),
-    type: z.nativeEnum(TaskType).optional(),
-    notes: z.array(z.string().max(1000)).max(100).optional(),
-    reasoning: z.string().max(2000).optional(),
-    dependencies: z.array(z.string()).max(50).optional(),
-    metadata: taskMetadataSchema.optional()
-});
-
-// Update task input schema
-export const updateTaskSchema = z.object({
-    name: z.string().min(1).max(200).optional(),
-    description: z.string().max(2000).optional(),
-    type: z.nativeEnum(TaskType).optional(),
-    status: z.nativeEnum(TaskStatus).optional(),
-    notes: z.array(z.string().max(1000)).max(100).optional(),
-    reasoning: z.string().max(2000).optional(),
-    dependencies: z.array(z.string()).max(50).optional(),
-    metadata: taskMetadataSchema.optional()
-});
-
-// Task response schema
-export const taskResponseSchema = z.object({
-    success: z.boolean(),
-    data: z.unknown().optional(),
-    error: z.object({
-        code: z.string(),
-        message: z.string()
-    }).optional(),
-    metadata: z.object({
-        timestamp: z.number(),
-        requestId: z.string(),
-        projectPath: z.string(),
-        affectedPaths: z.array(z.string())
-    })
-});
+export class TaskValidator {
+    private readonly logger: Logger;
+    private readonly validators: TaskValidators;
 
-// Export type-safe validation functions
-export function validateTask(task: unknown) {
-    return baseTaskSchema.parse(task);
-}
+    constructor(private readonly storage: TaskStorage) {
+        this.logger = Logger.getInstance().child({ component: 'TaskValidator' });
+        this.validators = new TaskValidators();
+    }
 
-export function validateCreateTaskInput(input: unknown) {
-    return createTaskSchema.parse(input);
-}
+    /**
+     * Validates task creation input
+     */
+    async validateCreate(input: CreateTaskInput): Promise<void> {
+        try {
+            // Validate schema
+            createTaskSchema.parse(input);
+
+            // Create dummy task for validation
+            const task: BaseTask = {
+                path: input.path || '',
+                name: input.name,
+                type: input.type || TaskType.TASK,
+                status: TaskStatus.PENDING,
+                created: Date.now(),
+                updated: Date.now(),
+                version: 1,
+                projectPath: input.path?.split('/')[0] || '',
+                dependencies: input.dependencies || [],
+                subtasks: [],
+                metadata: input.metadata || {}
+            };
 
-export function validateUpdateTaskInput(input: unknown) {
-    return updateTaskSchema.parse(input);
-}
+            // Validate hierarchy if parent path provided
+            await this.validators.validateHierarchy(task, input.parentPath, this.storage.getTask.bind(this.storage));
 
-export function validateTaskResponse(response: unknown) {
-    return taskResponseSchema.parse(response);
-}
+            // Validate dependencies if provided
+            if (input.dependencies?.length) {
+                await this.validators.validateDependencies(task, input.dependencies, this.storage.getTask.bind(this.storage));
+            }
 
-/**
- * Validates task status transitions and dependencies
- */
-export async function validateTaskStatusTransition(
-    task: z.infer<typeof baseTaskSchema>,
-    newStatus: TaskStatus,
-    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
-): Promise<void> {
-    // Cannot transition from COMPLETED/FAILED back to IN_PROGRESS
-    if ((task.status === TaskStatus.COMPLETED || task.status === TaskStatus.FAILED) &&
-        newStatus === TaskStatus.IN_PROGRESS) {
-        throw createError(
-            ErrorCodes.TASK_STATUS,
-            `Cannot transition from ${task.status} to ${newStatus}`,
-            'validateTaskStatusTransition',
-            undefined,
-            {
-                taskPath: task.path,
-                currentStatus: task.status,
-                newStatus
+            // Validate metadata if provided
+            if (input.metadata) {
+                taskMetadataSchema.parse(input.metadata);
             }
-        );
+        } catch (error) {
+            this.logger.error('Task creation validation failed', {
+                error,
+                input
+            });
+            throw error;
+        }
     }
 
-    // Check dependencies for COMPLETED status
-    if (newStatus === TaskStatus.COMPLETED) {
-        for (const depPath of task.dependencies) {
-            const depTask = await getTaskByPath(depPath);
-            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
+    /**
+     * Validates task update input
+     */
+    async validateUpdate(path: string, updates: UpdateTaskInput): Promise<void> {
+        try {
+            // Get existing task
+            const existingTask = await this.storage.getTask(path);
+            if (!existingTask) {
                 throw createError(
-                    ErrorCodes.TASK_DEPENDENCY,
-                    `Cannot complete task: dependency ${depPath} is not completed`,
-                    'validateTaskStatusTransition',
-                    undefined,
-                    {
-                        taskPath: task.path,
-                        dependencyPath: depPath,
-                        dependencyStatus: depTask?.status
-                    }
+                    ErrorCodes.TASK_NOT_FOUND,
+                    `Task not found: ${path}`,
+                    'TaskValidator.validateUpdate'
                 );
             }
-        }
-    }
-
-    // Check dependencies for IN_PROGRESS status
-    if (newStatus === TaskStatus.IN_PROGRESS) {
-        const blockedByDeps = await isBlockedByDependencies(task, getTaskByPath);
-        if (blockedByDeps) {
-            throw createError(
-                ErrorCodes.TASK_DEPENDENCY,
-                'Cannot start task: blocked by incomplete dependencies',
-                'validateTaskStatusTransition',
-                undefined,
-                {
-                    taskPath: task.path,
-                    dependencies: task.dependencies
-                }
-            );
-        }
-    }
-}
-
-/**
- * Checks if a task is blocked by its dependencies
- */
-async function isBlockedByDependencies(
-    task: z.infer<typeof baseTaskSchema>,
-    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
-): Promise<boolean> {
-    for (const depPath of task.dependencies) {
-        const depTask = await getTaskByPath(depPath);
-        if (!depTask || depTask.status === TaskStatus.FAILED || 
-            depTask.status === TaskStatus.BLOCKED || 
-            depTask.status === TaskStatus.PENDING) {
-            return true;
-        }
-    }
-    return false;
-}
-
-/**
- * Detects circular dependencies in task relationships
- */
-export async function detectDependencyCycle(
-    task: z.infer<typeof baseTaskSchema>,
-    newDeps: string[],
-    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
-): Promise<boolean> {
-    const visited = new Set<string>();
-    const recursionStack = new Set<string>();
-
-    async function dfs(currentPath: string): Promise<boolean> {
-        if (recursionStack.has(currentPath)) return true;
-        if (visited.has(currentPath)) return false;
-
-        visited.add(currentPath);
-        recursionStack.add(currentPath);
-
-        const current = await getTaskByPath(currentPath);
-        if (!current) return false;
-
-        // Check both existing and new dependencies
-        const allDeps = currentPath === task.path ? newDeps : current.dependencies;
-        for (const depPath of allDeps) {
-            if (await dfs(depPath)) return true;
-        }
-
-        recursionStack.delete(currentPath);
-        return false;
-    }
-
-    return await dfs(task.path);
-}
-
-export class TaskValidator {
-  private readonly logger: Logger;
-  private readonly pathValidator: PathValidator;
-
-  constructor(private readonly storage: TaskStorage) {
-    this.logger = Logger.getInstance().child({ component: 'TaskValidator' });
-    this.pathValidator = new PathValidator({
-      maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
-      maxLength: 1000,
-      allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
-      projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
-      maxProjectNameLength: 100
-    });
-  }
-
-  async validateCreate(input: CreateTaskInput): Promise<void> {
-    try {
-      // Validate required fields
-      if (!input.name) {
-        throw createError(
-          ErrorCodes.INVALID_INPUT,
-          'Task name is required'
-        );
-      }
 
-      // Validate task type
-      if (input.type && !Object.values(TaskType).includes(input.type)) {
-        throw createError(
-          ErrorCodes.INVALID_INPUT,
-          `Invalid task type: ${input.type}`
-        );
-      }
-
-      // Validate path and parent path
-      const pathResult = input.parentPath ? 
-        this.pathValidator.validateTaskPath(input.path, input.parentPath) :
-        this.pathValidator.validatePath(input.path);
-
-      if (!pathResult.isValid) {
-        throw createError(
-          ErrorCodes.INVALID_INPUT,
-          pathResult.error || 'Invalid task path'
-        );
-      }
-
-      // Validate parent path if provided
-      if (input.parentPath) {
-        const parent = await this.storage.getTask(input.parentPath);
-        if (!parent) {
-          throw createError(
-            ErrorCodes.INVALID_INPUT,
-            `Parent task not found: ${input.parentPath}`
-          );
-        }
-
-        // Validate parent-child relationship
-        if (parent.type === TaskType.TASK) {
-          throw createError(
-            ErrorCodes.INVALID_INPUT,
-            'TASK type cannot have child tasks'
-          );
-        }
-      }
+            // Validate schema
+            updateTaskSchema.parse(updates);
 
-      // Validate dependencies if provided
-      if (input.dependencies?.length) {
-        await this.validateDependencies(input.dependencies);
-      }
-
-      // Validate metadata if provided
-      if (input.metadata) {
-        this.validateMetadata(input.metadata);
-      }
-    } catch (error) {
-      this.logger.error('Task creation validation failed', {
-        error,
-        input
-      });
-      throw error;
-    }
-  }
-
-  async validateUpdate(path: string, updates: UpdateTaskInput): Promise<void> {
-    try {
-      const existingTask = await this.storage.getTask(path);
-      if (!existingTask) {
-        throw createError(
-          ErrorCodes.TASK_NOT_FOUND,
-          `Task not found: ${path}`
-        );
-      }
+            // Convert to base task type
+            const task: BaseTask = {
+                ...existingTask,
+                dependencies: existingTask.dependencies || [],
+                subtasks: existingTask.subtasks || [],
+                metadata: existingTask.metadata || {}
+            };
 
-      // Validate task type change
-      if (updates.type && updates.type !== existingTask.type) {
-        // Check if task has children when changing to TASK type
-        if (updates.type === TaskType.TASK) {
-          const hasChildren = await this.storage.hasChildren(path);
-          if (hasChildren) {
-            throw createError(
-              ErrorCodes.INVALID_INPUT,
-              'Cannot change to TASK type when task has children'
-            );
-          }
-        }
-      }
+            // Validate type change
+            if (updates.type && updates.type !== existingTask.type) {
+                const hasChildren = await this.storage.hasChildren(path);
+                await this.validators.validateTypeChange(task, updates.type, hasChildren);
+            }
 
-      // Validate status value and change
-      if (updates.status) {
-        // Validate status enum value
-        if (!Object.values(TaskStatus).includes(updates.status)) {
-          throw createError(
-            ErrorCodes.INVALID_INPUT,
-            `Invalid status value: ${updates.status}`
-          );
-        }
-        await this.validateStatusChange(updates.status, path);
-      }
+            // Validate status change
+            if (updates.status && updates.status !== existingTask.status) {
+                const siblings = await this.storage.getSubtasks(existingTask.parentPath || '');
+                await this.validators.validateStatus(
+                    task,
+                    updates.status,
+                    this.storage.getTask.bind(this.storage),
+                    siblings
+                );
+            }
 
-      // Validate dependencies change and check for cycles
-      if (updates.dependencies) {
-        await this.validateDependencies(updates.dependencies);
-        const hasCycle = await detectDependencyCycle(
-          existingTask,
-          updates.dependencies,
-          this.storage.getTask.bind(this.storage)
-        );
-        if (hasCycle) {
-          throw createError(
-            ErrorCodes.TASK_CYCLE,
-            'Circular dependencies detected in task relationships'
-          );
-        }
-      }
+            // Validate dependencies change
+            if (updates.dependencies) {
+                await this.validators.validateDependencies(
+                    task,
+                    updates.dependencies,
+                    this.storage.getTask.bind(this.storage)
+                );
+            }
 
-      // Validate metadata updates with schema
-      if (updates.metadata) {
-        try {
-          taskMetadataSchema.parse(updates.metadata);
+            // Validate metadata updates
+            if (updates.metadata) {
+                taskMetadataSchema.parse({
+                    ...existingTask.metadata,
+                    ...updates.metadata
+                });
+            }
         } catch (error) {
-          throw createError(
-            ErrorCodes.INVALID_INPUT,
-            `Invalid metadata: ${error instanceof Error ? error.message : String(error)}`
-          );
+            this.logger.error('Task update validation failed', {
+                error,
+                path,
+                updates
+            });
+            throw error;
         }
-      }
-    } catch (error) {
-      this.logger.error('Task update validation failed', {
-        error,
-        path,
-        updates
-      });
-      throw error;
-    }
-  }
-
-  private async validateDependencies(dependencies: string[]): Promise<void> {
-    // Check for missing dependencies
-    const missingDeps: string[] = [];
-    for (const depPath of dependencies) {
-      const depTask = await this.storage.getTask(depPath);
-      if (!depTask) {
-        missingDeps.push(depPath);
-      }
     }
-
-    if (missingDeps.length > 0) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        `Missing dependencies: ${missingDeps.join(', ')}`
-      );
-    }
-
-    // Check for circular dependencies using shared utility
-    const dummyTask: Task = {
-      path: 'temp',
-      name: 'Temporary Task',
-      type: TaskType.TASK,
-      status: TaskStatus.PENDING,
-      created: Date.now(),
-      updated: Date.now(),
-      version: 1,
-      projectPath: 'temp',
-      dependencies: [],
-      subtasks: [],
-      metadata: {}
-    };
-
-    const hasCycle = await detectDependencyCycle(
-      dummyTask,
-      dependencies,
-      this.storage.getTask.bind(this.storage)
-    );
-
-    if (hasCycle) {
-      throw createError(
-        ErrorCodes.TASK_CYCLE,
-        'Circular dependencies detected in task relationships'
-      );
-    }
-  }
-
-  private async validateStatusChange(
-    newStatus: TaskStatus,
-    path: string
-  ): Promise<void> {
-    // Clear cache before validation
-    if ('clearCache' in this.storage) {
-      await (this.storage as any).clearCache();
-    }
-
-    const task = await this.storage.getTask(path);
-    if (!task) {
-      throw createError(
-        ErrorCodes.TASK_NOT_FOUND,
-        `Task not found: ${path}`
-      );
-    }
-
-    // Validate version hasn't changed
-    const currentTask = await this.storage.getTask(path);
-    if (currentTask && currentTask.metadata.version !== task.metadata.version) {
-      throw createError(
-        ErrorCodes.CONCURRENT_MODIFICATION,
-        'Task has been modified by another process'
-      );
-    }
-
-    // Use shared validation utility
-    await validateTaskStatusTransition(
-      task,
-      newStatus,
-      this.storage.getTask.bind(this.storage)
-    );
-
-    // Check parent task constraints
-    if (task.parentPath) {
-      const parent = await this.storage.getTask(task.parentPath);
-      if (parent) {
-        const siblings = await this.storage.getSubtasks(parent.path);
-        
-        // Cannot complete if siblings are blocked
-        if (newStatus === TaskStatus.COMPLETED && 
-            siblings.some(s => s.status === TaskStatus.BLOCKED)) {
-          throw createError(
-            ErrorCodes.TASK_STATUS,
-            'Cannot complete task while sibling tasks are blocked'
-          );
-        }
-
-        // Cannot start if siblings have failed
-        if (newStatus === TaskStatus.IN_PROGRESS && 
-            siblings.some(s => s.status === TaskStatus.FAILED)) {
-          throw createError(
-            ErrorCodes.TASK_STATUS,
-            'Cannot start task while sibling tasks have failed'
-          );
-        }
-      }
-    }
-  }
-
-  private validateMetadata(metadata: Record<string, unknown>): void {
-    // Add any specific metadata validation rules here
-    // For now, just ensure it's an object
-    if (typeof metadata !== 'object' || metadata === null) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Metadata must be an object'
-      );
-    }
-  }
-
 }
diff --git a/src/tools/handler.ts b/src/tools/handler.ts
index a91e11a..03a89a9 100644
--- a/src/tools/handler.ts
+++ b/src/tools/handler.ts
@@ -58,15 +58,16 @@ export class ToolHandler {
     /**
      * Validates task hierarchy rules
      */
-    private async validateTaskHierarchy(args: Record<string, unknown>, operation: 'create' | 'update'): Promise<void> {
+    private async validateTaskHierarchy(args: CreateTaskInput | UpdateTaskInput & { path?: string }, operation: 'create' | 'update'): Promise<void> {
         const taskType = (args.type || 'TASK').toString().toUpperCase();
-        const parentPath = args.parentPath as string | undefined;
+        const parentPath = ('parentPath' in args) ? args.parentPath : undefined;
 
         // Validate task type is uppercase
         if (taskType !== taskType.toUpperCase()) {
             throw createError(
                 ErrorCodes.INVALID_INPUT,
-                'Task type must be uppercase (TASK, GROUP, or MILESTONE)'
+                'Task type must be uppercase (TASK, GROUP, or MILESTONE)',
+                'validateTaskHierarchy'
             );
         }
 
@@ -74,7 +75,8 @@ export class ToolHandler {
         if (!['TASK', 'GROUP', 'MILESTONE'].includes(taskType)) {
             throw createError(
                 ErrorCodes.INVALID_INPUT,
-                'Invalid task type. Must be TASK, GROUP, or MILESTONE'
+                'Invalid task type. Must be TASK, GROUP, or MILESTONE',
+                'validateTaskHierarchy'
             );
         }
 
@@ -84,7 +86,8 @@ export class ToolHandler {
             if (!parent) {
                 throw createError(
                     ErrorCodes.INVALID_INPUT,
-                    `Parent task '${parentPath}' not found`
+                    `Parent task '${parentPath}' not found`,
+                    'validateTaskHierarchy'
                 );
             }
 
@@ -94,7 +97,8 @@ export class ToolHandler {
                     if (!['TASK', 'GROUP'].includes(taskType)) {
                         throw createError(
                             ErrorCodes.INVALID_INPUT,
-                            'MILESTONE can only contain TASK or GROUP types'
+                            'MILESTONE can only contain TASK or GROUP types',
+                            'validateTaskHierarchy'
                         );
                     }
                     break;
@@ -102,14 +106,16 @@ export class ToolHandler {
                     if (taskType !== 'TASK') {
                         throw createError(
                             ErrorCodes.INVALID_INPUT,
-                            'GROUP can only contain TASK types'
+                            'GROUP can only contain TASK types',
+                            'validateTaskHierarchy'
                         );
                     }
                     break;
                 case TaskType.TASK:
                     throw createError(
                         ErrorCodes.INVALID_INPUT,
-                        'TASK type cannot contain subtasks'
+                        'TASK type cannot contain subtasks',
+                        'validateTaskHierarchy'
                     );
             }
         }
@@ -121,7 +127,8 @@ export class ToolHandler {
             if (!task) {
                 throw createError(
                     ErrorCodes.INVALID_INPUT,
-                    `Task '${path}' not found`
+                    `Task '${path}' not found`,
+                    'validateTaskHierarchy'
                 );
             }
 
@@ -131,7 +138,8 @@ export class ToolHandler {
                 if (subtasks.length > 0) {
                     throw createError(
                         ErrorCodes.INVALID_INPUT,
-                        'Cannot change to TASK type while having subtasks'
+                        'Cannot change to TASK type while having subtasks',
+                        'validateTaskHierarchy'
                     );
                 }
             }
@@ -143,7 +151,8 @@ export class ToolHandler {
                 if (invalidSubtasks.length > 0) {
                     throw createError(
                         ErrorCodes.INVALID_INPUT,
-                        'GROUP can only contain TASK type subtasks'
+                        'GROUP can only contain TASK type subtasks',
+                        'validateTaskHierarchy'
                     );
                 }
             }
@@ -354,7 +363,8 @@ export class ToolHandler {
                                 default:
                                     throw createError(
                                         ErrorCodes.INVALID_INPUT,
-                                        `Invalid operation type: ${op.type}`
+                                        `Invalid operation type: ${op.type}`,
+                                        'handleToolCall'
                                     );
                             }
                         } catch (error) {
@@ -480,7 +490,8 @@ export class ToolHandler {
                 (args as any).metadata?.dependencies) {
                 throw createError(
                     ErrorCodes.INVALID_INPUT,
-                    'Dependencies must be specified at root level, not in metadata'
+                    'Dependencies must be specified at root level, not in metadata',
+                    'handleToolCall'
                 );
             }
 
@@ -528,7 +539,8 @@ export class ToolHandler {
             this.logger.error('Failed to format response', { error });
             throw createError(
                 ErrorCodes.INTERNAL_ERROR,
-                'Failed to format response'
+                'Failed to format response',
+                'formatResponse'
             );
         }
     }
diff --git a/src/types/error.ts b/src/types/error.ts
index 22d08a6..8e78ba1 100644
--- a/src/types/error.ts
+++ b/src/types/error.ts
@@ -1,245 +1,246 @@
 /**
- * Error-related type definitions
+ * Error severity levels
  */
+export enum ErrorSeverity {
+    LOW = 'LOW',         // Minor issues, system continues normally
+    MEDIUM = 'MEDIUM',   // Significant issues, operation failed but system stable
+    HIGH = 'HIGH',       // Critical issues, system stability may be affected
+    CRITICAL = 'CRITICAL' // Severe issues, system stability compromised
+}
 
 /**
- * Error codes enumeration
- * @description Defines all possible error codes in the system
+ * Error codes for different types of errors
  */
 export const ErrorCodes = {
-    // Task-related errors
-    TASK_NOT_FOUND: 'TASK_NOT_FOUND',
-    TASK_VALIDATION: 'TASK_VALIDATION',
-    TASK_DEPENDENCY: 'TASK_DEPENDENCY',
-    TASK_STATUS: 'TASK_STATUS',
-    TASK_DUPLICATE: 'TASK_DUPLICATE',
-    TASK_INVALID_TYPE: 'TASK_INVALID_TYPE',
-    TASK_INVALID_STATUS: 'TASK_INVALID_STATUS',
-    TASK_INVALID_PARENT: 'TASK_INVALID_PARENT',
-    TASK_OPERATION_FAILED: 'TASK_OPERATION_FAILED',
-    
-    // Storage-related errors
-    STORAGE_READ: 'STORAGE_READ',
-    STORAGE_WRITE: 'STORAGE_WRITE',
-    STORAGE_INIT: 'STORAGE_INIT',
-    STORAGE_DELETE: 'STORAGE_DELETE',
-    STORAGE_PERMISSION: 'STORAGE_PERMISSION',
-    STORAGE_NOT_FOUND: 'STORAGE_NOT_FOUND',
-    STORAGE_TRANSACTION: 'STORAGE_TRANSACTION',
-    STORAGE_ROLLBACK: 'STORAGE_ROLLBACK',
-    STORAGE_COMMIT: 'STORAGE_COMMIT',
-    
+    // Task errors
+    TASK_NOT_FOUND: 'TASK_NOT_FOUND' as const,
+    TASK_VALIDATION: 'TASK_VALIDATION' as const,
+    TASK_DEPENDENCY: 'TASK_DEPENDENCY' as const,
+    TASK_STATUS: 'TASK_STATUS' as const,
+    TASK_OPERATION_FAILED: 'TASK_OPERATION_FAILED' as const,
+    TASK_INITIALIZATION: 'TASK_INITIALIZATION' as const,
+    TASK_DUPLICATE: 'TASK_DUPLICATE' as const,
+    TASK_INVALID_TYPE: 'TASK_INVALID_TYPE' as const,
+    TASK_INVALID_STATUS: 'TASK_INVALID_STATUS' as const,
+    TASK_INVALID_PARENT: 'TASK_INVALID_PARENT' as const,
+    TASK_INVALID_PATH: 'TASK_INVALID_PATH' as const,
+    TASK_PARENT_NOT_FOUND: 'TASK_PARENT_NOT_FOUND' as const,
+    TASK_PARENT_TYPE: 'TASK_PARENT_TYPE' as const,
+    TASK_CYCLE: 'TASK_CYCLE' as const,
+
+    // Storage errors
+    STORAGE_INIT: 'STORAGE_INIT' as const,
+    STORAGE_CONNECTION: 'STORAGE_CONNECTION' as const,
+    STORAGE_QUERY: 'STORAGE_QUERY' as const,
+    STORAGE_TRANSACTION: 'STORAGE_TRANSACTION' as const,
+    STORAGE_MIGRATION: 'STORAGE_MIGRATION' as const,
+    STORAGE_BACKUP: 'STORAGE_BACKUP' as const,
+    STORAGE_INTEGRITY: 'STORAGE_INTEGRITY' as const,
+    STORAGE_READ: 'STORAGE_READ' as const,
+    STORAGE_WRITE: 'STORAGE_WRITE' as const,
+    STORAGE_DELETE: 'STORAGE_DELETE' as const,
+    STORAGE_ROLLBACK: 'STORAGE_ROLLBACK' as const,
+    STORAGE_COMMIT: 'STORAGE_COMMIT' as const,
+    STORAGE_PERMISSION: 'STORAGE_PERMISSION' as const,
+    STORAGE_NOT_FOUND: 'STORAGE_NOT_FOUND' as const,
+    STORAGE_ERROR: 'STORAGE_ERROR' as const,
+    DATABASE_ERROR: 'DATABASE_ERROR' as const,
+
     // Configuration errors
-    CONFIG_MISSING: 'CONFIG_MISSING',
-    CONFIG_INVALID: 'CONFIG_INVALID',
-    CONFIG_TYPE: 'CONFIG_TYPE',
-    CONFIG_VALIDATION: 'CONFIG_VALIDATION',
-    CONFIG_REQUIRED: 'CONFIG_REQUIRED',
-    
-    // Server errors
-    SERVER_INIT: 'SERVER_INIT',
-    SERVER_SHUTDOWN: 'SERVER_SHUTDOWN',
-    SERVER_CONNECTION: 'SERVER_CONNECTION',
-    SERVER_TIMEOUT: 'SERVER_TIMEOUT',
-    SERVER_OVERLOAD: 'SERVER_OVERLOAD',
-    
-    // Tool-related errors
-    TOOL_NOT_FOUND: 'TOOL_NOT_FOUND',
-    TOOL_EXECUTION: 'TOOL_EXECUTION',
-    TOOL_VALIDATION: 'TOOL_VALIDATION',
-    TOOL_TIMEOUT: 'TOOL_TIMEOUT',
-    TOOL_PERMISSION: 'TOOL_PERMISSION',
-    
-    // General errors
-    INTERNAL_ERROR: 'INTERNAL_ERROR',
-    INVALID_INPUT: 'INVALID_INPUT',
-    OPERATION_FAILED: 'OPERATION_FAILED',
-    VALIDATION_ERROR: 'VALIDATION_ERROR',
-    PERMISSION_DENIED: 'PERMISSION_DENIED',
-    NOT_IMPLEMENTED: 'NOT_IMPLEMENTED',
-    TIMEOUT: 'TIMEOUT'
+    CONFIG_INVALID: 'CONFIG_INVALID' as const,
+    CONFIG_MISSING: 'CONFIG_MISSING' as const,
+    CONFIG_TYPE: 'CONFIG_TYPE' as const,
+    CONFIG_VALIDATION: 'CONFIG_VALIDATION' as const,
+    CONFIG_REQUIRED: 'CONFIG_REQUIRED' as const,
+
+    // Tool errors
+    TOOL_NOT_FOUND: 'TOOL_NOT_FOUND' as const,
+    TOOL_EXECUTION: 'TOOL_EXECUTION' as const,
+    TOOL_TIMEOUT: 'TOOL_TIMEOUT' as const,
+    TOOL_VALIDATION: 'TOOL_VALIDATION' as const,
+    TOOL_INITIALIZATION: 'TOOL_INITIALIZATION' as const,
+    TOOL_PERMISSION: 'TOOL_PERMISSION' as const,
+
+    // System errors
+    SYSTEM_RESOURCE: 'SYSTEM_RESOURCE' as const,
+    SYSTEM_MEMORY: 'SYSTEM_MEMORY' as const,
+    SYSTEM_DISK: 'SYSTEM_DISK' as const,
+    SYSTEM_NETWORK: 'SYSTEM_NETWORK' as const,
+    SYSTEM_TIMEOUT: 'SYSTEM_TIMEOUT' as const,
+    TIMEOUT: 'TIMEOUT' as const,
+    TIMEOUT_ERROR: 'TIMEOUT_ERROR' as const,
+    CONCURRENCY_ERROR: 'CONCURRENCY_ERROR' as const,
+
+    // Transaction errors
+    TRANSACTION_ERROR: 'TRANSACTION_ERROR' as const,
+
+    // Input/Output errors
+    IO_READ: 'IO_READ' as const,
+    IO_WRITE: 'IO_WRITE' as const,
+    IO_PERMISSION: 'IO_PERMISSION' as const,
+    IO_NOT_FOUND: 'IO_NOT_FOUND' as const,
+
+    // Cache errors
+    CACHE_MISS: 'CACHE_MISS' as const,
+    CACHE_INVALID: 'CACHE_INVALID' as const,
+    CACHE_FULL: 'CACHE_FULL' as const,
+    CACHE_CORRUPTION: 'CACHE_CORRUPTION' as const,
+
+    // Event errors
+    EVENT_INVALID: 'EVENT_INVALID' as const,
+    EVENT_HANDLER: 'EVENT_HANDLER' as const,
+    EVENT_DISPATCH: 'EVENT_DISPATCH' as const,
+    EVENT_SUBSCRIPTION: 'EVENT_SUBSCRIPTION' as const,
+
+    // Validation errors
+    VALIDATION_TYPE: 'VALIDATION_TYPE' as const,
+    VALIDATION_RANGE: 'VALIDATION_RANGE' as const,
+    VALIDATION_FORMAT: 'VALIDATION_FORMAT' as const,
+    VALIDATION_CONSTRAINT: 'VALIDATION_CONSTRAINT' as const,
+    VALIDATION_ERROR: 'VALIDATION_ERROR' as const,
+
+    // Authentication/Authorization errors
+    AUTH_INVALID: 'AUTH_INVALID' as const,
+    AUTH_EXPIRED: 'AUTH_EXPIRED' as const,
+    AUTH_MISSING: 'AUTH_MISSING' as const,
+    AUTH_FORBIDDEN: 'AUTH_FORBIDDEN' as const,
+    PERMISSION_DENIED: 'PERMISSION_DENIED' as const,
+
+    // Generic errors
+    INVALID_INPUT: 'INVALID_INPUT' as const,
+    INVALID_STATE: 'INVALID_STATE' as const,
+    OPERATION_FAILED: 'OPERATION_FAILED' as const,
+    NOT_IMPLEMENTED: 'NOT_IMPLEMENTED' as const,
+    INTERNAL_ERROR: 'INTERNAL_ERROR' as const
 } as const;
 
+// Update ErrorCode type to include all possible values
 export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];
 
 /**
- * Base error interface
- * @description Common properties for all errors
+ * Error context information
  */
-export interface BaseError {
-    /** Error name/type */
-    name: string;
-    /** Error message */
-    message: string;
-    /** Error code */
-    code: ErrorCode;
+export interface ErrorContext {
+    /** Operation that failed */
+    operation: string;
+    
+    /** When the error occurred */
+    timestamp: number;
+    
+    /** Error severity level */
+    severity: ErrorSeverity;
+    
+    /** Additional context information */
+    metadata?: Record<string, unknown>;
+    
     /** Error stack trace */
-    stack?: string;
-    /** Additional error details */
-    details?: unknown;
-}
+    stackTrace?: string;
 
-/**
- * Error severity levels
- * @description Defines the severity of errors for logging and handling
- */
-export const ErrorSeverity = {
-    DEBUG: 'debug',
-    INFO: 'info',
-    WARN: 'warn',
-    ERROR: 'error',
-    FATAL: 'fatal'
-} as const;
+    /** Correlation ID for tracking related errors */
+    correlationId?: string;
 
-export type ErrorSeverityLevel = typeof ErrorSeverity[keyof typeof ErrorSeverity];
+    /** User ID associated with the error */
+    userId?: string;
 
-/**
- * Extended error interface with severity
- * @description Error interface with additional severity information
- */
-export interface ExtendedError extends BaseError {
-    /** Error severity level */
-    severity: ErrorSeverityLevel;
-    /** Timestamp when the error occurred */
-    timestamp: string;
-    /** Request ID associated with the error */
-    requestId?: string;
     /** Session ID associated with the error */
     sessionId?: string;
-    /** User ID associated with the error */
-    userId?: string;
-    /** Additional context about the error */
-    context?: Record<string, unknown>;
-}
 
-/**
- * Error response interface
- * @description Standard error response format
- */
-export interface ErrorResponse {
-    /** Operation success status (always false for errors) */
-    success: false;
-    /** Error information */
-    error: {
-        /** Error code */
-        code: ErrorCode;
-        /** Error message */
-        message: string;
-        /** Additional error details */
-        details?: unknown;
-    };
-    /** Response metadata */
-    metadata?: {
-        /** Operation timestamp */
-        timestamp: string;
-        /** Request identifier */
-        requestId: string;
-        /** Session identifier */
-        sessionId: string;
-    };
-}
+    /** Request ID associated with the error */
+    requestId?: string;
 
-/**
- * Error handler options interface
- * @description Configuration options for error handling
- */
-export interface ErrorHandlerOptions {
-    /** Whether to include stack traces in errors */
-    includeStack?: boolean;
-    /** Default error severity level */
-    defaultSeverity?: ErrorSeverityLevel;
-    /** Whether to log errors automatically */
-    autoLog?: boolean;
-    /** Custom error transformers */
-    transformers?: {
-        [key: string]: (error: unknown) => ErrorResponse;
-    };
+    /** Component where the error occurred */
+    component?: string;
+
+    /** Error category for grouping */
+    category?: string;
+
+    /** Whether error has been handled */
+    handled?: boolean;
+
+    /** Recovery attempts made */
+    recoveryAttempts?: number;
 }
 
 /**
- * Error category mapping
- * @description Maps error codes to their categories for better organization
+ * Error details for user display
  */
-export const ErrorCategories = {
-    TASK: [
-        ErrorCodes.TASK_NOT_FOUND,
-        ErrorCodes.TASK_VALIDATION,
-        ErrorCodes.TASK_DEPENDENCY,
-        ErrorCodes.TASK_STATUS,
-        ErrorCodes.TASK_DUPLICATE,
-        ErrorCodes.TASK_INVALID_TYPE,
-        ErrorCodes.TASK_INVALID_STATUS,
-        ErrorCodes.TASK_INVALID_PARENT,
-        ErrorCodes.TASK_OPERATION_FAILED
-    ],
-    STORAGE: [
-        ErrorCodes.STORAGE_READ,
-        ErrorCodes.STORAGE_WRITE,
-        ErrorCodes.STORAGE_INIT,
-        ErrorCodes.STORAGE_DELETE,
-        ErrorCodes.STORAGE_PERMISSION,
-        ErrorCodes.STORAGE_NOT_FOUND,
-        ErrorCodes.STORAGE_TRANSACTION,
-        ErrorCodes.STORAGE_ROLLBACK,
-        ErrorCodes.STORAGE_COMMIT
-    ],
-    CONFIG: [
-        ErrorCodes.CONFIG_MISSING,
-        ErrorCodes.CONFIG_INVALID,
-        ErrorCodes.CONFIG_TYPE,
-        ErrorCodes.CONFIG_VALIDATION,
-        ErrorCodes.CONFIG_REQUIRED
-    ],
-    SERVER: [
-        ErrorCodes.SERVER_INIT,
-        ErrorCodes.SERVER_SHUTDOWN,
-        ErrorCodes.SERVER_CONNECTION,
-        ErrorCodes.SERVER_TIMEOUT,
-        ErrorCodes.SERVER_OVERLOAD
-    ],
-    TOOL: [
-        ErrorCodes.TOOL_NOT_FOUND,
-        ErrorCodes.TOOL_EXECUTION,
-        ErrorCodes.TOOL_VALIDATION,
-        ErrorCodes.TOOL_TIMEOUT,
-        ErrorCodes.TOOL_PERMISSION
-    ],
-    GENERAL: [
-        ErrorCodes.INTERNAL_ERROR,
-        ErrorCodes.INVALID_INPUT,
-        ErrorCodes.OPERATION_FAILED,
-        ErrorCodes.VALIDATION_ERROR,
-        ErrorCodes.PERMISSION_DENIED,
-        ErrorCodes.NOT_IMPLEMENTED,
-        ErrorCodes.TIMEOUT
-    ]
-} as const;
-
-export type ErrorCategory = keyof typeof ErrorCategories;
+export interface ErrorDetails {
+    /** User-friendly error message */
+    message: string;
+    
+    /** Error code for programmatic handling */
+    code: ErrorCode;
+    
+    /** Operation that failed */
+    operation: string;
+    
+    /** When the error occurred */
+    timestamp: number;
+    
+    /** Additional context for the user */
+    context?: Record<string, unknown>;
+}
 
 /**
- * Error metadata interface
- * @description Additional metadata for error tracking and analysis
+ * Error recovery options
  */
-export interface ErrorMetadata {
-    /** Error category */
-    category: ErrorCategory;
-    /** Error severity */
-    severity: ErrorSeverityLevel;
-    /** Whether the error is retryable */
+export interface ErrorRecovery {
+    /** Whether the error can be retried */
     retryable: boolean;
-    /** Suggested recovery action */
-    recovery?: string;
-    /** Related documentation link */
-    docs?: string;
-    /** Additional metadata */
-    [key: string]: unknown;
+    
+    /** Suggested retry delay in milliseconds */
+    retryDelay?: number;
+    
+    /** Maximum number of retry attempts */
+    maxRetries?: number;
+    
+    /** Recovery actions that can be taken */
+    actions?: Array<{
+        /** Action identifier */
+        id: string;
+        
+        /** User-friendly action name */
+        name: string;
+        
+        /** Action description */
+        description: string;
+        
+        /** Whether the action requires user confirmation */
+        requiresConfirmation: boolean;
+    }>;
 }
 
 /**
- * Error mapping type
- * @description Maps error codes to their metadata
+ * Error monitoring metadata
  */
-export type ErrorMapping = {
-    [K in ErrorCode]: ErrorMetadata;
-};
+export interface ErrorMonitoring {
+    /** Error instance identifier */
+    errorId: string;
+    
+    /** Related error group */
+    groupId?: string;
+    
+    /** Error frequency information */
+    frequency?: {
+        /** Count in current period */
+        count: number;
+        
+        /** Period start timestamp */
+        periodStart: number;
+        
+        /** Period duration in milliseconds */
+        periodDuration: number;
+    };
+    
+    /** Error impact assessment */
+    impact?: {
+        /** Number of affected users */
+        userCount?: number;
+        
+        /** Number of affected operations */
+        operationCount?: number;
+        
+        /** System components affected */
+        components?: string[];
+    };
+}
diff --git a/src/types/events.ts b/src/types/events.ts
index 8e5eeb8..88699d5 100644
--- a/src/types/events.ts
+++ b/src/types/events.ts
@@ -3,32 +3,81 @@
  */
 import { MonitoringMetrics } from './storage.js';
 
-// Base event type
-export type AtlasEvent = SystemEvent | TaskEvent | CacheEvent | ErrorEvent | TransactionEvent | BatchEvent;
+// Base event interface with common properties
+export interface BaseEvent {
+  type: EventTypes;
+  timestamp: number;
+  retryCount?: number;
+}
 
 // Event handler types
 export type EventHandler<T extends AtlasEvent> = (event: T) => void | Promise<void>;
 
 export interface EventSubscription {
-    unsubscribe: () => void;
+  unsubscribe: () => void;
+  type: EventTypes | '*';
+  createdAt: number;
+}
+
+export interface EventHandlerOptions {
+  timeout?: number;
+  maxRetries?: number;
+  batchOptions?: {
+    enabled: boolean;
+    maxBatchSize?: number;
+    maxWaitTime?: number;
+  };
 }
 
-// Transaction event interface
-export interface TransactionEvent {
-    type: EventTypes;
-    timestamp: number;
-    transactionId: string;
-    metadata?: Record<string, unknown>;
+// Event interfaces extending BaseEvent
+export interface SystemEvent extends BaseEvent {
+  metadata?: SystemEventMetadata;
 }
 
-// Batch event interface
-export interface BatchEvent {
-    type: EventTypes;
-    timestamp: number;
-    batchId: string;
-    metadata?: Record<string, unknown>;
+export interface TaskEvent extends BaseEvent {
+  taskId: string;
+  task: unknown;
+  metadata?: Record<string, unknown>;
+  changes?: {
+    before: unknown;
+    after: unknown;
+  };
+}
+
+export interface CacheEvent extends BaseEvent {
+  metadata: {
+    memoryUsage: {
+      heapUsed: number;
+      heapTotal: number;
+      rss: number;
+    };
+    threshold: number;
+  };
 }
 
+export interface ErrorEvent extends BaseEvent {
+  type: EventTypes.SYSTEM_ERROR;
+  error: Error;
+  context?: {
+    component: string;
+    operation: string;
+    args?: unknown;
+  };
+}
+
+export interface TransactionEvent extends BaseEvent {
+  transactionId: string;
+  metadata?: Record<string, unknown>;
+}
+
+export interface BatchEvent extends BaseEvent {
+  batchId: string;
+  metadata?: Record<string, unknown>;
+}
+
+// Union type of all event types
+export type AtlasEvent = SystemEvent | TaskEvent | CacheEvent | ErrorEvent | TransactionEvent | BatchEvent;
+
 export enum EventTypes {
     // System events
     SYSTEM_STARTUP = 'system_startup',
@@ -62,7 +111,17 @@ export enum EventTypes {
     // Cache events
     MEMORY_PRESSURE = 'memory_pressure',
     CACHE_CLEARED = 'cache_cleared',
-    CACHE_INVALIDATED = 'cache_invalidated'
+    CACHE_INVALIDATED = 'cache_invalidated',
+
+    // Logger events
+    LOGGER_INITIALIZED = 'logger_initialized',
+    LOGGER_SHUTDOWN = 'logger_shutdown',
+    LOGGER_TRANSPORT_ERROR = 'logger_transport_error',
+    LOGGER_TRANSPORT_RECOVERED = 'logger_transport_recovered',
+    LOGGER_TRANSPORT_FAILED = 'logger_transport_failed',
+    LOGGER_FAILOVER_USED = 'logger_failover_used',
+    LOGGER_CRITICAL_FAILURE = 'logger_critical_failure',
+    LOGGER_HEALTH_CHECK = 'logger_health_check'
 }
 
 export interface SystemEventMetadata {
@@ -104,46 +163,14 @@ export interface SystemEventMetadata {
         errorCount: number;
         avgResponseTime: number;
     };
-}
-
-export interface SystemEvent {
-    type: EventTypes;
-    timestamp: number;
-    metadata?: SystemEventMetadata;
-}
-
-export interface ErrorEvent {
-    type: EventTypes.SYSTEM_ERROR;
-    timestamp: number;
-    error: Error;
-    context?: {
-        component: string;
-        operation: string;
-        args?: unknown;
-    };
-}
 
-export interface TaskEvent {
-    type: EventTypes;
-    timestamp: number;
-    taskId: string;
-    task: unknown;
-    metadata?: Record<string, unknown>;
-    changes?: {
-        before: unknown;
-        after: unknown;
-    };
+    // Logger info
+    transports?: string[];
+    failoverEnabled?: boolean;
+    transport?: string;
+    status?: Record<string, unknown>;
+    originalErrors?: string[];
+    errors?: string[];
 }
 
-export interface CacheEvent {
-    type: EventTypes;
-    timestamp: number;
-    metadata: {
-        memoryUsage: {
-            heapUsed: number;
-            heapTotal: number;
-            rss: number;
-        };
-        threshold: number;
-    };
-}
+// End of file - removed duplicate interface definitions
diff --git a/src/types/logging.ts b/src/types/logging.ts
index ac6e06a..de9276d 100644
--- a/src/types/logging.ts
+++ b/src/types/logging.ts
@@ -1,203 +1,155 @@
 /**
  * Logging-related type definitions
  */
+import { EventManager } from '../events/event-manager.js';
 
 /**
- * Log levels enumeration
- * @description Defines the possible log levels using Winston's standard levels
+ * Log levels
  */
 export const LogLevels = {
-    ERROR: 'error',   // 0
-    WARN: 'warn',     // 1
-    INFO: 'info',     // 2
-    HTTP: 'http',     // 3
-    VERBOSE: 'verbose', // 4
-    DEBUG: 'debug',   // 5
-    SILLY: 'silly'    // 6
+    ERROR: 'error',
+    WARN: 'warn',
+    INFO: 'info',
+    DEBUG: 'debug',
+    HTTP: 'http',
+    VERBOSE: 'verbose',
+    SILLY: 'silly'
 } as const;
 
 export type LogLevel = typeof LogLevels[keyof typeof LogLevels];
 
 /**
- * Log entry interface
- * @description Represents a single log entry
- */
-export interface LogEntry {
-    /** Log timestamp */
-    timestamp: string;
-    /** Log level */
-    level: LogLevel;
-    /** Log message */
-    message: string;
-    /** Additional context */
-    context?: Record<string, unknown>;
-    /** Error information if applicable */
-    error?: {
-        /** Error name */
-        name: string;
-        /** Error message */
-        message: string;
-        /** Error stack trace */
-        stack?: string;
-        /** Error code */
-        code?: string;
-        /** Additional error details */
-        details?: unknown;
-    };
-}
-
-/**
- * Logger configuration interface
- * @description Configuration options for the logger
+ * Logger configuration
  */
 export interface LoggerConfig {
     /** Minimum log level to record */
     minLevel: LogLevel;
-    /** Log directory path */
-    logDir?: string;
     /** Whether to log to console */
     console?: boolean;
     /** Whether to log to file */
     file?: boolean;
-    /** Maximum number of log files */
-    maxFiles?: number;
+    /** Directory for log files */
+    logDir?: string;
     /** Maximum size of each log file in bytes */
     maxFileSize?: number;
-    /** Whether to disable colored console output */
+    /** Maximum number of log files to keep */
+    maxFiles?: number;
+    /** Whether to disable colors in console output */
     noColors?: boolean;
+    /** Event manager instance for logging events */
+    eventManager?: EventManager;
 }
 
 /**
- * Log formatter interface
- * @description Interface for log formatters
+ * Logger health check status
  */
-export interface LogFormatter {
-    /** Format a log entry */
-    format(entry: LogEntry): string;
+export interface LoggerHealthStatus {
+    /** Whether the logger is healthy */
+    healthy: boolean;
+    /** Error details if unhealthy */
+    error?: string;
+    /** Number of consecutive health check failures */
+    consecutiveFailures?: number;
+    /** Timestamp of last health check */
+    lastCheckTime?: number;
+    /** Additional diagnostic information */
+    diagnostics?: {
+        /** File descriptor status */
+        fileDescriptors?: {
+            open: boolean;
+            writable: boolean;
+            error?: string;
+        };
+        /** Transport status */
+        transports?: {
+            console?: {
+                active: boolean;
+                error?: string;
+            };
+            file?: {
+                active: boolean;
+                path?: string;
+                error?: string;
+            };
+        };
+        /** Memory usage */
+        memory?: {
+            heapUsed: number;
+            heapTotal: number;
+            external: number;
+        };
+    };
 }
 
 /**
- * Log transport interface
- * @description Interface for log transports (console, file, etc.)
+ * Logger transport configuration
  */
-export interface LogTransport {
-    /** Write a log entry */
-    write(entry: LogEntry): Promise<void>;
-    /** Initialize the transport */
-    initialize?(): Promise<void>;
-    /** Close the transport */
-    close?(): Promise<void>;
+export interface LoggerTransportConfig {
+    /** Transport type */
+    type: 'console' | 'file';
+    /** Transport-specific options */
+    options?: {
+        /** File path (for file transport) */
+        filename?: string;
+        /** Maximum file size */
+        maxsize?: number;
+        /** Maximum number of files */
+        maxFiles?: number;
+        /** Whether to use colors (for console transport) */
+        colors?: boolean;
+        /** Log format */
+        format?: 'json' | 'simple' | 'pretty';
+    };
 }
 
 /**
- * Child logger context interface
- * @description Context for child loggers
+ * Log entry metadata
  */
-export interface ChildLoggerContext {
-    /** Component name */
+export interface LogMetadata {
+    /** Timestamp of the log entry */
+    timestamp: number;
+    /** Correlation ID for request tracing */
+    correlationId?: string;
+    /** Component that generated the log */
     component?: string;
-    /** Request ID */
-    requestId?: string;
-    /** Session ID */
-    sessionId?: string;
-    /** User ID */
-    userId?: string;
+    /** Operation being performed */
+    operation?: string;
     /** Additional context */
-    [key: string]: unknown;
-}
-
-/**
- * Logger interface
- * @description Interface for logger instances
- */
-export interface Logger {
-    /** Log at DEBUG level */
-    debug(message: string, context?: Record<string, unknown>): void;
-    /** Log at INFO level */
-    info(message: string, context?: Record<string, unknown>): void;
-    /** Log at WARN level */
-    warn(message: string, context?: Record<string, unknown>): void;
-    /** Log at ERROR level */
-    error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
-    /** Log at ERROR level (alias for error, maintains backward compatibility) */
-    fatal(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
-    /** Create a child logger with additional context */
-    child(context: ChildLoggerContext): Logger;
-    /** Initialize the logger */
-    initialize(): Promise<void>;
-}
-
-/**
- * Log file info interface
- * @description Information about a log file
- */
-export interface LogFileInfo {
-    /** File name */
-    name: string;
-    /** File path */
-    path: string;
-    /** File size in bytes */
-    size: number;
-    /** Creation timestamp */
-    created: string;
-    /** Last modified timestamp */
-    modified: string;
-}
-
-/**
- * Log rotation options interface
- * @description Options for log rotation
- */
-export interface LogRotationOptions {
-    /** Maximum file size in bytes */
-    maxSize: number;
-    /** Maximum number of files */
-    maxFiles: number;
-    /** Whether to compress old logs */
-    compress?: boolean;
-    /** Pattern for date in file names */
-    datePattern?: string;
+    context?: Record<string, unknown>;
+    /** Error information */
+    error?: {
+        name: string;
+        message: string;
+        stack?: string;
+        code?: string;
+        details?: unknown;
+    };
 }
 
 /**
- * Log query options interface
- * @description Options for querying logs
+ * Log entry format
  */
-export interface LogQueryOptions {
-    /** Start timestamp */
-    from?: string;
-    /** End timestamp */
-    to?: string;
-    /** Log levels to include */
-    levels?: LogLevel[];
-    /** Search text */
-    search?: string;
-    /** Context filters */
+export interface LogEntry extends LogMetadata {
+    /** Log level */
+    level: LogLevel;
+    /** Log message */
+    message: string;
+    /** Additional context */
     context?: Record<string, unknown>;
-    /** Maximum number of entries */
-    limit?: number;
-    /** Number of entries to skip */
-    offset?: number;
-    /** Sort direction */
-    order?: 'asc' | 'desc';
 }
 
 /**
- * Log query result interface
- * @description Result of a log query
+ * Logger recovery options
  */
-export interface LogQueryResult {
-    /** Log entries */
-    entries: LogEntry[];
-    /** Total number of matching entries */
-    total: number;
-    /** Query metadata */
-    metadata: {
-        /** Query timestamp */
-        timestamp: string;
-        /** Query duration in milliseconds */
-        duration: number;
-        /** Applied filters */
-        filters: Record<string, unknown>;
-    };
+export interface LoggerRecoveryOptions {
+    /** Maximum number of recovery attempts */
+    maxAttempts?: number;
+    /** Delay between recovery attempts (ms) */
+    retryDelay?: number;
+    /** Whether to recreate transports on recovery */
+    recreateTransports?: boolean;
+    /** Whether to flush logs before recovery */
+    flushBeforeRecovery?: boolean;
+    /** Callback for recovery events */
+    onRecoveryAttempt?: (attempt: number, error?: Error) => void;
 }
diff --git a/src/types/task.ts b/src/types/task.ts
index 16efdde..0c6014b 100644
--- a/src/types/task.ts
+++ b/src/types/task.ts
@@ -1,11 +1,7 @@
-/**
- * Task type definitions
- */
-
 export enum TaskType {
     TASK = 'TASK',
-    MILESTONE = 'MILESTONE',
-    GROUP = 'GROUP'
+    GROUP = 'GROUP',
+    MILESTONE = 'MILESTONE'
 }
 
 export enum TaskStatus {
@@ -16,77 +12,65 @@ export enum TaskStatus {
     BLOCKED = 'BLOCKED'
 }
 
-/**
- * User-defined metadata for tasks
- * All fields are optional and can be customized
- */
-export interface TaskMetadata extends Record<string, unknown> {
-    priority?: 'low' | 'medium' | 'high';
-    tags?: string[];
-    reasoning?: string;  // LLM's reasoning about task decisions
-    toolsUsed?: string[];  // Tools used by LLM to accomplish task
-    resourcesAccessed?: string[];  // Resources accessed by LLM
-    contextUsed?: string[];  // Key context pieces used in decision making
-    // Each string field max 1000 chars, arrays max 100 items
-}
-
-/**
- * Core task interface with system fields at root level
- */
 export interface Task {
-    // System fields (required)
-    path: string;  // Max depth of 8 levels
-    name: string;  // Max 200 chars
+    path: string;
+    name: string;
     type: TaskType;
     status: TaskStatus;
-    created: number;  // Timestamp of creation
-    updated: number;  // Timestamp of last update
-    version: number;  // Incremental version number
-    projectPath: string;  // Root project path
-
-    // Optional fields
-    description?: string;  // Max 2000 chars
+    projectPath: string;
+    created: number;
+    updated: number;
+    version: number;
+    metadata: Record<string, unknown>;
+    dependencies: string[];
+    subtasks: string[];
+    description?: string;
     parentPath?: string;
-    notes?: string[];  // Each note max 1000 chars
-    reasoning?: string;  // Max 2000 chars - LLM's reasoning about the task
-    dependencies: string[];  // Max 50 dependencies
-    subtasks: string[];  // Max 100 subtasks
-    
-    // User-defined metadata (flexible)
-    metadata: TaskMetadata;  // Custom fields defined by user
+    notes?: string[];
+    reasoning?: string;
 }
 
-export interface CreateTaskInput extends Record<string, unknown> {
-    path: string;  // Now required
+export interface CreateTaskInput {
     name: string;
+    type?: TaskType;
+    path?: string;
     parentPath?: string;
+    dependencies?: string[];
+    metadata?: Record<string, unknown>;
     description?: string;
-    type?: TaskType;
     notes?: string[];
     reasoning?: string;
-    dependencies?: string[];
-    metadata?: Partial<TaskMetadata>;
 }
 
-export interface UpdateTaskInput extends Record<string, unknown> {
+export interface UpdateTaskInput {
     name?: string;
-    description?: string;
-    type?: TaskType;
     status?: TaskStatus;
-    parentPath?: string;
+    dependencies?: string[];
+    metadata?: Record<string, unknown>;
+    description?: string;
     notes?: string[];
     reasoning?: string;
-    dependencies?: string[];
-    metadata?: Partial<TaskMetadata>;
+    type?: TaskType;
 }
 
+export const CONSTRAINTS = {
+    NAME_MAX_LENGTH: 255,
+    DESCRIPTION_MAX_LENGTH: 1000,
+    PATH_MAX_LENGTH: 255,
+    MAX_DEPENDENCIES: 100,
+    MAX_NOTES: 1000,
+    MAX_REASONING_LENGTH: 1000,
+    NOTE_MAX_LENGTH: 1000,
+    REASONING_MAX_LENGTH: 1000,
+    MAX_PATH_DEPTH: 10,
+    MAX_SUBTASKS: 100,
+    MAX_ARRAY_ITEMS: 100,
+    METADATA_STRING_MAX_LENGTH: 1000
+};
+
 export interface TaskResponse<T> {
     success: boolean;
-    data?: T;
-    error?: {
-        code: string;
-        message: string;
-    };
+    data: T;
     metadata: {
         timestamp: number;
         requestId: string;
@@ -95,32 +79,12 @@ export interface TaskResponse<T> {
     };
 }
 
-// Field length constraints
-export const CONSTRAINTS = {
-    NAME_MAX_LENGTH: 200,
-    DESCRIPTION_MAX_LENGTH: 2000,
-    NOTE_MAX_LENGTH: 1000,
-    REASONING_MAX_LENGTH: 2000,
-    METADATA_STRING_MAX_LENGTH: 1000,
-    MAX_DEPENDENCIES: 50,
-    MAX_SUBTASKS: 100,
-    MAX_NOTES: 100,
-    MAX_ARRAY_ITEMS: 100,
-    MAX_PATH_DEPTH: 8
-} as const;
-
-/**
- * Gets the task name from a path
- */
-export function getTaskName(path: string): string {
-    const segments = path.split('/');
-    return segments[segments.length - 1];
-}
-
 /**
  * Gets the parent path from a task path
+ * @param path Task path (e.g., "project/feature/task")
+ * @returns Parent path or undefined if no parent exists
  */
 export function getParentPath(path: string): string | undefined {
-    const segments = path.split('/');
-    return segments.length > 1 ? segments.slice(0, -1).join('/') : undefined;
+    const parts = path.split('/');
+    return parts.length > 1 ? parts.slice(0, -1).join('/') : undefined;
 }
diff --git a/src/types/transaction.ts b/src/types/transaction.ts
index 06b7b24..c046d04 100644
--- a/src/types/transaction.ts
+++ b/src/types/transaction.ts
@@ -3,49 +3,51 @@ import { Task } from './task.js';
 export type TransactionStatus = 'pending' | 'committed' | 'rolled_back';
 
 export interface Transaction {
-  id: string;
-  operations: Operation[];
-  timestamp: number;
-  status: TransactionStatus;
-  timeout?: number;
-  metadata?: {
-    retryCount?: number;
-    parentTransaction?: string;
-    initiator?: string;
-  };
+    id: string;
+    operations: Operation[];
+    timestamp: number;
+    status: TransactionStatus;
+    timeout?: number;
+    metadata?: {
+        retryCount?: number;
+        parentTransaction?: string;
+        initiator?: string;
+        completedAt?: number;
+        timedOut?: boolean;
+    };
 }
 
 export interface Operation {
-  id: string;
-  type: 'create' | 'update' | 'delete';
-  timestamp: number;
-  path: string;
-  task?: Task;
-  tasks?: Task[];
-  previousState?: Partial<Task>;
-  metadata?: Record<string, any>;
+    id: string;
+    type: 'create' | 'update' | 'delete';
+    timestamp: number;
+    path: string;
+    task?: Task;
+    tasks?: Task[];
+    previousState?: Partial<Task>;
+    metadata?: Record<string, any>;
 }
 
 export interface TransactionResult {
-  success: boolean;
-  transactionId: string;
-  error?: Error;
-  metadata?: {
-    duration: number;
-    retryCount?: number;
-  };
+    success: boolean;
+    transactionId: string;
+    error?: Error;
+    metadata?: {
+        duration: number;
+        retryCount?: number;
+    };
 }
 
 export interface TransactionOptions {
-  timeout?: number;
-  retryLimit?: number;
-  retryDelay?: number;
-  requireLock?: boolean;
+    timeout?: number;
+    retryLimit?: number;
+    retryDelay?: number;
+    requireLock?: boolean;
 }
 
 export const DEFAULT_TRANSACTION_OPTIONS: TransactionOptions = {
-  timeout: 30000, // 30 seconds
-  retryLimit: 3,
-  retryDelay: 1000, // 1 second
-  requireLock: true
+    timeout: 30000, // 30 seconds
+    retryLimit: 3,
+    retryDelay: 1000, // 1 second
+    requireLock: true
 };
diff --git a/src/utils/path-utils.ts b/src/utils/path-utils.ts
index 2a07a39..0a3683d 100644
--- a/src/utils/path-utils.ts
+++ b/src/utils/path-utils.ts
@@ -1,123 +1,150 @@
 import { createError, ErrorCodes } from '../errors/index.js';
 
 /**
- * Utilities for handling task paths with validation and normalization
+ * Path validation and manipulation utilities
  */
 export class PathUtils {
-  /**
-   * Normalizes a path string by:
-   * - Converting to lowercase
-   * - Replacing spaces with hyphens
-   * - Removing invalid characters
-   * - Normalizing slashes
-   */
-  static normalize(path: string): string {
-    // First convert Windows backslashes to forward slashes
-    const normalized = path.replace(/\\/g, '/');
-    
-    return normalized.toLowerCase()
-      .trim()
-      .replace(/\s+/g, '-')
-      .replace(/[^a-z0-9-\/]/g, '')
-      .replace(/\/+/g, '/') // Normalize multiple slashes to single
-      .replace(/^\/+|\/+$/g, ''); // Trim leading/trailing slashes
-  }
+    private static readonly PATH_SEPARATOR = '/';
+    private static readonly VALID_PATH_REGEX = /^[a-zA-Z0-9-_/]+$/;
+    private static readonly MAX_PATH_LENGTH = 255;
+    private static readonly MAX_SEGMENTS = 10;
 
-  /**
-   * Extracts the project path (first segment) from a full path
-   */
-  static getProjectPath(path: string): string {
-    const normalized = this.normalize(path);
-    const segments = normalized.split('/');
-    if (segments.length === 0) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Invalid path: empty path'
-      );
-    }
-    return segments[0];
-  }
+    /**
+     * Validates a path string
+     */
+    static validatePath(path: string): void {
+        if (!path) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                'Path cannot be empty',
+                'PathUtils.validatePath',
+                'Please provide a valid path'
+            );
+        }
+
+        if (path.length > this.MAX_PATH_LENGTH) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                `Path exceeds maximum length of ${this.MAX_PATH_LENGTH} characters`,
+                'PathUtils.validatePath',
+                'Path is too long'
+            );
+        }
+
+        if (!this.VALID_PATH_REGEX.test(path)) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                'Path contains invalid characters',
+                'PathUtils.validatePath',
+                'Path can only contain letters, numbers, hyphens, and underscores'
+            );
+        }
+
+        const segments = this.splitPath(path);
+        if (segments.length > this.MAX_SEGMENTS) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                `Path has too many segments (max: ${this.MAX_SEGMENTS})`,
+                'PathUtils.validatePath',
+                'Path has too many segments'
+            );
+        }
 
-  /**
-   * Checks if a path is a valid subpath of another path
-   */
-  static isSubPath(parentPath: string, childPath: string): boolean {
-    const normalizedParent = this.normalize(parentPath);
-    const normalizedChild = this.normalize(childPath);
-    return normalizedChild.startsWith(`${normalizedParent}/`);
-  }
+        for (const segment of segments) {
+            if (!segment) {
+                throw createError(
+                    ErrorCodes.VALIDATION_ERROR,
+                    'Path contains empty segments',
+                    'PathUtils.validatePath',
+                    'Path segments cannot be empty'
+                );
+            }
+        }
+    }
 
-  /**
-   * Generates a valid path from a name and optional parent path
-   */
-  static generatePath(name: string, parentPath?: string): string {
-    const safeName = this.normalize(name);
-    if (!safeName) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Invalid name: cannot generate path from empty name'
-      );
+    /**
+     * Splits a path into segments
+     */
+    static splitPath(path: string): string[] {
+        return path.split(this.PATH_SEPARATOR).filter(Boolean);
     }
-    return parentPath ? `${this.normalize(parentPath)}/${safeName}` : safeName;
-  }
 
-  /**
-   * Validates a path string against path requirements
-   * Throws an error if the path is invalid
-   */
-  static validatePath(path: string): void {
-    if (!path) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Path cannot be empty'
-      );
+    /**
+     * Joins path segments
+     */
+    static joinPath(...segments: string[]): string {
+        return segments.filter(Boolean).join(this.PATH_SEPARATOR);
     }
 
-    const normalized = this.normalize(path);
-    
-    // Check for full path format
-    if (!normalized.includes('/')) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Path must be fully qualified (e.g., "project/feature/task")'
-      );
+    /**
+     * Gets the parent path
+     */
+    static getParentPath(path: string): string {
+        const segments = this.splitPath(path);
+        if (segments.length <= 1) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                'Cannot get parent of root path',
+                'PathUtils.getParentPath',
+                'This path has no parent'
+            );
+        }
+        return segments.slice(0, -1).join(this.PATH_SEPARATOR);
     }
 
-    // Validate path format (allow both forward and backslashes in input, but normalize to forward slashes)
-    const pathRegex = /^[a-z0-9-]+(?:[\/\\][a-z0-9-]+)*$/;
-    if (!pathRegex.test(normalized)) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Path must contain only letters, numbers, hyphens, and forward slashes'
-      );
+    /**
+     * Gets the last segment of a path
+     */
+    static getBaseName(path: string): string {
+        const segments = this.splitPath(path);
+        if (!segments.length) {
+            throw createError(
+                ErrorCodes.VALIDATION_ERROR,
+                'Cannot get base name of empty path',
+                'PathUtils.getBaseName',
+                'Path is empty'
+            );
+        }
+        return segments[segments.length - 1];
     }
 
-    // Check path depth (prevent excessive nesting)
-    const depth = normalized.split('/').length;
-    if (depth > 10) {
-      throw createError(
-        ErrorCodes.INVALID_INPUT,
-        'Path depth exceeds maximum allowed (10 levels)'
-      );
+    /**
+     * Checks if a path is a child of another path
+     */
+    static isChildPath(parentPath: string, childPath: string): boolean {
+        if (!parentPath || !childPath) {
+            return false;
+        }
+        const parentSegments = this.splitPath(parentPath);
+        const childSegments = this.splitPath(childPath);
+        if (childSegments.length <= parentSegments.length) {
+            return false;
+        }
+        return parentSegments.every((segment, index) => segment === childSegments[index]);
     }
-  }
 
-  /**
-   * Gets the parent path of a given path
-   * Returns null if the path has no parent (is a root path)
-   */
-  static getParentPath(path: string): string | null {
-    const normalized = this.normalize(path);
-    const lastSlashIndex = normalized.lastIndexOf('/');
-    return lastSlashIndex === -1 ? null : normalized.substring(0, lastSlashIndex);
-  }
+    /**
+     * Gets the relative path from one path to another
+     */
+    static getRelativePath(from: string, to: string): string {
+        const fromSegments = this.splitPath(from);
+        const toSegments = this.splitPath(to);
+        let commonPrefixLength = 0;
+
+        // Find common prefix
+        while (
+            commonPrefixLength < fromSegments.length &&
+            commonPrefixLength < toSegments.length &&
+            fromSegments[commonPrefixLength] === toSegments[commonPrefixLength]
+        ) {
+            commonPrefixLength++;
+        }
 
-  /**
-   * Gets the name (last segment) of a path
-   */
-  static getName(path: string): string {
-    const normalized = this.normalize(path);
-    const segments = normalized.split('/');
-    return segments[segments.length - 1];
-  }
+        // Build relative path
+        const upCount = fromSegments.length - commonPrefixLength;
+        const upSegments = Array(upCount).fill('..');
+        const downSegments = toSegments.slice(commonPrefixLength);
+
+        return [...upSegments, ...downSegments].join(this.PATH_SEPARATOR);
+    }
 }
